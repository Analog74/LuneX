{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{25F8CD53-1760-411A-B8F4-88F71CF9A91A}",
  "Source": "local ipairs = ipairs\nlocal BLACK_COLOR3 = Color3.new()\n\n-- Generic Roblox DataType lerp function.\nlocal function RobloxLerp(V0, V1)\n\treturn function(Alpha)\n\t\treturn V0:Lerp(V1, Alpha)\n\tend\nend\n\nlocal function Lerp(Start, Finish, Alpha)\n\treturn Start + Alpha * (Finish - Start)\nend\n\nlocal function SortByTime(A, B)\n\treturn A.Time < B.Time\nend\n\nlocal function Color3Lerp(C0, C1)\n\tlocal L0, U0, V0\n\tlocal R0, G0, B0 = C0.R, C0.G, C0.B\n\tR0 = R0 < 0.0404482362771076 and R0 / 12.92 or 0.87941546140213 * (R0 + 0.055) ^ 2.4\n\tG0 = G0 < 0.0404482362771076 and G0 / 12.92 or 0.87941546140213 * (G0 + 0.055) ^ 2.4\n\tB0 = B0 < 0.0404482362771076 and B0 / 12.92 or 0.87941546140213 * (B0 + 0.055) ^ 2.4\n\n\tlocal Y0 = 0.2125862307855956 * R0 + 0.71517030370341085 * G0 + 0.0722004986433362 * B0\n\tlocal Z0 = 3.6590806972265883 * R0 + 11.4426895800574232 * G0 + 4.1149915024264843 * B0\n\tlocal _L0 = Y0 > 0.008856451679035631 and 116 * Y0 ^ (1 / 3) - 16 or 903.296296296296 * Y0\n\n\tif Z0 > 1E-15 then\n\t\tlocal X = 0.9257063972951867 * R0 - 0.8333736323779866 * G0 - 0.09209820666085898 * B0\n\t\tL0, U0, V0 = _L0, _L0 * X / Z0, _L0 * (9 * Y0 / Z0 - 0.46832)\n\telse\n\t\tL0, U0, V0 = _L0, -0.19783 * _L0, -0.46832 * _L0\n\tend\n\n\tlocal L1, U1, V1\n\tlocal R1, G1, B1 = C1.R, C1.G, C1.B\n\tR1 = R1 < 0.0404482362771076 and R1 / 12.92 or 0.87941546140213 * (R1 + 0.055) ^ 2.4\n\tG1 = G1 < 0.0404482362771076 and G1 / 12.92 or 0.87941546140213 * (G1 + 0.055) ^ 2.4\n\tB1 = B1 < 0.0404482362771076 and B1 / 12.92 or 0.87941546140213 * (B1 + 0.055) ^ 2.4\n\n\tlocal Y1 = 0.2125862307855956 * R1 + 0.71517030370341085 * G1 + 0.0722004986433362 * B1\n\tlocal Z1 = 3.6590806972265883 * R1 + 11.4426895800574232 * G1 + 4.1149915024264843 * B1\n\tlocal _L1 = Y1 > 0.008856451679035631 and 116 * Y1 ^ (1 / 3) - 16 or 903.296296296296 * Y1\n\n\tif Z1 > 1E-15 then\n\t\tlocal X = 0.9257063972951867 * R1 - 0.8333736323779866 * G1 - 0.09209820666085898 * B1\n\t\tL1, U1, V1 = _L1, _L1 * X / Z1, _L1 * (9 * Y1 / Z1 - 0.46832)\n\telse\n\t\tL1, U1, V1 = _L1, -0.19783 * _L1, -0.46832 * _L1\n\tend\n\n\treturn function(Alpha)\n\t\tlocal L = (1 - Alpha) * L0 + Alpha * L1\n\t\tif L < 0.0197955 then\n\t\t\treturn BLACK_COLOR3\n\t\tend\n\n\t\tlocal U = ((1 - Alpha) * U0 + Alpha * U1) / L + 0.19783\n\t\tlocal V = ((1 - Alpha) * V0 + Alpha * V1) / L + 0.46832\n\n\t\tlocal Y = (L + 16) / 116\n\t\tY = Y > 0.206896551724137931 and Y * Y * Y or 0.12841854934601665 * Y - 0.01771290335807126\n\t\tlocal X = Y * U / V\n\t\tlocal Z = Y * ((3 - 0.75 * U) / V - 5)\n\n\t\tlocal R = 7.2914074 * X - 1.5372080 * Y - 0.4986286 * Z\n\t\tlocal G = -2.1800940 * X + 1.8757561 * Y + 0.0415175 * Z\n\t\tlocal B = 0.1253477 * X - 0.2040211 * Y + 1.0569959 * Z\n\n\t\tif R < 0 and R < G and R < B then\n\t\t\tR, G, B = 0, G - R, B - R\n\t\telseif G < 0 and G < B then\n\t\t\tR, G, B = R - G, 0, B - G\n\t\telseif B < 0 then\n\t\t\tR, G, B = R - B, G - B, 0\n\t\tend\n\n\t\tR = R < 3.1306684425E-3 and 12.92 * R or 1.055 * R ^ (1 / 2.4) - 0.055 -- 3.1306684425E-3\n\t\tG = G < 3.1306684425E-3 and 12.92 * G or 1.055 * G ^ (1 / 2.4) - 0.055\n\t\tB = B < 3.1306684425E-3 and 12.92 * B or 1.055 * B ^ (1 / 2.4) - 0.055\n\n\t\tR = R > 1 and 1 or R < 0 and 0 or R\n\t\tG = G > 1 and 1 or G < 0 and 0 or G\n\t\tB = B > 1 and 1 or B < 0 and 0 or B\n\n\t\treturn Color3.new(R, G, B)\n\tend\nend\n\nlocal Lerps = setmetatable({\n\tboolean = function(V0, V1)\n\t\treturn function(Alpha)\n\t\t\tif Alpha < 0.5 then\n\t\t\t\treturn V0\n\t\t\telse\n\t\t\t\treturn V1\n\t\t\tend\n\t\tend\n\tend;\n\n\tnumber = function(V0, V1)\n\t\tlocal Delta = V1 - V0\n\t\treturn function(Alpha)\n\t\t\treturn V0 + Delta * Alpha\n\t\tend\n\tend;\n\n\tstring = function(V0, V1)\n\t\tlocal RegularString = false\n\n\t\tlocal N0, D do\n\t\t\tlocal Sign0, H0, M0, S0 = string.match(V0, \"^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$\")\n\t\t\tlocal Sign1, H1, M1, S1 = string.match(V1, \"^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$\")\n\t\t\tif Sign0 and Sign1 then\n\t\t\t\tN0 = 3600 * (tonumber(H0) or 0) + 60 * (tonumber(M0) or 0) + (tonumber(S0) or 0)\n\t\t\t\tlocal N1 = 3600 * (tonumber(H1) or 0) + 60 * (tonumber(M1) or 0) + (tonumber(S1) or 0)\n\t\t\t\tif Sign0 == \"-\" then\n\t\t\t\t\tN0 = -N0\n\t\t\t\tend\n\n\t\t\t\tD = (43200 + (Sign1 ~= \"-\" and N1 or -N1) - N0) % 86400 - 43200\n\t\t\telse\n\t\t\t\tRegularString = true\n\t\t\tend\n\t\tend\n\n\t\tif RegularString then\n\t\t\tlocal Length = #V1\n\t\t\treturn function(Alpha)\n\t\t\t\tAlpha = 1 + Length * Alpha\n\t\t\t\treturn string.sub(V1, 1, Alpha < Length and Alpha or Length)\n\t\t\tend\n\t\telse\n\t\t\treturn function(Alpha)\n\t\t\t\tlocal FS = (N0 + D * Alpha) % 86400\n\t\t\t\tlocal S = math.abs(FS)\n\t\t\t\treturn string.format(\n\t\t\t\t\tFS < 0 and \"-%.2u:%.2u:%.2u\" or \"%.2u:%.2u:%.2u\",\n\t\t\t\t\t(S - S % 3600) / 3600,\n\t\t\t\t\t(S % 3600 - S % 60) / 60,\n\t\t\t\t\tS % 60\n\t\t\t\t)\n\t\t\tend\n\t\tend\n\tend;\n\n\tCFrame = RobloxLerp;\n\tColor3 = Color3Lerp;\n\tNumberRange = function(V0, V1)\n\t\tlocal Min0, Max0 = V0.Min, V0.Max\n\t\tlocal DeltaMin, DeltaMax = V1.Min - Min0, V1.Max - Max0\n\n\t\treturn function(Alpha)\n\t\t\treturn NumberRange.new(Min0 + Alpha * DeltaMin, Max0 + Alpha * DeltaMax)\n\t\tend\n\tend;\n\n\tNumberSequenceKeypoint = function(V0, V1)\n\t\tlocal T0, Value0, E0 = V0.Time, V0.Value, V0.Envelope\n\t\tlocal DT, DV, DE = V1.Time - T0, V1.Value - Value0, V1.Envelope - E0\n\n\t\treturn function(Alpha)\n\t\t\treturn NumberSequenceKeypoint.new(T0 + Alpha * DT, Value0 + Alpha * DV, E0 + Alpha * DE)\n\t\tend\n\tend;\n\n\tPhysicalProperties = function(V0, V1)\n\t\tlocal D0, E0, EW0, F0, FW0 =\n\t\t\tV0.Density, V0.Elasticity,\n\t\tV0.ElasticityWeight, V0.Friction,\n\t\tV0.FrictionWeight\n\n\t\tlocal DD, DE, DEW, DF, DFW =\n\t\t\tV1.Density - D0, V1.Elasticity - E0,\n\t\tV1.ElasticityWeight - EW0, V1.Friction - F0,\n\t\tV1.FrictionWeight - FW0\n\n\t\treturn function(Alpha)\n\t\t\treturn PhysicalProperties.new(\n\t\t\t\tD0 + Alpha * DD,\n\t\t\t\tE0 + Alpha * DE, EW0 + Alpha * DEW,\n\t\t\t\tF0 + Alpha * DF, FW0 + Alpha * DFW\n\t\t\t)\n\t\tend\n\tend;\n\n\tRay = function(V0, V1)\n\t\tlocal O0, D0, O1, D1 = V0.Origin, V0.Direction, V1.Origin, V1.Direction\n\t\tlocal OX0, OY0, OZ0, DX0, DY0, DZ0 = O0.X, O0.Y, O0.Z, D0.X, D0.Y, D0.Z\n\t\tlocal DOX, DOY, DOZ, DDX, DDY, DDZ = O1.X - OX0, O1.Y - OY0, O1.Z - OZ0, D1.X - DX0, D1.Y - DY0, D1.Z - DZ0\n\n\t\treturn function(Alpha)\n\t\t\treturn Ray.new(\n\t\t\t\tVector3.new(OX0 + Alpha * DOX, OY0 + Alpha * DOY, OZ0 + Alpha * DOZ),\n\t\t\t\tVector3.new(DX0 + Alpha * DDX, DY0 + Alpha * DDY, DZ0 + Alpha * DDZ)\n\t\t\t)\n\t\tend\n\tend;\n\n\tUDim = function(V0, V1)\n\t\tlocal SC, OF = V0.Scale, V0.Offset\n\t\tlocal DSC, DOF = V1.Scale - SC, V1.Offset - OF\n\n\t\treturn function(Alpha)\n\t\t\treturn UDim.new(SC + Alpha * DSC, OF + Alpha * DOF)\n\t\tend\n\tend;\n\n\tUDim2 = RobloxLerp;\n\tVector2 = RobloxLerp;\n\tVector3 = RobloxLerp;\n\tRect = function(V0, V1)\n\t\treturn function(Alpha)\n\t\t\treturn Rect.new(\n\t\t\t\tV0.Min.X + Alpha * (V1.Min.X - V0.Min.X), V0.Min.Y + Alpha * (V1.Min.Y - V0.Min.Y),\n\t\t\t\tV0.Max.X + Alpha * (V1.Max.X - V0.Max.X), V0.Max.Y + Alpha * (V1.Max.Y - V0.Max.Y)\n\t\t\t)\n\t\tend\n\tend;\n\n\tRegion3 = function(V0, V1)\n\t\treturn function(Alpha)\n\t\t\tlocal imin = Lerp(V0.CFrame * (-V0.Size / 2), V1.CFrame * (-V1.Size / 2), Alpha)\n\t\t\tlocal imax = Lerp(V0.CFrame * (V0.Size / 2), V1.CFrame * (V1.Size / 2), Alpha)\n\n\t\t\tlocal iminx = imin.X\n\t\t\tlocal imaxx = imax.X\n\t\t\tlocal iminy = imin.Y\n\t\t\tlocal imaxy = imax.Y\n\t\t\tlocal iminz = imin.Z\n\t\t\tlocal imaxz = imax.Z\n\n\t\t\treturn Region3.new(\n\t\t\t\tVector3.new(iminx < imaxx and iminx or imaxx, iminy < imaxy and iminy or imaxy, iminz < imaxz and iminz or imaxz),\n\t\t\t\tVector3.new(iminx > imaxx and iminx or imaxx, iminy > imaxy and iminy or imaxy, iminz > imaxz and iminz or imaxz)\n\t\t\t)\n\t\tend\n\tend;\n\n\tNumberSequence = function(V0, V1)\n\t\treturn function(Alpha)\n\t\t\tlocal keypoints = {}\n\t\t\tlocal addedTimes = {}\n\t\t\tlocal keylength = 0\n\n\t\t\tfor _, ap in ipairs(V0.Keypoints) do\n\t\t\t\tlocal closestAbove, closestBelow\n\n\t\t\t\tfor _, bp in ipairs(V1.Keypoints) do\n\t\t\t\t\tif bp.Time == ap.Time then\n\t\t\t\t\t\tclosestAbove, closestBelow = bp, bp\n\t\t\t\t\t\tbreak\n\t\t\t\t\telseif bp.Time < ap.Time and (closestBelow == nil or bp.Time > closestBelow.Time) then\n\t\t\t\t\t\tclosestBelow = bp\n\t\t\t\t\telseif bp.Time > ap.Time and (closestAbove == nil or bp.Time < closestAbove.Time) then\n\t\t\t\t\t\tclosestAbove = bp\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tlocal bValue, bEnvelope\n\t\t\t\tif closestAbove == closestBelow then\n\t\t\t\t\tbValue, bEnvelope = closestAbove.Value, closestAbove.Envelope\n\t\t\t\telse\n\t\t\t\t\tlocal p = (ap.Time - closestBelow.Time) / (closestAbove.Time - closestBelow.Time)\n\t\t\t\t\tbValue = (closestAbove.Value - closestBelow.Value) * p + closestBelow.Value\n\t\t\t\t\tbEnvelope = (closestAbove.Envelope - closestBelow.Envelope) * p + closestBelow.Envelope\n\t\t\t\tend\n\n\t\t\t\tkeylength += 1\n\t\t\t\tkeypoints[keylength] = NumberSequenceKeypoint.new(ap.Time, (bValue - ap.Value) * Alpha + ap.Value, (bEnvelope - ap.Envelope) * Alpha + ap.Envelope)\n\t\t\t\taddedTimes[ap.Time] = true\n\t\t\tend\n\n\t\t\tfor _, bp in ipairs(V1.Keypoints) do\n\t\t\t\tif not addedTimes[bp.Time] then\n\t\t\t\t\tlocal closestAbove, closestBelow\n\n\t\t\t\t\tfor _, ap in ipairs(V0.Keypoints) do\n\t\t\t\t\t\tif ap.Time == bp.Time then\n\t\t\t\t\t\t\tclosestAbove, closestBelow = ap, ap\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telseif ap.Time < bp.Time and (closestBelow == nil or ap.Time > closestBelow.Time) then\n\t\t\t\t\t\t\tclosestBelow = ap\n\t\t\t\t\t\telseif ap.Time > bp.Time and (closestAbove == nil or ap.Time < closestAbove.Time) then\n\t\t\t\t\t\t\tclosestAbove = ap\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\tlocal aValue, aEnvelope\n\t\t\t\t\tif closestAbove == closestBelow then\n\t\t\t\t\t\taValue, aEnvelope = closestAbove.Value, closestAbove.Envelope\n\t\t\t\t\telse\n\t\t\t\t\t\tlocal p = (bp.Time - closestBelow.Time) / (closestAbove.Time - closestBelow.Time)\n\t\t\t\t\t\taValue = (closestAbove.Value - closestBelow.Value) * p + closestBelow.Value\n\t\t\t\t\t\taEnvelope = (closestAbove.Envelope - closestBelow.Envelope) * p + closestBelow.Envelope\n\t\t\t\t\tend\n\n\t\t\t\t\tkeylength += 1\n\t\t\t\t\tkeypoints[keylength] = NumberSequenceKeypoint.new(bp.Time, (bp.Value - aValue) * Alpha + aValue, (bp.Envelope - aEnvelope) * Alpha + aEnvelope)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\ttable.sort(keypoints, SortByTime)\n\t\t\treturn NumberSequence.new(keypoints)\n\t\tend\n\tend;\n\n\tColorSequence = function(V0, V1)\n\t\treturn function(Alpha)\n\t\t\tlocal keypoints = {}\n\t\t\tlocal addedTimes = {}\n\t\t\tlocal keylength = 0\n\n\t\t\tfor _, ap in ipairs(V0.Keypoints) do\n\t\t\t\tlocal closestAbove, closestBelow\n\n\t\t\t\tfor _, bp in ipairs(V1.Keypoints) do\n\t\t\t\t\tif bp.Time == ap.Time then\n\t\t\t\t\t\tclosestAbove, closestBelow = bp, bp\n\t\t\t\t\t\tbreak\n\t\t\t\t\telseif bp.Time < ap.Time and (closestBelow == nil or bp.Time > closestBelow.Time) then\n\t\t\t\t\t\tclosestBelow = bp\n\t\t\t\t\telseif bp.Time > ap.Time and (closestAbove == nil or bp.Time < closestAbove.Time) then\n\t\t\t\t\t\tclosestAbove = bp\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tlocal bValue\n\t\t\t\tif closestAbove == closestBelow then\n\t\t\t\t\tbValue = closestAbove.Value\n\t\t\t\telse\n\t\t\t\t\tbValue = Color3Lerp(closestBelow.Value, closestAbove.Value)((ap.Time - closestBelow.Time) / (closestAbove.Time - closestBelow.Time))\n\t\t\t\tend\n\n\t\t\t\tkeylength += 1\n\t\t\t\tkeypoints[keylength] = ColorSequenceKeypoint.new(ap.Time, Color3Lerp(ap.Value, bValue)(Alpha))\n\t\t\t\taddedTimes[ap.Time] = true\n\t\t\tend\n\n\t\t\tfor _, bp in ipairs(V1.Keypoints) do\n\t\t\t\tif not addedTimes[bp.Time] then\n\t\t\t\t\tlocal closestAbove, closestBelow\n\n\t\t\t\t\tfor _, ap in ipairs(V0.Keypoints) do\n\t\t\t\t\t\tif ap.Time == bp.Time then\n\t\t\t\t\t\t\tclosestAbove, closestBelow = ap, ap\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telseif ap.Time < bp.Time and (closestBelow == nil or ap.Time > closestBelow.Time) then\n\t\t\t\t\t\t\tclosestBelow = ap\n\t\t\t\t\t\telseif ap.Time > bp.Time and (closestAbove == nil or ap.Time < closestAbove.Time) then\n\t\t\t\t\t\t\tclosestAbove = ap\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\tlocal aValue\n\t\t\t\t\tif closestAbove == closestBelow then\n\t\t\t\t\t\taValue = closestAbove.Value\n\t\t\t\t\telse\n\t\t\t\t\t\taValue = Color3Lerp(closestBelow.Value, closestAbove.Value)((bp.Time - closestBelow.Time) / (closestAbove.Time - closestBelow.Time))\n\t\t\t\t\tend\n\n\t\t\t\t\tkeylength += 1\n\t\t\t\t\tkeypoints[keylength] = ColorSequenceKeypoint.new(bp.Time, Color3Lerp(bp.Value, aValue)(Alpha))\n\t\t\t\tend\n\t\t\tend\n\n\t\t\ttable.sort(keypoints, SortByTime)\n\t\t\treturn ColorSequence.new(keypoints)\n\t\tend\n\tend;\n}, {\n\t__index = function(_, Index)\n\t\terror(\"No lerp function is defined for type \" .. tostring(Index) .. \".\", 4)\n\tend;\n\n\t__newindex = function(_, Index)\n\t\terror(\"No lerp function is defined for type \" .. tostring(Index) .. \".\", 4)\n\tend;\n})\n\nreturn Lerps",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 26681, time: 142155861, random: 1232354692393223026 })>"
}