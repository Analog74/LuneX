{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{FC324C28-966D-4719-8E79-49E132050DAF}",
  "Source": "-- Custom enum implementation that provides an effective way to compare, send\n-- and store values. Instead of returning a userdata value, enum items return\n-- their corresponding itemValue (an integer) when indexed. Enum items can\n-- also associate a 'property', specified as the third element, which can be\n-- retrieved by doing ``enum.getProperty(ITEM_NAME_OR_VALUE)``\n-- This ultimately means groups of data can be easily categorised, efficiently\n-- transmitted over networks and saved without throwing errors.\n-- Ben Horton (ForeverHD)\n\n\n\n-- LOCAL\nlocal Enum = {}\nlocal enums = {}\nEnum.enums = enums\n\n\n\n-- METHODS\nfunction Enum.createEnum(enumName, details)\n\tassert(typeof(enumName) == \"string\", \"bad argument #1 - enums must be created using a string name!\")\n\tassert(typeof(details) == \"table\", \"bad argument #2 - enums must be created using a table!\")\n\tassert(not enums[enumName], (\"enum '%s' already exists!\"):format(enumName))\n\t\n\tlocal enum = {}\n\tlocal usedNames = {}\n\tlocal usedValues = {}\n\tlocal usedProperties = {}\n\tlocal enumMetaFunctions = {\n\t\tgetName = function(valueOrProperty)\n\t\t\tvalueOrProperty = tostring(valueOrProperty)\n\t\t\tlocal index = usedValues[valueOrProperty]\n\t\t\tif not index then\n\t\t\t\tindex = usedProperties[valueOrProperty]\n\t\t\tend\n\t\t\tif index then\n\t\t\t\treturn details[index][1]\n\t\t\tend\n\t\tend,\n\t\tgetValue = function(nameOrProperty)\n\t\t\tnameOrProperty = tostring(nameOrProperty)\n\t\t\tlocal index = usedNames[nameOrProperty]\n\t\t\tif not index then\n\t\t\t\tindex = usedProperties[nameOrProperty]\n\t\t\tend\n\t\t\tif index then\n\t\t\t\treturn details[index][2]\n\t\t\tend\n\t\tend,\n\t\tgetProperty = function(nameOrValue)\n\t\t\tnameOrValue = tostring(nameOrValue)\n\t\t\tlocal index = usedNames[nameOrValue]\n\t\t\tif not index then\n\t\t\t\tindex = usedValues[nameOrValue]\n\t\t\tend\n\t\t\tif index then\n\t\t\t\treturn details[index][3]\n\t\t\tend\n\t\tend\n\t}\n\tfor i, detail in pairs(details) do\n\t\tassert(typeof(detail) == \"table\", (\"bad argument #2.%s - details must only be comprised of tables!\"):format(i))\n\t\tlocal name = detail[1]\n\t\tassert(typeof(name) == \"string\", (\"bad argument #2.%s.1 - detail name must be a string!\"):format(i))\n\t\tassert(typeof(not usedNames[name]), (\"bad argument #2.%s.1 - the detail name '%s' already exists!\"):format(i, name))\n\t\tassert(typeof(not enumMetaFunctions[name]), (\"bad argument #2.%s.1 - that name is reserved.\"):format(i, name))\n\t\tusedNames[tostring(name)] = i\n\t\tlocal value = detail[2]\n\t\tlocal valueString = tostring(value)\n\t\t--assert(typeof(value) == \"number\" and math.ceil(value)/value == 1, (\"bad argument #2.%s.2 - detail value must be an integer!\"):format(i))\n\t\tassert(typeof(not usedValues[valueString]), (\"bad argument #2.%s.2 - the detail value '%s' already exists!\"):format(i, valueString))\n\t\tusedValues[valueString] = i\n\t\tlocal property = detail[3]\n\t\tif property then\n\t\t\tassert(typeof(not usedProperties[property]), (\"bad argument #2.%s.3 - the detail property '%s' already exists!\"):format(i, tostring(property)))\n\t\t\tusedProperties[tostring(property)] = i\n\t\tend\n\t\tenum[name] = value\n\t\tsetmetatable(enum, {\n\t\t\t__index = function(_, index)\n\t\t\t\treturn(enumMetaFunctions[index])\n\t\t\tend\n\t\t})\n\tend\n\t\n\tenums[enumName] = enum\n\treturn enum\nend\n\nfunction Enum.getEnums()\n\treturn enums\nend\n\n\n\n-- SETUP ENUMS\nlocal createEnum = Enum.createEnum\nfor _, childModule in pairs(script:GetChildren()) do\n\tif childModule:IsA(\"ModuleScript\") then\n\t\tlocal enumDetail = require(childModule)\n\t\tcreateEnum(childModule.Name, enumDetail)\n\tend\nend\n\n--[[\n-- Example enum\ncreateEnum(\"Color\", {\n\t{\"White\", 1, Color3.fromRGB(255, 255, 255)},\n\t{\"Black\", 2, Color3.fromRGB(0, 0, 0)},\n})\n--]]\n\n\n\nreturn Enum\n",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25882, time: 142155861, random: 1232354692393223026 })>"
}