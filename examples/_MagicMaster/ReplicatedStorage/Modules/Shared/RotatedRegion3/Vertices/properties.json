{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: Vertices)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: Vertices)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: Vertices)>",
  "Sandboxed": false,
  "ScriptGuid": "{F467C740-DEA0-4540-8FE2-5634C7D4FC2D}",
  "Source": "-- CONSTANTS\n\nlocal PI2 = math.pi*2\nlocal PHI = (1 + math.sqrt(5)) / 2\n\nlocal RIGHT \t= Vector3.new(1, 0, 0)\nlocal UP \t\t= Vector3.new(0, 1, 0)\nlocal BACK \t\t= Vector3.new(0, 0, 1)\nlocal LEFT \t\t= Vector3.new(-1, 0, 0)\nlocal DOWN \t\t= Vector3.new(0, -1, 0)\nlocal FORWARD \t= Vector3.new(0, 0, -1)\n\nlocal CORNERS = {\n\tVector3.new(1, 1, 1);\n\tVector3.new(-1, 1, 1);\n\tVector3.new(-1, 1, -1);\n\tVector3.new(1, 1, -1);\n\tVector3.new(1, -1, 1);\n\tVector3.new(-1, -1, 1);\n\tVector3.new(-1, -1, -1);\n\tVector3.new(1, -1, -1);\n}\n\n-- VERTICE INDEX ARRAYS\n\nlocal BLOCK = {1, 2, 3, 4, 5, 6, 7, 8}\nlocal WEDGE = {1, 2, 5, 6, 7, 8}\nlocal CORNERWEDGE = {4, 5, 6, 7, 8}\n\n-- VERTICE FUNCTIONS\n\nlocal function fromIndexArray(array)\n\tlocal output = {}\n\tfor i = 1, #array do\n\t\toutput[i] = CORNERS[array[i]]\n\tend\n\treturn output\nend\n\nlocal function cylinder(n)\n\tlocal output = {}\n\tlocal arc = PI2 / n\n\tfor i = 1, n do\n\t\tlocal vi = CFrame.fromAxisAngle(RIGHT, i*arc) * UP\n\t\toutput[i] = RIGHT + vi\n\t\toutput[n + i] = LEFT + vi\n\tend\n\treturn output\nend\n\nlocal function icoSphere(n)\n\tlocal verts = {\n\t\tVector3.new(-1,  PHI, 0),\n\t\tVector3.new(1,  PHI, 0),\n\t\tVector3.new(-1, -PHI, 0),\n\t\tVector3.new(1, -PHI, 0),\n\t\t\n\t\tVector3.new(0, -1,  PHI),\n\t\tVector3.new(0,  1,  PHI),\n\t\tVector3.new(0, -1, -PHI),\n\t\tVector3.new(0,  1, -PHI),\n\t\t\n\t\tVector3.new(PHI, 0, -1),\n\t\tVector3.new(PHI, 0,  1),\n\t\tVector3.new(-PHI, 0, -1),\n\t\tVector3.new(-PHI, 0,  1)\n\t}\n\t\n\tlocal indices = {\n\t\t1, 12, 6,\n\t\t1, 6, 2,\n\t\t1, 2, 8,\n\t\t1, 8, 11,\n\t\t1, 11, 12,\n\t\t\n\t\t2, 6, 10,\n\t\t6, 12, 5,\n\t\t12, 11, 3,\n\t\t11, 8, 7,\n\t\t8, 2, 9,\n\t\t\n\t\t4, 10, 5,\n\t\t4, 5, 3,\n\t\t4, 3, 7,\n\t\t4, 7, 9,\n\t\t4, 9, 10,\n\t\t\n\t\t5, 10, 6,\n\t\t3, 5, 12,\n\t\t7, 3, 11,\n\t\t9, 7, 8,\n\t\t10, 9, 2\n\t}\n\t\n\tlocal splits = {}\n\t\n\tlocal function split(i, j)\n\t\tlocal key = i < j and (i .. \",\" .. j) or (j .. \",\" .. i)\n\t\t\n\t\tif (not splits[key]) then\n\t\t\tverts[#verts+1] = (verts[i] + verts[j]) / 2\n\t\t\tsplits[key] = #verts\n\t\tend\n\t\t\n\t\treturn splits[key]\n\tend\n\t\n\tfor _ = 1, n do\n\t\tfor  i = #indices, 1, -3 do\n\t\t\tlocal v1, v2, v3 = indices[i - 2], indices[i - 1], indices[i]\n\t\t\tlocal a = split(v1, v2)\n\t\t\tlocal b = split(v2, v3)\n\t\t\tlocal c = split(v3, v1)\n\t\t\t\n\t\t\tindices[#indices+1] = v1\n\t\t\tindices[#indices+1] = a\n\t\t\tindices[#indices+1] = c\n\t\t\t\n\t\t\tindices[#indices+1] = v2\n\t\t\tindices[#indices+1] = b\n\t\t\tindices[#indices+1] = a\n\t\t\t\n\t\t\tindices[#indices+1] = v3\n\t\t\tindices[#indices+1] = c\n\t\t\tindices[#indices+1] = b\n\t\t\t\n\t\t\tindices[#indices+1] = a\n\t\t\tindices[#indices+1] = b\n\t\t\tindices[#indices+1] = c\n\t\t\t\n\t\t\ttable.remove(indices, i)\n\t\t\ttable.remove(indices, i - 1)\n\t\t\ttable.remove(indices, i - 2)\n\t\tend\n\tend\n\t\n\t-- normalize\n\tfor i = 1, #verts do\n\t\tverts[i] = verts[i].Unit\n\tend\n\t\n\treturn verts\nend\n\n-- Useful functions\n\nlocal function vertShape(cf, size2, array)\n\tlocal output = {}\n\tfor i = 1, #array do\n\t\toutput[i] = cf:PointToWorldSpace(array[i] * size2)\n\tend\n\treturn output\nend\n\nlocal function getCentroidFromSet(set)\n\tlocal sum = set[1]\n\tfor i = 2, #set do\n\t\tsum = sum + set[2]\n\tend\n\treturn sum / #set\nend\n\nlocal function classify(part)\n\tif (part.ClassName == \"Part\") then\n\t\tif (part.Shape == Enum.PartType.Block) then\n\t\t\treturn \"Block\"\n\t\telseif (part.Shape == Enum.PartType.Cylinder) then\n\t\t\treturn \"Cylinder\"\n\t\telseif (part.Shape == Enum.PartType.Ball) then\n\t\t\treturn \"Ball\"\n\t\tend;\n\telseif (part.ClassName == \"WedgePart\") then\n\t\treturn \"Wedge\"\n\telseif (part.ClassName == \"CornerWedgePart\") then\n\t\treturn \"CornerWedge\"\n\telseif (part:IsA(\"BasePart\")) then -- mesh, CSG, truss, etc... just use block\n\t\treturn \"Block\"\n\tend\nend\n\n-- \n\nlocal BLOCK_ARRAY = fromIndexArray(BLOCK)\nlocal WEDGE_ARRAY = fromIndexArray(WEDGE)\nlocal CORNERWEDGE_ARRAY = fromIndexArray(CORNERWEDGE)\nlocal CYLINDER_ARRAY = cylinder(20)\nlocal SPHERE_ARRAY = icoSphere(2)\n\nreturn {\n\tBlock = function(cf, size2) return vertShape(cf, size2, BLOCK_ARRAY) end;\n\tWedge = function(cf, size2) return vertShape(cf, size2, WEDGE_ARRAY) end;\n\tCornerWedge = function(cf, size2) return vertShape(cf, size2, CORNERWEDGE_ARRAY) end;\n\tCylinder = function(cf, size2) return vertShape(cf, size2, CYLINDER_ARRAY) end;\n\tBall = function(cf, size2) return vertShape(cf, size2, SPHERE_ARRAY) end;\n\t\n\tGetCentroid = getCentroidFromSet;\n\tClassify = classify;\n}",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: Vertices)>"
}