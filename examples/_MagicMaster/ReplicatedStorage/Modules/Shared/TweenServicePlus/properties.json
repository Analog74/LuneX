{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: TweenServicePlus)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: TweenServicePlus)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: TweenServicePlus)>",
  "Sandboxed": false,
  "ScriptGuid": "{287F9250-25F3-4398-993B-3ECFCEF6F5BA}",
  "Source": "--[[\n\nTweenService+ V1.1\n@rek_kie on 8/9/20\n\nPlease read the devforum post here!\nhttps://devforum.roblox.com/t/tweenservice-plus/716025\n\nUpdate log [V1.1]: \n\n:Play() now has a mainObject parameter\n\n -- You are now able to set the object to calculate distance from if you are using :Play() with a range. This is useful if\n    you are trying to tween something that isn't a BasePart, but you still need to calculate distance from something to tween \n    the object.\n\nSetup instructions: \n\n\tPut this module into REPLICATEDSTORAGE, nowhere else.\n\tTo set up, all you have to do is require this module somewhere on a local script, and require it on a server script to be \n\tready for use on the server side.\n\n\nDocumentation:\n\n=== FUNCTIONS ===\n\ntweenServicePlus:Construct(instance Object, TweenInfo info, table Properties, number timeThreshold, bool debugMode, bool clientSync)\n\n  Returns: tweenObject\n\t\n- The \"equivalent\" to TweenService:Create(). The time threshold is the latency threshold if clientSync (latency compensation) \n  is enabled. The object is the object to tween, the TweenInfo is the info to use, the properties and are properties you \n  want to tween to.\n\n - debugMode defaults to false, and clientSync defaults to true.\n\ntweenObject:Play(array/instance clients, number Range, string rootPart, BasePart mainObject)\n\n- If clients are not specified, then the tween will play for all clients (the default setting). If you want to specify clients, either \n  pass in an ARRAY of clients, or pass in one individual client. These should be PLAYER INSTANCES.\n\n- If a range (a NUMBER) is specified, then the tween will only play for clients (you can specify them as stated above) within the range \n  (in studs) of the object being tweened. EXTREMELY useful for optimization and reducing client load. You wouldn't need to tween \n  something for a client if they're somewhere like 1000 studs away from the object. \n\n- rootPart: Only works when a range is specified. Defaults to HumanoidRootPart. If you specify this (has to be a string) \n  then the distance calculations will be from the distance from the tweened object to the specified rootPart. This uses a \n  recursive :FindFirstChild(), so make sure that your rootPart has a unique name so it isn't mistaken for something else in the\n  player. \n\n-- mainObject: The object to calculate distance from if you are using :Play() with a range. Defaults to the original object you're trying to tween.\n   This is useful if you are trying to tween something that isn't a BasePart, but you still need to calculate distance from something \n   to tween the object. (Ex. You want to tween a pointlight and use a range of 50 studs, but a pointlight doesn't have a workspace \n   position. So, you can set the mainObject to a BasePart and then the range would be 50 studs within that part.)\n\ntweenObject:Cancel(array/instance clients)\n\n- This behaves like the normal TweenService. Documentation is on developer.roblox.com\n\n- Cancels the tween. If clients are specified (either an ARRAY of player instances or one player instance), then the tween will only\n  cancel for the specified clients. Otherwise, it cancels for all clients. \n\n- Always stays in sync with the server. If you cancel a tween and then call :Play() again, it will still have TweenService's normal\n  behavior and take the initial tween time to finish.\n\nTip: Cancelling for specific clients is not reccommended, though. It only has a few use cases and could lead to things getting \nout of sync between your clients and the server.\n\ntweenObject:Pause(array/instance clients)\n\n- This also behaves like the normal TweenService. Documentation is on developer.roblox.com\n\n- Pauses the tween. If clients are specified (either an ARRAY of player instances or one player instance), then the tween will only\n  pause for the specified clients. Otherwise, it pauses for all clients. If a tween is paused while it wa\n\n- Also always stays in sync with the server. If you pause a tween and then call :Play() again, it will still have TweenService's normal\n  behavior and resumes where the tween had left off when it was paused.\n\n=== EVENTS ===\n\n- tweenObject.Cancelled -- Fires when a tween is cancelled.\n- tweenObject.Resumed -- Fires when a tween is played after being paused.\n- tweenObject.Paused -- Fires when a tween is paused.\n- tweenObject.Completed -- Fires when a tween is completed.\n\n]]--\n\n\nlocal tweenService = {}\n\nlocal clock = require(script.SyncedTime)\n\nlocal rs = game:GetService(\"RunService\")\nlocal ts = game:GetService(\"TweenService\")\nlocal http = game:GetService(\"HttpService\")\n\nlocal wrap = coroutine.wrap\n\nlocal wait = function(n)\n\tn = n or 1/30\n\tlocal now = tick()\n\trepeat rs.Heartbeat:Wait() until tick() - now >= n\nend\n\nlocal tEvent = script:WaitForChild(\"TweenCommunication\")\n\nif rs:IsServer() then \t\n\tif not clock:IsSynced() then -- make sure our clock is synced\n\t\trepeat \n\t\t\tclock:Sync()\n\t\t\twait(.5)\n\t\tuntil clock:IsSynced()\n\tend\nend\n\nlocal function infoToTable(tInfo)\n\tlocal info = {}\n\tinfo[\"Time\"] = tInfo.Time or 1 \n\tinfo[\"EasingStyle\"] = tInfo.EasingStyle or Enum.EasingStyle.Quad\n\tinfo[\"EasingDirection\"] = tInfo.EasingDirection or Enum.EasingDirection.Out\n\tinfo[\"RepeatCount\"] = tInfo.RepeatCount or 0\n\tinfo[\"Reverses\"] = tInfo.Reverses or false\n\tinfo[\"DelayTime\"] = tInfo.DelayTime or 0\n\treturn info\nend\n\nlocal function assign(object, properties, debugMode)\n\tif not object or not properties then return end\n\t\n\tfor property, value in pairs(properties) do\n\t\tobject[property] = value\n\t\t\n\t\tif debugMode then \n\t\t\tprint(\"Set \"..object.Name.. \"'s \"..property..\" to \".. tostring(value)..\".\")\n\t\tend\n\tend\nend\n\n\nfunction tweenService:Construct(obj, info, properties, timeThreshold, debugMode, clientSync)\n\t\n\tif not obj then warn(\"This object doesn't exist.\") return end\n\tif not info then warn(\"Please provide some TweenInfo!\") return end\n\tif not properties then warn(\"Please provide some properties to tween to!\") return end \n\t\n\tif timeThreshold and not type(timeThreshold) == \"number\" then warn(\"Latency threshold must be a number!\") return end\n\tif debugMode and not type(debugMode) == \"boolean\" then warn(\"The debugMode parameter must be true or false!\") return end \n\tif clientSync and not type(clientSync) == \"boolean\" then warn(\"The parameter clientSync must be true or false!\") return end\n\t\n\tlocal startProperties \n\t\n\tif info.Reverses then \n\t\tfor property, value in pairs(properties) do\n\t\t\tstartProperties[property] = obj[property]\n\t\tend\n\tend\n\t\n\tdebugMode = debugMode or false\n\tclientSync = clientSync or true \n\t\n\tlocal events = {\n\t\t[\"Cancelled\"] = true, \n\t\t[\"Completed\"] = true,\n\t\t[\"Paused\"] = true, \n\t\t[\"Resumed\"] = true\n\t}\n\t\n\tlocal tObject = {\n\t\t[\"PlaybackState\"] = Enum.PlaybackState.Begin,\n\t\t[\"TweenId\"] = http:GenerateGUID(false), -- so that we can identify each tween.\n\t\t[\"IsPaused\"] = false, \n\t\t[\"IsCancelled\"] = false, \n\t\t[\"LastPlay\"] = clock:GetTime(), \n\t\t[\"TimeElapsed\"] = 0\n\t}\n\t\n\tlocal function changeState(state)\n\t\ttObject.PlaybackState = state\n\t\t\n\t\tif debugMode then \n\t\t\tprint(\"Playback state changed. New playback state:\", tostring(state))\n\t\tend\n\tend\n\n\tfor name, event in pairs(events) do  -- Setting up the events to connect to \n\t\tevents[name] = Instance.new(\"BindableEvent\")\n\t\ttObject[name] = events[name].Event\n\tend\n\t\n\tlocal tweenWait = function(n)\n\t\tn = n or 1/30\n\t\tlocal now = tick()\n\t\trepeat \n\t\t\trs.Heartbeat:Wait()\n\t\t\tif tObject.IsPaused == true or tObject.IsCancelled == true then \n\t\t\t\tif debugMode then \n\t\t\t\t\tprint(\"Tween cancelled/paused server-side.\")\n\t\t\t\tend\n\t\t\t\treturn true\n\t\t\tend \n\t\tuntil tick() - now >= n\n\tend\n\t\n\tlocal function completionWait(t)\n\t\tlocal func = wrap(function()\n\t\t\t\n\t\t\tif tObject.IsPaused then \n\t\t\t\tt = t - tObject.TimeElapsed\n\t\t\t\t\n\t\t\t\tif debugMode then \n\t\t\t\t\tprint(\"Tween is resuming from a pause. Length:\", t)\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tevents.Resumed:Fire()\n\t\t\t\ttObject.IsPaused = false\n\t\t\tend\n\t\t\t\n\t\t\tif tObject.IsCancelled then \n\t\t\t\ttObject.IsCancelled = false\n\t\t\tend\n\t\t\t\n\t\t\tif info.DelayTime > 0 then\n\t\t\t\tchangeState(Enum.PlaybackState.Delayed)\n\t\t\t\twait(info.DelayTime)\n\t\t\tend\n\t\t\t\t\n\t\t\ttObject.LastPlay = clock:GetTime()\n\t\t\t\n\t\t\tchangeState(Enum.PlaybackState.Playing)\n\t\t\tlocal cancelled = tweenWait(t)\n\t\t\t\n\t\t\tprint(\"Cancelled:\", cancelled)\n\t\t\t\n\t\t\tif not cancelled then \n\t\t\t\tassign(obj, properties, debugMode)\n\t\t\t\t\n\t\t\t\tif not info.Reverses then \n\t\t\t\t\tchangeState(Enum.PlaybackState.Completed)\n\t\t\t\t\tevents.Completed:Fire()\n\t\t\t\telseif info.Reverses then \n\t\t\t\t\twait(t)\n\n\t\t\t\t\tif not tObject.IsPaused then \n\t\t\t\t\t\tassign(obj, startProperties, debugMode)\n\t\t\t\t\t\tchangeState(Enum.PlaybackState.Completed)\n\t\t\t\t\t\tevents.Completed:Fire()\t\n\t\t\t\t\tend\n\t\t\t\tend\t\t\n\t\t\tend\n\t\t\t\n\t\tend)\n\t\t\n\t\tfunc()\n\tend\n\t\n\t \n\t\n\tfunction tObject:Play(clients, range, rootPart, mainObject)\n\t\t\n\t\trootPart = rootPart or \"HumanoidRootPart\" \n\t\t\n\t\tif mainObject then \n\t\t\tif not mainObject:IsA(\"BasePart\") or not mainObject:IsDescendantOf(workspace) then warn(\"The mainObject must be a BasePart in the workspace.\") return end\n\t\tend\t\n\t\t\t\n\t\tmainObject = mainObject or obj\n\t\t\n\t\tif mainObject ~= obj and debugMode then \n\t\t\tprint(\"Set the main object to\", mainObject.Name)\n\t\tend\n\t\t\n\t\tif clients then \n\t\t\t\n\t\t\tclients = (type(clients) == \"table\") and clients or {clients} -- If you only provide a single player, it turns it into a table for you\n\t\t\t\n\t\t\tif range then \n\t\t\t\tfor _, player in ipairs(clients) do\n\t\t\t\t\t\n\t\t\t\t\tif player and player:IsA(\"Player\") and player.Character then \n\t\t\t\t\t\t\n\t\t\t\t\t\tlocal runTween = wrap(function() \n\t\t\t\t\t\t\tlocal root = player.Character:FindFirstChild(rootPart, true)\n\n\t\t\t\t\t\t\tif root then\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif debugMode then \n\t\t\t\t\t\t\t\t\tprint(\"Found root part of \"..player.Name..\":\", rootPart)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tlocal dist = (mainObject.Position - root.Position).magnitude\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif dist <= range then  -- Tween it only for clients in the range\n\t\t\t\t\t\t\t\t\ttEvent:FireClient(player, obj, infoToTable(info), properties, clock:GetTime(), tObject.TweenId, timeThreshold, debugMode, nil, clientSync) -- Tell the client to tween the object and the timestamp of when it was sent\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif debugMode then \n\t\t\t\t\t\t\t\t\t\tprint(\"Sent tween data to \"..player.Name..\". Distance from object:\", dist)\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend)\n\t\t\t\t\t\t\n\t\t\t\t\t\trunTween()\n\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\t\n\t\t\t\t\n\t\t\t\tfor _, player in ipairs(clients) do\n\t\t\t\t\t\n\t\t\t\t\tif player and player:IsA(\"Player\") and player.Character then \n\t\t\t\t\t\tlocal runTween = wrap(function()\n\t\t\t\t\t\t\ttEvent:FireClient(player, obj, infoToTable(info), properties, clock:GetTime(), tObject.TweenId, timeThreshold, debugMode, nil, clientSync)\n\t\t\t\t\t\tend)\t\n\t\t\t\t\t\t\n\t\t\t\t\t\trunTween()\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\t\n\t\t\tend\n\t\telse\n\t\t\tif range then \n\t\t\t\tfor _, player in ipairs(game.Players:GetPlayers()) do\n\t\t\t\t\t\n\t\t\t\t\tif player and player:IsA(\"Player\") and player.Character then \n\t\t\t\t\t\t\n\t\t\t\t\t\tlocal runTween = wrap(function() \n\t\t\t\t\t\t\tlocal root = player.Character:FindFirstChild(rootPart, true)\n\n\t\t\t\t\t\t\tif root then\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif debugMode then \n\t\t\t\t\t\t\t\t\tprint(\"Found root part of \"..player.Name..\":\", rootPart)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tlocal dist = (mainObject.Position - root.Position).magnitude\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif dist <= range then  -- Tween it only for clients in the range\n\t\t\t\t\t\t\t\t\ttEvent:FireClient(player, obj, infoToTable(info), properties, clock:GetTime(), tObject.TweenId, timeThreshold, debugMode, nil, clientSync) -- Tell the client to tween the object and the timestamp of when it was sent\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif debugMode then \n\t\t\t\t\t\t\t\t\t\tprint(\"Sent tween data to \"..player.Name..\". Distance from object:\", dist)\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend)\n\t\t\t\t\t\t\n\t\t\t\t\t\trunTween()\n\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\telse\n\t\t\t\ttEvent:FireAllClients(obj, infoToTable(info), properties, clock:GetTime(), tObject.TweenId, timeThreshold, debugMode, nil, clientSync)\n\t\t\tend\n\t\tend\n\t\t\n\t\tcompletionWait(info.Time)\n\t\t\n\tend\n\t\n\tfunction tObject:Cancel(clients)\n\t\t\n\t\tif clients then \n\t\t\tclients = (type(clients) == \"table\") and clients or {clients}\n\t\t\t\n\t\t\tfor _, client in ipairs(clients) do\n\t\t\t\ttEvent:FireClient(client, nil, nil, nil, clock:GetTime(), tObject.TweenId, nil, debugMode, \"Cancel\")\n\t\t\tend\t\n\t\telse\n\t\t\ttEvent:FireAllClients(nil, nil, nil, clock:GetTime(), tObject.TweenId, nil, debugMode, \"Cancel\")\n\t\tend\n\t\t\n\t\tevents.Cancelled:Fire()\n\t\ttObject.IsCancelled = true \n\t\tchangeState(Enum.PlaybackState.Cancelled)\t\n\t\t\n\tend\n\t\n\tfunction tObject:Pause(clients)\n\t\t\n\t\tif clients then\n\t\t\tclients = (type(clients) == \"table\") and clients or {clients}\n\t\t\t\n\t\t\tfor _, client in ipairs(clients) do\n\t\t\t\ttEvent:FireClient(client, nil, nil, nil, clock:GetTime(), tObject.TweenId, nil, debugMode, \"Pause\")\n\t\t\tend\t\t\n\t\telse\n\t\t\ttEvent:FireAllClients(nil, nil, nil, clock:GetTime(), tObject.TweenId, nil, debugMode, \"Pause\")\n\t\tend\n\t\t\n\t\t\t\t\n\t\ttObject.TimeElapsed = clock:GetTime() - tObject.LastPlay \n\t\ttObject.LastPlay = clock:GetTime()\n\t\t\n\t\tevents.Paused:Fire()\n\t\ttObject.IsPaused = true \n\t\tchangeState(Enum.PlaybackState.Paused)\n\tend\n\t\n\t\n\treturn tObject\nend\n\nif rs:IsClient() then\n\tlocal player = game.Players.LocalPlayer \n\t\n\tlocal tweens = {}\n\t\n\ttEvent.OnClientEvent:Connect(function(obj, info, properties, timestamp, tweenID, threshold, debugMode, modify, sync)\n\t\t\n\t\tif modify then \n\t\t\tlocal tweenToEdit = tweens[tweenID]\n\t\t\t\n\t\t\tif not tweenToEdit then -- if the tween doesn't exist, just return and give a warning\n\t\t\t\twarn(\"The tween you tried to modify does not exist.\")\n\t\t\t\treturn \n\t\t\tend\n\t\t\t\n\t\t\tif modify == \"Cancel\" then\n\t\t\t\t\n\t\t\t\ttweenToEdit:Cancel()\n\t\t\t\t\n\t\t\t\tif debugMode then \n\t\t\t\t\tlocal latency = clock:GetTime() - timestamp\n\t\t\t\t\tprint(\"Cancelled a tween. Latency:\", latency)\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\treturn \t\n\t\t\t\t\n\t\t\telseif modify == \"Pause\" then \n\t\t\t\t\n\t\t\t\ttweenToEdit:Pause() \n\t\t\t\t\n\t\t\t\tif debugMode then \n\t\t\t\t\tlocal latency = clock:GetTime() - timestamp\n\t\t\t\t\tprint(\"Paused a tween. Latency:\", latency)\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\treturn \t\n\t\t\tend\n\t\tend\n\t\t\n\t\tlocal latency = clock:GetTime() - timestamp\n\t\t\n\t\tlocal newtime = sync and info.Time - latency or info.Time    -- If enabled, this syncs the tween up based on latency. \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- Ex. If the server told a client to do a 10 second tween and it\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- took .7 seconds to get to the client, then the time for the \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- client's tween would be 10 - .7 = 9.3 seconds. \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     -- I'm using Quenty's module to get a global timestamp, so\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- that server and client time are synced. This results in a \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- perfect sync between client and server tween completion.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- To better see this for yourself, turn on debug mode and \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- look at the output to see how the server prints exactly\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- when the client tween ends. (If you are in Studio, Make sure you  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- stay watching only on the client though, because switching to \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t -- the server  view pauses the client's game session on Play Solo)\n\t\t\n\t\tif debugMode then \n\t\t\tprint(\"Approximate latency for \".. player.Name ..\": \" ..latency .. \" seconds. \\n New tween time: \".. newtime ..\" seconds\")\n\t\tend\n\t\t\n\t\tthreshold = threshold or 0 -- Defaults to 0. When you set this, this basically means the amount of time \n\t\t  \t\t\t\t\t\t   -- the new tween time (after calculating latency) needs to be greater than \n\t\t\t\t\t\t\t\t   -- for the tween to play. If the new tween time after calculating latency is less than \n\t\t\t\t\t\t\t\t   -- or equal to than the threshold, the tween will not play.\n\t\t\n\t\t\n\t\tif newtime > threshold and obj and properties and tweenID then -- some checks\n\t\t\tlocal newInfo = TweenInfo.new(newtime, info.EasingStyle, info.EasingDirection, info.RepeatCount, info.Reverses, info.DelayTime)\n\t\t\t\n\t\t\tlocal trackTween = wrap(function()\n\t\t\t\t\n\t\t\t\tif not tweens[tweenID] then \n\t\t\t\t\ttweens[tweenID] = ts:Create(obj, newInfo, properties)\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\ttweens[tweenID]:Play()\t\n\t\t\t\ttweens[tweenID].Completed:Wait()\n\t\t\t\ttweens[tweenID] = nil\n\t\t\tend)\n\t\t\t\n\t\t\ttrackTween()\t\n\t\t\t\n\t\t\tif debugMode then \n\t\t\t\tlocal printProperties = wrap(function()\n\t\t\t\t\tprint(\"Currently tweening properties of \"..obj.Name..\":\")\n\t\t\t\t\t\n\t\t\t\t\tfor property, value in pairs(properties) do\n\t\t\t\t\t\tprint(property .. \" to \"..tostring(value))\n\t\t\t\t\tend\n\t\t\t\tend)\n\t\t\t\t\n\t\t\t\tprintProperties()\n\t\t\tend\t\t\n\t\tend\n\tend)\nend\n\nreturn tweenService",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: TweenServicePlus)>"
}