{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: VersionChecker)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: VersionChecker)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: VersionChecker)>",
  "Sandboxed": false,
  "ScriptGuid": "{5D506043-7CE2-4FE0-AB05-FCE073694A89}",
  "Source": "-- Quenty Signal Class\t\nlocal Signal do\n\tSignal = {}\n\tSignal.__index = Signal\n\tSignal.ClassName = \"Signal\"\n\n\t--- Constructs a new signal.\n\t-- @constructor Signal.new()\n\t-- @treturn Signal\n\tfunction Signal.new()\n\t\tlocal self = setmetatable({}, Signal)\n\n\t\tself._bindableEvent = Instance.new(\"BindableEvent\")\n\t\tself._argData = nil\n\t\tself._argCount = nil -- Prevent edge case of :Fire(\"A\", nil) --> \"A\" instead of \"A\", nil\n\n\t\treturn self\n\tend\n\n\t--- Fire the event with the given arguments. All handlers will be invoked. Handlers follow\n\t-- Roblox signal conventions.\n\t-- @param ... Variable arguments to pass to handler\n\t-- @treturn nil\n\tfunction Signal:Fire(...)\n\t\tself._argData = {...}\n\t\tself._argCount = select(\"#\", ...)\n\t\tself._bindableEvent:Fire()\n\t\tself._argData = nil\n\t\tself._argCount = nil\n\tend\n\n\t--- Connect a new handler to the event. Returns a connection object that can be disconnected.\n\t-- @tparam function handler Function handler called with arguments passed when `:Fire(...)` is called\n\t-- @treturn Connection Connection object that can be disconnected\n\tfunction Signal:Connect(handler)\n\t\tif not (type(handler) == \"function\") then\n\t\t\terror((\"connect(%s)\"):format(typeof(handler)), 2)\n\t\tend\n\n\t\treturn self._bindableEvent.Event:Connect(function()\n\t\t\thandler(unpack(self._argData, 1, self._argCount))\n\t\tend)\n\tend\n\n\t--- Wait for fire to be called, and return the arguments it was given.\n\t-- @treturn ... Variable arguments from connection\n\tfunction Signal:Wait()\n\t\tself._bindableEvent.Event:Wait()\n\t\tassert(self._argData, \"Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.\")\n\t\treturn unpack(self._argData, 1, self._argCount)\n\tend\nend\n\n--- Disconnects all connected events to the signal. Voids the signal as unusable.\n-- @treturn nil\nfunction Signal:Destroy()\n\tif self._bindableEvent then\n\t\tself._bindableEvent:Destroy()\n\t\tself._bindableEvent = nil\n\tend\n\n\tself._argData = nil\n\tself._argCount = nil\nend\n\n-- Real code starts below\nlocal v = {}\n\nlocal rs = game:GetService(\"RunService\")\nlocal mps = game:GetService(\"MarketplaceService\")\n\nlocal Activated = false\n\nlocal Place = game.PlaceId\nlocal Universe = game.GameId\n\nlocal PlaceLastUpdated, GameLastUpdated\n\nlocal UpToDatePlace = true\nlocal UpToDateGame = true\n\nlocal CheckFrequency = 5\n\nv.GameUpdated = Signal.new()\nv.PlaceUpdated = Signal.new()\n\nfunction GetGameProductInfo()\n\tlocal success, info = pcall(function()\n\t\treturn mps:GetProductInfo(Universe)\n\tend)\n\n\tif success then\n\t\treturn info\n\telse\n\t\twait(2)\n\t\treturn GetGameProductInfo()\n\tend\nend\n\nfunction GetPlaceProductInfo()\n\tlocal success, info = pcall(function()\n\t\treturn mps:GetProductInfo(Place)\n\tend)\n\n\tif success then\n\t\treturn info\n\telse\n\t\twait(2)\n\t\treturn GetPlaceProductInfo()\n\tend\nend\n\n-- Boolean\n-- Check if current place is up-to-date. \nfunction v:IsPlaceUpToDate()\n\tassert(PlaceLastUpdated, \"You have not activated the module yet.\")\n\tassert(GameLastUpdated, \"You have not activated the module yet.\")\n\treturn UpToDatePlace\nend\n\n-- Boolean\n-- Check if current game is up-to-date. \nfunction v:IsGameUpToDate()\n\tassert(PlaceLastUpdated, \"You have not activated the module yet.\")\n\tassert(GameLastUpdated, \"You have not activated the module yet.\")\n\treturn UpToDateGame\nend\n\n-- DateTime \n-- Get the last time the place was updated.\nfunction v:GetPlaceLastUpdated()\n\tassert(PlaceLastUpdated, \"You have not activated the module yet.\")\n\tassert(GameLastUpdated, \"You have not activated the module yet.\")\n\treturn DateTime.fromIsoDate(PlaceLastUpdated)\nend\n\n-- DateTime\n-- Get the last time the game was updated. \nfunction v:GetGameLastUpdated()\n\tassert(PlaceLastUpdated, \"You have not activated the module yet.\")\n\tassert(GameLastUpdated, \"You have not activated the module yet.\")\n\treturn DateTime.fromIsoDate(GameLastUpdated)\nend\n\n-- Void\n-- Sets the frequency in which the game will be checked for obsolescence.\nfunction v:SetCheckFrequency(frequency)\n\tassert(type(frequency) == \"number\", \"Argument 1 (frequency) must be a positive number!\")\n\tassert(frequency >= 0, \"Argument 1 (frequency) must be a positive number!\")\n\tCheckFrequency = frequency\nend\n\n-- Void\n-- Activate the module.\nfunction v.Activate()\n\tActivated = true\n\tGameLastUpdated = GetGameProductInfo().Updated\n\tPlaceLastUpdated = GetPlaceProductInfo().Updated\n\t\n\tcoroutine.wrap(function()\n\t\twhile wait(CheckFrequency) do\n\t\t\tif not Activated then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tlocal Updated = GetGameProductInfo().Updated\n\t\t\tif GameLastUpdated ~= Updated then\n\t\t\t\tUpToDateGame = false\n\t\t\t\tv.GameUpdated:Fire(DateTime.fromIsoDate(Updated))\n\t\t\t\tGameLastUpdated = GetGameProductInfo().Updated\n\t\t\tend\n\t\t\tUpdated = GetPlaceProductInfo().Updated\n\t\t\tif PlaceLastUpdated ~= Updated then\n\t\t\t\tUpToDatePlace = false\n\t\t\t\tv.PlaceUpdated:Fire(DateTime.fromIsoDate(Updated))\n\t\t\t\tPlaceLastUpdated = GetPlaceProductInfo().Updated\n\t\t\tend\n\t\tend\n\tend)()\nend\n\n-- Void\n-- Deactive the module.\nfunction v.Deactive()\n\tActivated = false\nend\n\nreturn v\n",
  "SourceAssetId": 7066324528,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: VersionChecker)>"
}