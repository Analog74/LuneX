{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: MockDataStoreService)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: MockDataStoreService)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: MockDataStoreService)>",
  "Sandboxed": false,
  "ScriptGuid": "{E1894AA6-D574-4CB5-B8B1-41764D1C25D4}",
  "Source": "--[[\n\tMockDataStoreService.lua\n\tThis module implements the API and functionality of Roblox's DataStoreService class.\n\n\tThis module is licensed under APLv2, refer to the LICENSE file or:\n\thttps://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE\n]]\n\nlocal MockDataStoreService = {}\n\nlocal MockDataStoreManager = require(script.MockDataStoreManager)\nlocal MockGlobalDataStore = require(script.MockGlobalDataStore)\nlocal MockOrderedDataStore = require(script.MockOrderedDataStore)\nlocal Utils = require(script.MockDataStoreUtils)\nlocal Constants = require(script.MockDataStoreConstants)\nlocal HttpService = game:GetService(\"HttpService\") -- for json encode/decode\n\nlocal function makeGetWrapper(methodName, getObject, isGlobal) -- Helper function to reduce amount of redundant code\n\treturn function(_, name, scope)\n\t\tif not game:GetService(\"RunService\"):IsServer() then\n\t\t\terror(\"DataStore can't be accessed from client\", 2)\n\t\tend\n\n\t\tif isGlobal then\n\t\t\treturn getObject()\n\t\telse\n\t\t\tif type(name) ~= \"string\" then\n\t\t\t\terror((\"bad argument #1 to '%s' (string expected, got %s)\")\n\t\t\t\t\t:format(methodName, typeof(name)), 2)\n\t\t\telseif scope ~= nil and type(scope) ~= \"string\" then\n\t\t\t\terror((\"bad argument #2 to '%s' (string expected, got %s)\")\n\t\t\t\t\t:format(methodName, typeof(scope)), 2)\n\t\t\telseif #name == 0 then\n\t\t\t\terror((\"bad argument #1 to '%s' (name can't be empty string)\")\n\t\t\t\t\t:format(methodName), 2)\n\t\t\telseif #name > Constants.MAX_LENGTH_NAME then\n\t\t\t\terror((\"bad argument #1 to '%s' (name exceeds %d character limit)\")\n\t\t\t\t\t:format(methodName, Constants.MAX_LENGTH_NAME), 2)\n\t\t\telseif scope and #scope == 0 then\n\t\t\t\terror((\"bad argument #2 to '%s' (scope can't be empty string)\")\n\t\t\t\t\t:format(methodName), 2)\n\t\t\telseif scope and #scope > Constants.MAX_LENGTH_SCOPE then\n\t\t\t\terror((\"bad argument #2 to '%s' (scope exceeds %d character limit)\")\n\t\t\t\t\t:format(methodName, Constants.MAX_LENGTH_SCOPE), 2)\n\t\t\tend\n\t\t\treturn getObject(name, scope or \"global\")\n\t\tend\n\n\tend\nend\n\nMockDataStoreService.GetGlobalDataStore = makeGetWrapper(\n\t\"GetGlobalDataStore\",\n    function()\n        local data = MockDataStoreManager.GetGlobalData()\n\n        local interface = MockDataStoreManager.GetDataInterface(data)\n        if interface then\n            return interface\n        end\n\n        local value = {\n\t\t\t__type = \"GlobalDataStore\";\n            __data = data; -- Mapping from <key> to <value>\n            __event = Instance.new(\"BindableEvent\"); -- For OnUpdate\n\t\t\t__writeCache = {};\n\t\t\t__writeLock = {};\n\t\t\t__getCache = {};\n        }\n        interface = setmetatable(value, MockGlobalDataStore)\n\t\tMockDataStoreManager.SetDataInterface(data, interface)\n\n\t\treturn interface\n\tend,\n\ttrue -- This is the global datastore, no name/scope needed\n)\n\nMockDataStoreService.GetDataStore = makeGetWrapper(\n\t\"GetDataStore\",\n\tfunction(name, scope)\n        local data = MockDataStoreManager.GetData(name, scope)\n\n        local interface = MockDataStoreManager.GetDataInterface(data)\n        if interface then\n            return interface\n        end\n\n        local value = {\n\t\t\t__type = \"GlobalDataStore\";\n            Name = name;\n            __scope = scope;\n            __data = data; -- Mapping from <key> to <value>\n            __event = Instance.new(\"BindableEvent\"); -- For OnUpdate\n\t\t\t__writeCache = {};\n\t\t\t__writeLock = {};\n\t\t\t__getCache = {};\n        }\n        interface = setmetatable(value, MockGlobalDataStore)\n\t\tMockDataStoreManager.SetDataInterface(data, interface)\n\n        return interface\n\tend\n)\n\nMockDataStoreService.GetOrderedDataStore = makeGetWrapper(\n\t\"GetOrderedDataStore\",\n\tfunction(name, scope)\n        local data = MockDataStoreManager.GetOrderedData(name, scope)\n\n        local interface = MockDataStoreManager.GetDataInterface(data)\n        if interface then\n            return interface\n        end\n\n        local value = {\n\t\t\t__type = \"OrderedDataStore\";\n\t\t\tName = name;\n            __scope = scope;\n            __data = data; -- Mapping from <key> to <value>\n            __sorted = {}; -- List of {Key = <key>, Value = <value>} pairs\n            __ref = {}; -- Mapping from <key> to corresponding {Key = <key>, Value = <value>} entry in __sorted\n            __changed = false; -- Whether __sorted is guaranteed sorted at the moment\n            __event = Instance.new(\"BindableEvent\"); -- For OnUpdate\n\t\t\t__writeCache = {};\n\t\t\t__writeLock = {};\n\t\t\t__getCache = {};\n        }\n        interface = setmetatable(value, MockOrderedDataStore)\n\t\tMockDataStoreManager.SetDataInterface(data, interface)\n\n\t\treturn interface\n\tend\n)\n\nlocal DataStoreRequestTypes = {}\n\nfor _, Enumerator in ipairs(Enum.DataStoreRequestType:GetEnumItems()) do\n\tDataStoreRequestTypes[Enumerator] = Enumerator\n\tDataStoreRequestTypes[Enumerator.Name] = Enumerator\n\tDataStoreRequestTypes[Enumerator.Value] = Enumerator\nend\n\nfunction MockDataStoreService:GetRequestBudgetForRequestType(requestType) -- luacheck: ignore self\n\tif not DataStoreRequestTypes[requestType] then\n\t\terror((\"bad argument #1 to 'GetRequestBudgetForRequestType' (unable to cast '%s' of type %s to DataStoreRequestType)\")\n\t\t\t:format(tostring(requestType), typeof(requestType)), 2)\n\tend\n\n\treturn MockDataStoreManager.GetBudget(DataStoreRequestTypes[requestType])\nend\n\nfunction MockDataStoreService:ImportFromJSON(json, verbose) -- luacheck: ignore self\n\tlocal content\n\tif type(json) == \"string\" then\n\t\tlocal parsed, value = pcall(function() return HttpService:JSONDecode(json) end)\n\t\tif not parsed then\n\t\t\terror(\"bad argument #1 to 'ImportFromJSON' (string is not valid json)\", 2)\n\t\tend\n\t\tcontent = value\n\telseif type(json) == \"table\" then\n\t\tcontent = Utils.deepcopy(json)\n\telse\n\t\terror((\"bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)\"):format(typeof(json)), 2)\n\tend\n\tif verbose ~= nil and type(verbose) ~= \"boolean\" then\n\t\terror((\"bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)\"):format(typeof(verbose)), 2)\n\tend\n\n\treturn MockDataStoreManager.ImportFromJSON(content, verbose)\nend\n\nfunction MockDataStoreService:ExportToJSON() -- luacheck: ignore self\n\treturn MockDataStoreManager.ExportToJSON()\nend\n\nreturn MockDataStoreService\n",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: MockDataStoreService)>"
}