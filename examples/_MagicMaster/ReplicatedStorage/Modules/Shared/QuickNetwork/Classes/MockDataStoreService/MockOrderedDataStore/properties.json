{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: MockOrderedDataStore)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: MockOrderedDataStore)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: MockOrderedDataStore)>",
  "Sandboxed": false,
  "ScriptGuid": "{8BD1ABE9-6FFF-49AF-BAEC-082752BC0F41}",
  "Source": "--[[\n\tMockOrderedDataStore.lua\n\tThis module implements the API and functionality of Roblox's OrderedDataStore class.\n\n\tThis module is licensed under APLv2, refer to the LICENSE file or:\n\thttps://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE\n]]\n\nlocal MockOrderedDataStore = {}\nMockOrderedDataStore.__index = MockOrderedDataStore\n\nlocal MockDataStoreManager = require(script.Parent.MockDataStoreManager)\nlocal MockDataStorePages = require(script.Parent.MockDataStorePages)\nlocal Utils = require(script.Parent.MockDataStoreUtils)\nlocal Constants = require(script.Parent.MockDataStoreConstants)\nlocal HttpService = game:GetService(\"HttpService\") -- for json encode/decode\n\nlocal rand = Random.new()\n\nfunction MockOrderedDataStore:OnUpdate(key, callback)\n\tkey = Utils.preprocessKey(key)\n\tif type(key) ~= \"string\" then\n\t\terror((\"bad argument #1 to 'OnUpdate' (string expected, got %s)\"):format(typeof(key)), 2)\n\telseif type(callback) ~= \"function\" then\n\t\terror((\"bad argument #2 to 'OnUpdate' (function expected, got %s)\"):format(typeof(callback)), 2)\n\telseif #key == 0 then\n\t\terror(\"bad argument #1 to 'OnUpdate' (key name can't be empty)\", 2)\n\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\terror((\"bad argument #1 to 'OnUpdate' (key name exceeds %d character limit)\"):format(Constants.MAX_LENGTH_KEY), 2)\n\tend\n\n\tUtils.simulateErrorCheck(\"OnUpdate\")\n\n\tlocal success = MockDataStoreManager.YieldForBudget(\n\t\tfunction()\n\t\t\twarn((\"OnUpdate request was throttled due to lack of budget. Try sending fewer requests. Key = %s\"):format(key))\n\t\tend,\n\t\t{Enum.DataStoreRequestType.OnUpdate}\n\t)\n\n\tif not success then\n\t\terror(\"OnUpdate rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tUtils.logMethod(self, \"OnUpdate\", key)\n\n\treturn self.__event.Event:Connect(function(k, v)\n\t\tif k == key then\n\t\t\tif Constants.YIELD_TIME_UPDATE_MAX > 0 then\n\t\t\t\tUtils.accurateWait(rand:NextNumber(Constants.YIELD_TIME_UPDATE_MIN, Constants.YIELD_TIME_UPDATE_MAX))\n\t\t\tend\n\t\t\tcallback(v) -- v was implicitly deep-copied\n\t\tend\n\tend)\nend\n\nfunction MockOrderedDataStore:GetAsync(key)\n\tkey = Utils.preprocessKey(key)\n\tif type(key) ~= \"string\" then\n\t\terror((\"bad argument #1 to 'GetAsync' (string expected, got %s)\"):format(typeof(key)), 2)\n\telseif #key == 0 then\n\t\terror(\"bad argument #1 to 'GetAsync' (key name can't be empty)\", 2)\n\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\terror((\"bad argument #1 to 'GetAsync' (key name exceeds %d character limit)\"):format(Constants.MAX_LENGTH_KEY), 2)\n\tend\n\n\tif self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then\n\t\treturn self.__data[key]\n\tend\n\n\tUtils.simulateErrorCheck(\"GetAsync\")\n\n\tlocal success = MockDataStoreManager.YieldForBudget(\n\t\tfunction()\n\t\t\twarn((\"GetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s\"):format(key))\n\t\tend,\n\t\t{Enum.DataStoreRequestType.GetAsync}\n\t)\n\n\tif not success then\n\t\terror(\"GetAsync rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tlocal retValue = self.__data[key]\n\n\tUtils.simulateYield()\n\n\tself.__getCache[key] = tick()\n\n\tUtils.logMethod(self, \"GetAsync\", key)\n\n\treturn retValue\nend\n\nfunction MockOrderedDataStore:IncrementAsync(key, delta)\n\tkey = Utils.preprocessKey(key)\n\tif type(key) ~= \"string\" then\n\t\terror((\"bad argument #1 to 'IncrementAsync' (string expected, got %s)\"):format(typeof(key)), 2)\n\telseif delta ~= nil and type(delta) ~= \"number\" then\n\t\terror((\"bad argument #2 to 'IncrementAsync' (number expected, got %s)\"):format(typeof(delta)), 2)\n\telseif #key == 0 then\n\t\terror(\"bad argument #1 to 'IncrementAsync' (key name can't be empty)\", 2)\n\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\terror((\"bad argument #1 to 'IncrementAsync' (key name exceeds %d character limit)\")\n\t\t\t:format(Constants.MAX_LENGTH_KEY), 2)\n\tend\n\n\tUtils.simulateErrorCheck(\"IncrementAsync\")\n\n\tlocal success\n\n\tif self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then\n\t\tsuccess = MockDataStoreManager.YieldForWriteLockAndBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"IncrementAsync request was throttled, a key can only be written to once every %d seconds. Key = %s\")\n\t\t\t\t\t:format(Constants.WRITE_COOLDOWN, key))\n\t\t\tend,\n\t\t\tkey,\n\t\t\tself.__writeLock,\n\t\t\tself.__writeCache,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\telse\n\t\tself.__writeLock[key] = true\n\t\tsuccess = MockDataStoreManager.YieldForBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"IncrementAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s\")\n\t\t\t\t\t:format(key))\n\t\t\tend,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\t\tself.__writeLock[key] = nil\n\tend\n\n\tif not success then\n\t\terror(\"IncrementAsync rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tlocal old = self.__data[key]\n\n\tif old ~= nil and (type(old) ~= \"number\" or old % 1 ~= 0) then\n\t\tUtils.simulateYield()\n\t\terror(\"IncrementAsync rejected with error (cannot increment non-integer value)\", 2)\n\tend\n\n\tself.__writeLock[key] = true\n\n\tdelta = delta and math.floor(delta + .5) or 1\n\n\tif old == nil then\n\t\tself.__data[key] = delta\n\t\tself.__ref[key] = {Key = key, Value = self.__data[key]}\n\t\ttable.insert(self.__sorted, self.__ref[key])\n\t\tself.__changed = true\n\t\tself.__event:Fire(key, self.__data[key])\n\telseif delta ~= 0 then\n\t\tself.__data[key] = self.__data[key] + delta\n\t\tself.__ref[key].Value = self.__data[key]\n\t\tself.__changed = true\n\t\tself.__event:Fire(key, self.__data[key])\n\tend\n\n\tlocal retValue = self.__data[key]\n\n\tUtils.simulateYield()\n\n\tself.__writeLock[key] = nil\n\tself.__writeCache[key] = tick()\n\n\tself.__getCache[key] = tick()\n\n\tUtils.logMethod(self, \"IncrementAsync\", key, retValue, delta)\n\n\treturn retValue\nend\n\nfunction MockOrderedDataStore:RemoveAsync(key)\n\tkey = Utils.preprocessKey(key)\n\tif type(key) ~= \"string\" then\n\t\terror((\"bad argument #1 to 'RemoveAsync' (string expected, got %s)\"):format(type(key)), 2)\n\telseif #key == 0 then\n\t\terror(\"bad argument #1 to 'RemoveAsync' (key name can't be empty)\", 2)\n\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\terror((\"bad argument #1 to 'RemoveAsync' (key name exceeds %d character limit)\"):format(Constants.MAX_LENGTH_KEY), 2)\n\tend\n\n\tUtils.simulateErrorCheck(\"RemoveAsync\")\n\n\tlocal success\n\n\tif self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then\n\t\tsuccess = MockDataStoreManager.YieldForWriteLockAndBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"RemoveAsync request was throttled, a key can only be written to once every %d seconds. Key = %s\")\n\t\t\t\t\t:format(Constants.WRITE_COOLDOWN, key))\n\t\t\tend,\n\t\t\tkey,\n\t\t\tself.__writeLock,\n\t\t\tself.__writeCache,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\telse\n\t\tself.__writeLock[key] = true\n\t\tsuccess = MockDataStoreManager.YieldForBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"RemoveAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s\")\n\t\t\t\t\t:format(key))\n\t\t\tend,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\t\tself.__writeLock[key] = nil\n\tend\n\n\tif not success then\n\t\terror(\"RemoveAsync rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tself.__writeLock[key] = true\n\n\tlocal value = self.__data[key]\n\n\tif value ~= nil then\n\t\tself.__data[key] = nil\n\t\tself.__ref[key] = nil\n\t\tfor i,v in pairs(self.__sorted) do\n\t\t\tif v.Key == key then\n\t\t\t\ttable.remove(self.__sorted, i)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tself.__event:Fire(key, nil)\n\tend\n\n\tUtils.simulateYield()\n\n\tself.__writeLock[key] = nil\n\tself.__writeCache[key] = tick()\n\n\tUtils.logMethod(self, \"RemoveAsync\", key, value)\n\n\treturn value\nend\n\nfunction MockOrderedDataStore:SetAsync(key, value)\n\tkey = Utils.preprocessKey(key)\n\tif type(key) ~= \"string\" then\n\t\terror((\"bad argument #1 to 'SetAsync' (string expected, got %s)\"):format(typeof(key)), 2)\n\telseif #key == 0 then\n\t\terror(\"bad argument #1 to 'SetAsync' (key name can't be empty)\", 2)\n\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\terror((\"bad argument #1 to 'SetAsync' (key name exceeds %d character limit)\"):format(Constants.MAX_LENGTH_KEY), 2)\n\telseif type(value) ~= \"number\" then\n\t\terror((\"bad argument #2 to 'SetAsync' (number expected, got %s)\"):format(typeof(value)), 2)\n\telseif value % 1 ~= 0 then\n\t\terror(\"bad argument #2 to 'SetAsync' (cannot store non-integer values in OrderedDataStore)\", 2)\n\tend\n\n\tUtils.simulateErrorCheck(\"SetAsync\")\n\n\tlocal success\n\n\tif self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then\n\t\tsuccess = MockDataStoreManager.YieldForWriteLockAndBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"SetAsync request was throttled, a key can only be written to once every %d seconds. Key = %s\")\n\t\t\t\t\t:format(Constants.WRITE_COOLDOWN, key))\n\t\t\tend,\n\t\t\tkey,\n\t\t\tself.__writeLock,\n\t\t\tself.__writeCache,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\telse\n\t\tself.__writeLock[key] = true\n\t\tsuccess = MockDataStoreManager.YieldForBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"SetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s\")\n\t\t\t\t\t:format(key))\n\t\t\tend,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\t\tself.__writeLock[key] = nil\n\tend\n\n\tif not success then\n\t\terror(\"SetAsync rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tself.__writeLock[key] = true\n\n\tlocal old = self.__data[key]\n\n\tif old == nil then\n\t\tself.__data[key] = value\n\t\tself.__ref[key] = {Key = key, Value = value}\n\t\ttable.insert(self.__sorted, self.__ref[key])\n\t\tself.__changed = true\n\t\tself.__event:Fire(key, self.__data[key])\n\telseif old ~= value then\n\t\tself.__data[key] = value\n\t\tself.__ref[key].Value = value\n\t\tself.__changed = true\n\t\tself.__event:Fire(key, self.__data[key])\n\tend\n\n\tUtils.simulateYield()\n\n\tself.__writeLock[key] = nil\n\tself.__writeCache[key] = tick()\n\n\tUtils.logMethod(self, \"SetAsync\", key, self.__data[key])\n\n\treturn value\nend\n\nfunction MockOrderedDataStore:UpdateAsync(key, transformFunction)\n\tkey = Utils.preprocessKey(key)\n\tif type(key) ~= \"string\" then\n\t\terror((\"bad argument #1 to 'UpdateAsync' (string expected, got %s)\"):format(typeof(key)), 2)\n\telseif type(transformFunction) ~= \"function\" then\n\t\terror((\"bad argument #2 to 'UpdateAsync' (function expected, got %s)\"):format(typeof(transformFunction)), 2)\n\telseif #key == 0 then\n\t\terror(\"bad argument #1 to 'UpdateAsync' (key name can't be empty)\", 2)\n\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\terror((\"bad argument #1 to 'UpdateAsync' (key name exceeds %d character limit)\"):format(Constants.MAX_LENGTH_KEY), 2)\n\tend\n\n\tUtils.simulateErrorCheck(\"UpdateAsync\")\n\n\tlocal success\n\n\tif self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then\n\t\tsuccess = MockDataStoreManager.YieldForWriteLockAndBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"UpdateAsync request was throttled, a key can only be written to once every %d seconds. Key = %s\")\n\t\t\t\t\t:format(Constants.WRITE_COOLDOWN, key))\n\t\t\tend,\n\t\t\tkey,\n\t\t\tself.__writeLock,\n\t\t\tself.__writeCache,\n\t\t\t{Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\t)\n\telse\n\t\tself.__writeLock[key] = true\n\t\tlocal budget\n\t\tif self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then\n\t\t\tbudget = {Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\telse\n\t\t\tbudget = {Enum.DataStoreRequestType.GetAsync, Enum.DataStoreRequestType.SetIncrementSortedAsync}\n\t\tend\n\t\tsuccess = MockDataStoreManager.YieldForBudget(\n\t\t\tfunction()\n\t\t\t\twarn((\"UpdateAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s\")\n\t\t\t\t\t:format(key))\n\t\t\tend,\n\t\t\tbudget\n\t\t)\n\t\tself.__writeLock[key] = nil\n\tend\n\n\tif not success then\n\t\terror(\"UpdateAsync rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tlocal value = transformFunction(self.__data[key])\n\n\tif value == nil then -- cancel update after remote call\n\t\tUtils.simulateYield()\n\t\treturn nil -- this is what datastores do even though it should be old value\n\tend\n\n\tif type(value) ~= \"number\" or value % 1 ~= 0 then\n\t\terror(\"UpdateAsync rejected with error (resulting non-integer value can't be stored in OrderedDataStore)\", 2)\n\tend\n\n\tself.__writeLock[key] = true\n\n\tlocal old = self.__data[key]\n\n\tif old == nil then\n\t\tself.__data[key] = value\n\t\tself.__ref[key] = {Key = key, Value = value}\n\t\ttable.insert(self.__sorted, self.__ref[key])\n\t\tself.__changed = true\n\t\tself.__event:Fire(key, self.__data[key])\n\telseif old ~= value then\n\t\tself.__data[key] = value\n\t\tself.__ref[key].Value = value\n\t\tself.__changed = true\n\t\tself.__event:Fire(key, self.__data[key])\n\tend\n\n\tUtils.simulateYield()\n\n\tself.__writeLock[key] = nil\n\tself.__writeCache[key] = tick()\n\n\tself.__getCache[key] = tick()\n\n\tUtils.logMethod(self, \"UpdateAsync\", key, value)\n\n\treturn value\nend\n\nfunction MockOrderedDataStore:GetSortedAsync(ascending, pageSize, minValue, maxValue)\n\tif type(ascending) ~= \"boolean\" then\n\t\terror((\"bad argument #1 to 'GetSortedAsync' (boolean expected, got %s)\"):format(typeof(ascending)), 2)\n\telseif type(pageSize) ~= \"number\" then\n\t\terror((\"bad argument #2 to 'GetSortedAsync' (number expected, got %s)\"):format(typeof(pageSize)), 2)\n\tend\n\n\tpageSize = math.floor(pageSize + .5)\n\tif pageSize <= 0 or pageSize > Constants.MAX_PAGE_SIZE then\n\t\terror((\"bad argument #2 to 'GetSortedAsync' (page size must be an integer above 0 and below or equal to %d)\")\n\t\t\t:format(Constants.MAX_PAGE_SIZE), 2)\n\tend\n\n\tif minValue ~= nil then\n\t\tif type(minValue) ~= \"number\" then\n\t\t\terror((\"bad argument #3 to 'GetSortedAsync' (number expected, got %s)\"):format(typeof(minValue)), 2)\n\t\telseif minValue % 1 ~= 0 then\n\t\t\terror(\"bad argument #3 to 'GetSortedAsync' (minimum threshold must be an integer)\", 2)\n\t\tend\n\telse\n\t\tminValue = -math.huge\n\tend\n\n\tif maxValue ~= nil then\n\t\tif type(maxValue) ~= \"number\" then\n\t\t\terror((\"bad argument #4 to 'GetSortedAsync' (number expected, got %s)\"):format(typeof(maxValue)), 2)\n\t\telseif maxValue % 1 ~= 0 then\n\t\t\terror(\"bad argument #4 to 'GetSortedAsync' (maximum threshold must be an integer)\", 2)\n\t\tend\n\telse\n\t\tmaxValue = math.huge\n\tend\n\n\tUtils.simulateErrorCheck(\"GetSortedAsync\")\n\n\tlocal success = MockDataStoreManager.YieldForBudget(\n\t\tfunction()\n\t\t\twarn(\"GetSortedAsync request was throttled due to lack of budget. Try sending fewer requests.\")\n\t\tend,\n\t\t{Enum.DataStoreRequestType.GetSortedAsync}\n\t)\n\n\tif not success then\n\t\terror(\"GetSortedAsync rejected with error (request was throttled, but throttled queue was full)\", 2)\n\tend\n\n\tif minValue > maxValue then\n\t\tUtils.simulateYield()\n\t\terror(\"GetSortedAsync rejected with error (minimum threshold is higher than maximum threshold)\", 2)\n\tend\n\n\tif self.__changed then\n\t\ttable.sort(self.__sorted, function(a,b) return a.Value < b.Value end)\n\t\tself.__changed = false\n\tend\n\n\tlocal results = {}\n\n\tif ascending then\n\t\tlocal i = 1\n\t\twhile self.__sorted[i] and self.__sorted[i].Value < minValue do\n\t\t\ti = i + 1\n\t\tend\n\t\twhile self.__sorted[i] and self.__sorted[i].Value <= maxValue do\n\t\t\ttable.insert(results, {key = self.__sorted[i].Key, value = self.__sorted[i].Value})\n\t\t\ti = i + 1\n\t\tend\n\telse\n\t\tlocal i = #self.__sorted\n\t\twhile i > 0 and self.__sorted[i].Value > maxValue do\n\t\t\ti = i - 1\n\t\tend\n\t\twhile i > 0 and self.__sorted[i].Value >= minValue do\n\t\t\ttable.insert(results, {key = self.__sorted[i].Key, value = self.__sorted[i].Value})\n\t\t\ti = i - 1\n\t\tend\n\tend\n\n\tUtils.simulateYield()\n\n\tUtils.logMethod(self, \"GetSortedAsync\")\n\n\treturn setmetatable({\n\t\t__datastore = self;\n\t\t__currentPage = 1;\n\t\t__pageSize = pageSize;\n\t\t__results = results;\n\t\tIsFinished = (#results <= pageSize);\n\t}, MockDataStorePages)\nend\n\nfunction MockOrderedDataStore:ExportToJSON()\n\treturn HttpService:JSONEncode(self.__data)\nend\n\nfunction MockOrderedDataStore:ImportFromJSON(json, verbose)\n\tlocal content\n\tif type(json) == \"string\" then\n\t\tlocal parsed, value = pcall(function() return HttpService:JSONDecode(json) end)\n\t\tif not parsed then\n\t\t\terror(\"bad argument #1 to 'ImportFromJSON' (string is not valid json)\", 2)\n\t\tend\n\t\tcontent = value\n\telseif type(json) == \"table\" then\n\t\tcontent = json -- No need to deepcopy, OrderedDataStore only contains numbers which are passed by value\n\telse\n\t\terror((\"bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)\"):format(typeof(json)), 2)\n\tend\n\n\tif verbose ~= nil and type(verbose) ~= \"boolean\" then\n\t\terror((\"bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)\"):format(typeof(verbose)), 2)\n\tend\n\n\tUtils.importPairsFromTable(\n\t\tcontent,\n\t\tself.__data,\n\t\tMockDataStoreManager.GetDataInterface(self.__data),\n\t\t(verbose == false and function() end or warn),\n\t\t\"ImportFromJSON\",\n\t\t(\"OrderedDataStore > %s > %s\"):format(self.__name, self.__scope),\n\t\ttrue\n\t)\nend\n\nreturn MockOrderedDataStore\n",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: MockOrderedDataStore)>"
}