{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: QuickNetwork)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: QuickNetwork)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: QuickNetwork)>",
  "Sandboxed": false,
  "ScriptGuid": "{CDDA11C0-2FF5-421B-B06B-5C2ECB423AEC}",
  "Source": "--[[\n    QuickNetwork.GetDataNetwork(name, defaultDataTemplate, mock)\n\n\tDataNetwork.DataErrorSignal\n\tDataNetwork.DataCorruptionSignal\n\n\tData:Reset()\n\tData:Set(key, value)\n\tData:SetTable(table, key, value)\n\tData:Save(forceSave)\n\tData:Wipe(forceWipe)\n\tData:Clear()\n\tData:IsActive()\n\tData:CombineDataStoresAsync(dataStores)\n\tData:CombineKeysAsync(keys)\n\tData:IsBackup()\n\tData:ClearBackup()\n\tData:Reconcile()\n\tData.ListenToUpdate\n\tData.ListenToSave\n\tData.ListenToWipe\n]]\n\nlocal QuickNetwork = {\n\tBindToShutdown = false\n}\n\nlocal DataNetwork = {CachedNetworks = {}}\nDataNetwork.__index = DataNetwork\n\nlocal DataStoreService = game:GetService(\"DataStoreService\")\nlocal RunService = game:GetService(\"RunService\")\nlocal HttpService = game:GetService(\"HttpService\")\n\nlocal Settings = require(script.Settings)\nlocal Data = require(script.Classes.Data)\nlocal Utility = require(script.AbstractionLayers.Utility)\nlocal Signal = require(script.Classes.Signal)\nlocal Queue = require(script.AbstractionLayers.Queue)\nlocal Constants = require(script.Constants)\nlocal MockDataStoreService = require(script.Classes.MockDataStoreService)\n\nlocal MAX_DATA_CHARACTERS = Constants.MAX_DATA_CHARACTERS\nlocal MAX_KEY_CHARACTERS = Constants.MAX_KEY_CHARACTERS\nlocal MAX_DATASTORE_NAME_CHARACTERS = Constants.MAX_DATASTORE_NAME_CHARACTERS\nlocal INVALID_ARGUMENT_TYPE = Constants.INVALID_ARGUMENT_TYPE\nlocal BACKUP_DATASTORE_NAME = Constants.BACKUP_DATASTORE_NAME\nlocal DATA_CORRUPTIONSIGNAL_RETURN_VALUES = Constants.DATA_CORRUPTIONSIGNAL_RETURN_VALUES\nlocal DATA_ERRORSIGNAL_RETURN_VALUES = Constants.DATA_ERRORSIGNAL_RETURN_VALUES\n\nlocal globalMock = false\n\nlocal SessionLockedData = {}\nQuickNetwork.DataStoreErrorHandleFinish = Signal.new()\n\nlocal function DeepCopyTable(tabl)\n\tlocal copiedTable = {}\n\n\tsetmetatable(copiedTable, getmetatable(tabl))\n\n\tfor key, value in pairs(tabl) do\n\t\tif typeof(value) == \"table\" then\n\t\t\tcopiedTable[key] = DeepCopyTable(value)\n\t\telse\n\t\t\tcopiedTable[key] = value\n\t\tend\n\tend\n\n\treturn copiedTable\nend\n\nlocal function HeartbeatWait(yield)\n\tif yield == 0 or typeof(yield) ~= \"number\" then\n\t\treturn RunService.Heartbeat:Wait()\n\tend\n\n\tlocal dtPassed = 0 \n\n\twhile true do\n\t\tif dtPassed >= yield then\n\t\t\treturn dtPassed\n\t\tend \n\n\t\tdtPassed += RunService.Heartbeat:Wait()\n\tend\t\nend \n\nlocal function Output(message)\n\tif not Settings.Logging then\n\t\treturn\n\tend\n\n\twarn(message)\nend\n\nlocal function BindToClose()\n\tif RunService:IsStudio() and not Settings.SaveOnShutDownInStudio and Settings.SaveInStudio and #SessionLockedData > 0 then\n\t\tif #SessionLockedData == 1 and SessionLockedData[1].MetaData.BoundToClear then\n\t\t\treturn\n\t\tend\n\t\t\n\t\tOutput((\"[QuickNetwork]: Data won't save on server shutdown in Studio as SaveOnShutDownInStudio is false\"))\n\t\treturn\n\tend\n\n\tlocal clearJobsFinished = Signal.new()\n\tlocal clearJobs = #SessionLockedData\n\n\tQuickNetwork.BindToShutdown = true\n\n\tfor _, data in ipairs(SessionLockedData) do\t\n\t\tcoroutine.wrap(function()\n\t\t\tdata:Clear()\n\t\t\tclearJobs -= 1\n\t\tend)()\n\n\t\tif clearJobs == 0 then\n\t\t\tclearJobsFinished:Fire()\n\t\tend\n\tend\n\n\tif clearJobs > 0 then\n\t\tclearJobsFinished:Wait() -- Yield until clear jobs have finished\n\tend\nend\n\nlocal function CheckTableSize(tabl)\n\tlocal tablCharacters = #HttpService:JSONEncode(tabl)\n\treturn tablCharacters < Constants.MAX_DATA_CHARACTERS, tablCharacters\nend\n\nlocal function HandleDataSessionLock(dataNetwork, key, backup)\n\twhile true do\n\t\tlocal data, sessionLocked = Queue.QueueAPICall({dataNetwork, key, _, backup}, Utility.Load)  \n\n\t\tif not sessionLocked and typeof(data) ~= \"table\" then\n\t\t\t-- Data couldn’t be loaded \n\t\t\tbreak\n\n\t\telseif not sessionLocked then\n\t\t\tdata.MetaData.SessionLockFree = true\n\t\t\treturn data\n\t\tend\n\tend\nend\n\nfunction DataNetwork:SaveCachedData(forceSave)\n\tfor _, data in pairs(self.cachedData) do\n\t\tcoroutine.wrap(data.Save)(data, forceSave)\n\tend\nend\n\nfunction DataNetwork:WipeCachedData(forceWipe)\n\tfor _, data in pairs(self.cachedData) do\n\t\tcoroutine.wrap(data.Wipe)(data, forceWipe)\n\tend\nend\n\nfunction DataNetwork:LoadDataAsync(key, loadMethod, readOnly) \n\tassert(typeof(key) == \"string\" or typeof(key) == \"number\", INVALID_ARGUMENT_TYPE:format(1, \"number or string\", typeof(key)))\n\tassert(#tostring(key) < MAX_KEY_CHARACTERS, INVALID_ARGUMENT_TYPE:format(1, (\"key characters <= %s\"):format(MAX_KEY_CHARACTERS), (\"%s characters\"):format(#tostring(key))))\n\tassert(typeof(loadMethod) == \"string\" or loadMethod == nil, INVALID_ARGUMENT_TYPE:format(2, \"load method [Cancel, Steal, nil]\", tostring(loadMethod)))\n\tassert(typeof(readOnly) == \"boolean\" or readOnly == nil, INVALID_ARGUMENT_TYPE:format(3, \"boolean or nil\", typeof(readOnly)))\n\n\tloadMethod = loadMethod and loadMethod:lower() or loadMethod\n\n\tif self._LoadingQueue[key] then\n\t\tself._LoadingQueue[key]:Wait()\n\t\treturn self.CachedData[key]\n\telse\n\t\tif self.CachedData[key] then \n\t\t\treturn self.CachedData[key]\n\t\tend\n\tend\n\n\tself._LoadingQueue[key] = Signal.new()\n\n\tlocal data, sessionLocked = Queue.QueueAPICall({self, key, loadMethod, false, readOnly}, Utility.Load)  \n\tlocal backup = false\n\tlocal loaded = false\n\t\n\tif typeof(data) ~= \"table\" and typeof(data) ~= \"string\" then\n\t\tif data == nil then\n\t\t\t-- Case #1: Data is nil\n\n\t\t\tif sessionLocked and loadMethod == \"cancel\" then\n\t\t\t\treturn\n\t\t\tend \n\n\t\t\tdata = HandleDataSessionLock(self, key, false)\n\t\telse   \n\t\t\t-- Data wasn’t saved, load backup data:\n\t\t\tlocal backupData, sessionLocked = Queue.QueueAPICall({self, key, loadMethod, true, readOnly}, Utility.Load) \n\n\t\t\tif sessionLocked then\n\t\t\t\tbackupData = HandleDataSessionLock(self, key, true)\n\t\t\tend\n\n\t\t\tif typeof(backupData) == \"table\" then\n\t\t\t\tdata = backupData\n\t\t\t\tloaded = true\n\t\t\telse\n\t\t\t\tloaded = false\n\t\t\tend\n\t\tend\n\tend\n\n\tif data == \"CORRUPTED\" then\n\t\t-- Case #2: Data was loaded but is corrupted\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Data loaded was corrupted\"):format(key))\t\n\t\tlocal response = self.DataCorruptionSignal:Fire(key, \"Data loaded was corrupted\")\n\n\t\tresponse = typeof(response) == \"string\" and response:lower() or response\n\t\tassert(Constants.DATA_CORRUPTIONSIGNAL_RETURN_VALUES[response] or DATA_CORRUPTIONSIGNAL_RETURN_VALUES[typeof(response)], INVALID_ARGUMENT_TYPE:format(1, \"return value [Cancel, LoadBackup, nil, Table]\", tostring(response)))\n\n\t\tif response == \"loadbackup\" then\n\t\t\tlocal backupData, sessionLocked = Queue.QueueAPICall({self, key, loadMethod, true, readOnly}, Utility.Load) \n\t\t\tif sessionLocked then\n\t\t\t\tbackupData = HandleDataSessionLock(self, key, true)\n\t\t\tend\n\n\t\t\tif typeof(backupData) == \"table\" then\n\t\t\t\tdata = backupData\n\t\t\telse\n\t\t\t\tdata = nil\n\t\t\tend\n\n\t\telseif response == \"cancel\" then\n\t\t\treturn\t\n\n\t\telseif typeof(response) == \"table\" then\n\t\t\tlocal tableSizeUnderLimit, characters = CheckTableSize(response)\n\t\t\tassert(tableSizeUnderLimit, INVALID_ARGUMENT_TYPE:format(1, (\"expected data characters lower than %s\"):format(Constants.MAX_DATA_CHARACTERS), characters))\n\n\t\t\tdata = response\n\t\tend\n\n\t\tloaded = true\n\n\telseif typeof(data) == \"string\" then\n\t\t-- Case #3: Data couldn't be loaded\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Data couldn't be loaded, error message: %s\"):format(key, data))\t\n\t\tlocal response = self.DataErrorLoadSignal:Fire(key, (\"Error loading data, %s\"):format(data))\n\t\t\n\t\tresponse = typeof(response) == \"string\" and response:lower() or response\n\t\tassert(DATA_ERRORSIGNAL_RETURN_VALUES[response] or DATA_ERRORSIGNAL_RETURN_VALUES[typeof(response)], INVALID_ARGUMENT_TYPE:format(1, \"return value [Cancel, LoadBackup, nil, Table]\", tostring(response)))\n\n\t\tif response == \"loadbackup\" then\n\t\t\tlocal backupData, sessionLocked = Queue.QueueAPICall({self, key, loadMethod, true, readOnly}, Utility.Load) \n\t\t\tif sessionLocked then\n\t\t\t\tbackupData = HandleDataSessionLock(self, key, true)\n\t\t\tend\n\n\t\t\tdata = typeof(backupData) == \"table\" and backupData or nil\n\n\t\telseif response == \"cancel\" then\n\t\t\treturn\n\n\t\telseif typeof(response) == \"table\" then\n\t\t\tlocal tableSizeUnderLimit, characters = CheckTableSize(response)\n\t\t\tassert(tableSizeUnderLimit, INVALID_ARGUMENT_TYPE:format(1, (\"expected data characters lower than %s\"):format(Constants.MAX_DATA_CHARACTERS), characters))\n\n\t\t\tdata = response\n\t\tend\n\n\t\tloaded = typeof(data) == \"table\" \n\t\tbackup = loaded\n\n\t\tif typeof(data) == \"table\" then\n\t\t\tloaded = true\n\t\tend\n\telse\n\t\tloaded = true\n\tend\n\t\n\tif typeof(data) ~= \"table\" then\n\t\tdata = DeepCopyTable(self.DefaultDataTemplate) \n\tend\n\n\tdata.MetaData = data.MetaData or {}\n\tdata.MetaData.Key = key \n\tdata.MetaData.BoundToClear = false\n\tdata.MetaData.Backup = backup\n\tdata.MetaData.Updated = false\t\n\tdata.MetaData.Cleared = false\n\tdata.MetaData.SessionLockFree = (data.MetaData.SessionLockFree == nil) and true or data.MetaData.SessionLockFree\n\tdata.MetaData.Loaded = loaded\n\tdata.MetaData.SessionJobTime = data.MetaData.SessionJobTime or os.time()\n\tdata.MetaData.DataNetwork = setmetatable(DeepCopyTable(self), DataNetwork)\n\n\tdata.ListenToUpdate = Signal.new()\n\tdata.ListenToSave = Signal.new()\n\tdata.ListenToWipe = Signal.new()\n\tdata._ListenToClear = Signal.new() \n\n\tsetmetatable(data, {__index = function(_, key)\n\t\tlocal value = rawget(Data, key)\n\t\tassert(not (typeof(value) == \"function\" and readOnly), \"Writing or calling any methods on data isn't possible as it is read only!\")\n\n\t\treturn value\n\tend})\n\n\tself.CachedData[key] = data\n\tself._LoadingQueue[key]:Fire()\n\tself._LoadingQueue[key] = nil\n\n\tlocal index = #SessionLockedData + 1\n\ttable.insert(SessionLockedData, index, data)\n\n\t-- Auto saving \n\tcoroutine.wrap(function()\n\t\twhile data.MetaData.Loaded and data.MetaData.SessionLockFree and not data.MetaData.Cleared do\n\t\t\t-- Make sure data is updated and autosaving is allowed:\n\t\t\tif data.MetaData.Updated and Settings.AutoSave and not data.MetaData.BoundToClear then\n\t\t\t\tdata.MetaData.AutoSaving = true\n\t\t\t\tdata:Save() \n\t\t\tend\n\n\t\t\tHeartbeatWait(Settings.AutoSaveInterval)\n\t\tend\n\tend)()\n\n\t-- Clear up data when the data is about to be cleared:\n\tdata._ListenToClear:Connect(function()\n\t\tSessionLockedData[index] = nil\n\t\tself.CachedData[key] = nil\n\t\tdata.MetaData.Cleared = true\n\n\t\tfor _, value in pairs(data) do\n\t\t\tlocal signal = typeof(value) == \"table\" and value.Signal \n\t\t\tif signal then \n\t\t\t\tvalue:Disconnect()\n\t\t\tend\n\t\tend\n\tend)\n\n\treturn data\nend\n\nfunction DataNetwork:GetCachedData(key)\n\tlocal cachedData = self.CachedData[key]\n\n\tif not cachedData then\n\t\twarn((\"%s's cached data was not found\"):format(key))\n\t\treturn\n\tend\n\n\treturn cachedData\nend\n\nfunction QuickNetwork.GetDataNetwork(name, defaultDataTemplate, mock) \n\t-- Return cached data network if found:\n\tif DataNetwork.CachedNetworks[name] then\n\t\treturn DataNetwork.CachedNetworks[name]\n\tend\n\n\tassert(typeof(name) == \"string\", INVALID_ARGUMENT_TYPE:format(1, \"string\", typeof(name)))\n\tassert(typeof(defaultDataTemplate) == \"table\", INVALID_ARGUMENT_TYPE:format(2, \"table\", typeof(defaultDataTemplate)))\n\tassert(typeof(mock) == \"boolean\" or mock == nil, INVALID_ARGUMENT_TYPE:format(3, \"boolean or nil\", typeof(mock)))\n\n\tlocal _, characters = CheckTableSize(defaultDataTemplate)\n\tassert(CheckTableSize(defaultDataTemplate), INVALID_ARGUMENT_TYPE:format(2, (\"data characters <= %s\"):format(MAX_KEY_CHARACTERS), characters))\n\n\tif not QuickNetwork.DataStoreErrorHandleFinish.Fired then\n\t\tQuickNetwork.DataStoreErrorHandleFinish:Wait()\n\tend\n\n\tlocal dataNetwork = {\n\t\tDefaultDataTemplate = defaultDataTemplate,\n\t\tCachedData = {},\n\t\t_LoadingQueue = {},\n\n\t\t-- Signals\n\t\tDataCorruptionSignal = Signal.new(),\n\t\tDataErrorLoadSignal = Signal.new(),\n\t}\n\n\tmock = globalMock or mock\n\n\tif mock then\n\t\tdataNetwork.DataStore = MockDataStoreService:GetDataStore(name)\n\t\tdataNetwork.BackupDataStore = MockDataStoreService:GetDataStore(BACKUP_DATASTORE_NAME:format(name)) \n\telse\n\t\tdataNetwork.DataStore = DataStoreService:GetDataStore(name)\n\t\tdataNetwork.BackupDataStore = DataStoreService:GetDataStore(BACKUP_DATASTORE_NAME:format(name)) \n\tend\n\n\tDataNetwork.CachedNetworks[name] = dataNetwork \n\treturn setmetatable(dataNetwork, DataNetwork)\nend\n\ngame:BindToClose(BindToClose)\nData._Init(QuickNetwork)\n\n-- Handle any data store related errors in a new scope:\n\ndo\n\tlocal TestDataStore = DataStoreService:GetDataStore(\"_TestDataStore\")\n\n\tif RunService:IsClient() then \n\t\t-- Module is required by a local script\n\t\treturn Output((\"[QuickNetwork]: Is running on the client, won't function!\"))\n\tend\n\n\tcoroutine.wrap(function()\n\t\tlocal response = select(2, pcall(TestDataStore.GetAsync, TestDataStore, \"_\"))\n\n\t\tif response then\n\t\t\tif response:find(\"403\") then\n\t\t\t\t-- API Services are disabled\n\t\t\t\tglobalMock = Settings.UseMockDataStoreOffline\n\t\t\t\twarn((\"[QuickNetwork]: API services are disabled, %s\"):format(globalMock and \"will use MockDataStoreService\" or \"won't function!\"))\n\n\t\t\telseif response:find(\"502\") then\n\t\t\t\t-- No internet access\n\t\t\t\tglobalMock = Settings.UseMockDataStoreOffline\n\t\t\t\twarn((\"[QuickNetwork]: No internet access or error processing on Roblox servers, %s\"):format(globalMock and \"will use MockDataStoreService\" or \"won't function!\"))\t\n\n\t\t\telseif response:find(\"402\") then\n\t\t\t\tglobalMock = Settings.UseMockDataStoreOffline\n\t\t\t\t-- Rare case: server is shutting down as soon as this module was required\n\t\t\t\twarn((\"[QuickNetwork]: Server is shutting down, won't function!\"))\n\t\t\tend\n\t\tend\n\n\t\tQuickNetwork.DataStoreErrorHandleFinish:Fire()\n\tend)()\nend\n\nreturn QuickNetwork \n",
  "SourceAssetId": 6474226265,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: QuickNetwork)>"
}