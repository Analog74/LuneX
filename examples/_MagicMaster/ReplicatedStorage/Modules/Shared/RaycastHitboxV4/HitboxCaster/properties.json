{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: HitboxCaster)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: HitboxCaster)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: HitboxCaster)>",
  "Sandboxed": false,
  "ScriptGuid": "{74D3F4B3-D875-4CE5-B71C-0B03E7EA786E}",
  "Source": "--!nocheck\r\n--- Creates and manages the hitbox class\r\n-- @author Swordphin123\r\n\r\n-- Instance options\r\nlocal DEFAULT_ATTACHMENT_INSTANCE: string = \"DmgPoint\"\r\nlocal DEFAULT_GROUP_NAME_INSTANCE: string = \"Group\"\r\n\r\n-- Debug / Test ray visual options\r\nlocal DEFAULT_DEBUGGER_RAY_DURATION: number = 0.25\r\n\r\n-- Debug Message options\r\nlocal DEFAULT_DEBUG_LOGGER_PREFIX: string = \"[ Raycast Hitbox V4 ]\\n\"\r\nlocal DEFAULT_MISSING_ATTACHMENTS: string = \"No attachments found in object: %s. Can be safely ignored if using SetPoints.\"\r\nlocal DEFAULT_ATTACH_COUNT_NOTICE: string = \"%s attachments found in object: %s.\"\r\n\r\n-- Hitbox values\r\nlocal MINIMUM_SECONDS_SCHEDULER: number = 1 / 60\r\nlocal DEFAULT_SIMULATION_TYPE: RBXScriptSignal = game:GetService(\"RunService\").Heartbeat\r\n\r\n--- Variable definitions\r\nlocal CollectionService: CollectionService = game:GetService(\"CollectionService\")\r\nlocal VisualizerCache = require(script.Parent.VisualizerCache)\r\n\r\nlocal ActiveHitboxes: {[number]: any} = {}\r\nlocal Solvers: Instance = script.Parent:WaitForChild(\"Solvers\")\r\n\r\nlocal Hitbox = {}\r\nHitbox.__index = Hitbox\r\nHitbox.__type = \"RaycastHitbox\"\r\n\r\nHitbox.CastModes = {\r\n\tLinkAttachments = 1,\r\n\tAttachment = 2,\r\n\tVector3 = 3,\r\n\tBone = 4,\r\n}\r\n\r\n--- Point type\r\ntype Point = {\r\n\tGroup: string?,\r\n\tCastMode: number,\r\n\tLastPosition: Vector3?,\r\n\tWorldSpace: Vector3?,\r\n\tInstances: {[number]: Instance | Vector3}\r\n}\r\n\r\n-- AdornmentData type\r\ntype AdornmentData = VisualizerCache.AdornmentData\r\n\r\n--- Activates the raycasts for the hitbox object.\r\n--- The hitbox will automatically stop and restart if the hitbox was already casting.\r\n-- @param optional number parameter to automatically turn off the hitbox after 'n' seconds\r\nfunction Hitbox:HitStart(seconds: number?)\r\n\tif self.HitboxActive then\r\n\t\tself:HitStop()\r\n\tend\r\n\r\n\tif seconds then\r\n\t\tself.HitboxStopTime = os.clock() + math.max(MINIMUM_SECONDS_SCHEDULER, seconds)\r\n\tend\r\n\r\n\tself.HitboxActive = true\r\nend\r\n\r\n--- Disables the raycasts for the hitbox object, and clears all current hit targets.\r\n--- Also automatically cancels any current time scheduling for the current hitbox.\r\nfunction Hitbox:HitStop()\r\n\tself.HitboxActive = false\r\n\tself.HitboxStopTime = 0\r\n\ttable.clear(self.HitboxHitList)\r\nend\r\n\r\n--- Queues the hitbox to be destroyed in the next frame\r\nfunction Hitbox:Destroy()\r\n\tself.HitboxPendingRemoval = true\r\n\r\n\tif self.HitboxObject then\r\n\t\tCollectionService:RemoveTag(self.HitboxObject, self.Tag)\r\n\tend\r\n\r\n\tself:HitStop()\r\n\tself.OnHit:Destroy()\r\n\tself.OnUpdate:Destroy()\r\n\tself.HitboxRaycastPoints = nil\r\n\tself.HitboxObject = nil\r\nend\r\n\r\n--- Searches for attachments for the given instance (if applicable)\r\nfunction Hitbox:Recalibrate()\r\n\tlocal descendants: {[number]: Instance} = self.HitboxObject:GetDescendants()\r\n\tlocal attachmentCount: number = 0\r\n\r\n\t--- Remove all previous attachments\r\n\tfor i = #self.HitboxRaycastPoints, 1, -1 do\r\n\t\tif self.HitboxRaycastPoints[i].CastMode == Hitbox.CastModes.Attachment then\r\n\t\t\ttable.remove(self.HitboxRaycastPoints, i)\r\n\t\tend\r\n\tend\r\n\r\n\tfor _, attachment: any in ipairs(descendants) do\r\n\t\tif not attachment:IsA(\"Attachment\") or attachment.Name ~= DEFAULT_ATTACHMENT_INSTANCE then\r\n\t\t\tcontinue\r\n\t\tend\r\n\r\n\t\tlocal group: string? = attachment:GetAttribute(DEFAULT_GROUP_NAME_INSTANCE)\r\n\t\tlocal point: Point = self:_CreatePoint(group, Hitbox.CastModes.Attachment, attachment.WorldPosition)\r\n\r\n\t\ttable.insert(point.Instances, attachment)\r\n\t\ttable.insert(self.HitboxRaycastPoints, point)\r\n\r\n\t\tattachmentCount += 1\r\n\tend\r\n\r\n\tif self.DebugLog then\r\n\t\tprint(string.format(\"%s%s\", DEFAULT_DEBUG_LOGGER_PREFIX,\r\n\t\t\tattachmentCount > 0 and string.format(DEFAULT_ATTACH_COUNT_NOTICE, attachmentCount, self.HitboxObject.Name) or\r\n\t\t\t\tstring.format(DEFAULT_MISSING_ATTACHMENTS, self.HitboxObject.Name))\r\n\t\t)\r\n\tend\r\nend\r\n\r\n--- Creates a link between two attachments. The module will constantly raycast between these two attachments.\r\n-- @param attachment1 Attachment object (can have a group attribute)\r\n-- @param attachment2 Attachment object\r\nfunction Hitbox:LinkAttachments(attachment1: Attachment, attachment2: Attachment)\r\n\tlocal group: string? = attachment1:GetAttribute(DEFAULT_GROUP_NAME_INSTANCE)\r\n\tlocal point: Point = self:_CreatePoint(group, Hitbox.CastModes.LinkAttachments)\r\n\r\n\tpoint.Instances[1] = attachment1\r\n\tpoint.Instances[2] = attachment2\r\n\ttable.insert(self.HitboxRaycastPoints, point)\r\nend\r\n\r\n--- Removes the link of an attachment. Putting one of any of the two original attachments you used in LinkAttachment will automatically sever the other\r\n-- @param attachment\r\nfunction Hitbox:UnlinkAttachments(attachment: Attachment)\r\n\tfor i = #self.HitboxRaycastPoints, 1, -1 do\r\n\t\tif #self.HitboxRaycastPoints[i].Instances >= 2 then\r\n\t\t\tif self.HitboxRaycastPoints[i].Instances[1] == attachment or self.HitboxRaycastPoints[i].Instances[2] == attachment then\r\n\t\t\t\ttable.remove(self.HitboxRaycastPoints, i)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--- Creates raycast points using only vector3 values.\r\n-- @param object BasePart or Bone, the part you want the points to be locally offset from\r\n-- @param table of vector3 values that are in local space relative to the basePart or bone\r\n-- @param optional group string parameter that names the group these points belong to\r\nfunction Hitbox:SetPoints(object: BasePart | Bone, vectorPoints: {[number]: Vector3}, group: string?)\r\n\tfor _: number, vector: Vector3 in ipairs(vectorPoints) do\r\n\t\tlocal point: Point = self:_CreatePoint(group, Hitbox.CastModes[object:IsA(\"Bone\") and \"Bone\" or \"Vector3\"])\r\n\r\n\t\tpoint.Instances[1] = object\r\n\t\tpoint.Instances[2] = vector\r\n\t\ttable.insert(self.HitboxRaycastPoints, point)\r\n\tend\r\nend\r\n\r\n--- Removes raycast points using only vector3 values. Use the same vector3 table from SetPoints\r\n-- @param object BasePart or Bone, the original instance you used for SetPoints\r\n-- @param table of vector values that are in local space relative to the basePart\r\nfunction Hitbox:RemovePoints(object: BasePart | Bone, vectorPoints: {[number]: Vector3})\r\n\tfor i = #self.HitboxRaycastPoints, 1, -1 do\r\n\t\tlocal part = (self.HitboxRaycastPoints[i] :: Point).Instances[1]\r\n\r\n\t\tif part == object then\r\n\t\t\tlocal originalVector = (self.HitboxRaycastPoints[i] :: Point).Instances[2]\r\n\r\n\t\t\tfor _: number, vector: Vector3 in ipairs(vectorPoints) do\r\n\t\t\t\tif vector == originalVector :: Vector3 then\r\n\t\t\t\t\ttable.remove(self.HitboxRaycastPoints, i)\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--- Internal function that returns a point type\r\n-- @param group string name\r\n-- @param castMode numeric enum value\r\n-- @param lastPosition Vector3 value\r\nfunction Hitbox:_CreatePoint(group: string?, castMode: number, lastPosition: Vector3?): Point\r\n\treturn {\r\n\t\tGroup = group,\r\n\t\tCastMode = castMode,\r\n\t\tLastPosition = lastPosition,\r\n\t\tWorldSpace = nil,\r\n\t\tInstances = {},\r\n\t}\r\nend\r\n\r\n--- Internal function that finds an existing hitbox from a given instance\r\n-- @param instance object\r\nfunction Hitbox:_FindHitbox(object: any)\r\n\tfor _: number, hitbox: any in ipairs(ActiveHitboxes) do\r\n\t\tif not hitbox.HitboxPendingRemoval and hitbox.HitboxObject == object then\r\n\t\t\treturn hitbox\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--- Runs for the very first time whenever a hitbox is created\r\n--- Do not run this more than once, you may introduce memory leaks if you do so\r\nfunction Hitbox:_Init()\r\n\tif not self.HitboxObject then return end\r\n\r\n\tlocal tagConnection: RBXScriptConnection\r\n\r\n\tlocal function onTagRemoved(instance: Instance)\r\n\t\tif instance == self.HitboxObject then\r\n\t\t\ttagConnection:Disconnect()\r\n\t\t\tself:Destroy()\r\n\t\tend\r\n\tend\r\n\r\n\tself:Recalibrate()\r\n\ttable.insert(ActiveHitboxes, self)\r\n\tCollectionService:AddTag(self.HitboxObject, self.Tag)\r\n\r\n\ttagConnection = CollectionService:GetInstanceRemovedSignal(self.Tag):Connect(onTagRemoved)\r\nend\r\n\r\nlocal function Init()\r\n\t--- Reserve table sizing for solver tables\r\n\tlocal solversCache: {[number]: any} = table.create(#Solvers:GetChildren())\r\n\r\n\tDEFAULT_SIMULATION_TYPE:Connect(function(step: number)\r\n\t\t--- Iterate through all the hitboxes\r\n\t\tfor i = #ActiveHitboxes, 1, -1 do\r\n\t\t\t--- Skip this hitbox if the hitbox will be garbage collected this frame\r\n\t\t\tif ActiveHitboxes[i].HitboxPendingRemoval then\r\n\t\t\t\tlocal hitbox: any = table.remove(ActiveHitboxes, i)\r\n\t\t\t\ttable.clear(hitbox)\r\n\t\t\t\tsetmetatable(hitbox, nil)\r\n\t\t\t\tcontinue\r\n\t\t\tend\r\n\r\n\t\t\tfor _: number, point: Point in ipairs(ActiveHitboxes[i].HitboxRaycastPoints) do\r\n\t\t\t\t--- Reset this point if the hitbox is inactive\r\n\t\t\t\tif not ActiveHitboxes[i].HitboxActive then\r\n\t\t\t\t\tpoint.LastPosition = nil\r\n\t\t\t\t\tcontinue\r\n\t\t\t\tend\r\n\r\n\t\t\t\t--- Calculate rays\r\n\t\t\t\tlocal castMode: any = solversCache[point.CastMode]\r\n\t\t\t\tlocal origin: Vector3, direction: Vector3 = castMode:Solve(point)\r\n\t\t\t\tlocal raycastResult: RaycastResult = workspace:Raycast(origin, direction, ActiveHitboxes[i].RaycastParams)\r\n\r\n\t\t\t\t--- Draw debug rays\r\n\t\t\t\tif ActiveHitboxes[i].Visualizer then\r\n\t\t\t\t\tlocal adornmentData: AdornmentData? = VisualizerCache:GetAdornment()\r\n\r\n\t\t\t\t\tif adornmentData then\r\n\t\t\t\t\t\tlocal debugStartPosition: CFrame = castMode:Visualize(point)\r\n\t\t\t\t\t\tadornmentData.Adornment.Length = direction.Magnitude\r\n\t\t\t\t\t\tadornmentData.Adornment.CFrame = debugStartPosition\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\r\n\t\t\t\t--- Update the current point's position\r\n\t\t\t\tpoint.LastPosition = castMode:UpdateToNextPosition(point)\r\n\r\n\t\t\t\t--- If a ray detected a hit\r\n\t\t\t\tif raycastResult then\r\n\t\t\t\t\tlocal part: BasePart = raycastResult.Instance\r\n\t\t\t\t\tlocal model: Instance?\r\n\t\t\t\t\tlocal humanoid: Instance?\r\n\t\t\t\t\tlocal target: Instance?\r\n\r\n\t\t\t\t\tif ActiveHitboxes[i].DetectionMode == 1 then\r\n\t\t\t\t\t\tmodel = part:FindFirstAncestorOfClass(\"Model\")\r\n\t\t\t\t\t\tif model then\r\n\t\t\t\t\t\t\thumanoid = model:FindFirstChildOfClass(\"Humanoid\")\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\ttarget = humanoid\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttarget = part\r\n\t\t\t\t\tend\r\n\r\n\t\t\t\t\t--- Found a target. Fire the OnHit event\r\n\t\t\t\t\tif target then\r\n\t\t\t\t\t\tif ActiveHitboxes[i].DetectionMode <= 2 then\r\n\t\t\t\t\t\t\tif ActiveHitboxes[i].HitboxHitList[target] then\r\n\t\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tActiveHitboxes[i].HitboxHitList[target] = true\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\r\n\t\t\t\t\t\tActiveHitboxes[i].OnHit:Fire(part, humanoid, raycastResult, point.Group)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\r\n\t\t\t\t--- Hitbox Time scheduler\r\n\t\t\t\tif ActiveHitboxes[i].HitboxStopTime > 0 then\r\n\t\t\t\t\tif ActiveHitboxes[i].HitboxStopTime <= os.clock() then\r\n\t\t\t\t\t\tActiveHitboxes[i]:HitStop()\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\r\n\t\t\t\t--- OnUpdate event that fires every frame for every point\r\n\t\t\t\tActiveHitboxes[i].OnUpdate:Fire(point.LastPosition)\r\n\r\n\t\t\t\t--- Update SignalType\r\n\t\t\t\tif ActiveHitboxes[i].OnUpdate._signalType ~= ActiveHitboxes[i].SignalType then\r\n\t\t\t\t\tActiveHitboxes[i].OnUpdate._signalType = ActiveHitboxes[i].SignalType\r\n\t\t\t\t\tActiveHitboxes[i].OnHit._signalType = ActiveHitboxes[i].SignalType\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlocal adornmentsInUse: number = #VisualizerCache._AdornmentInUse\r\n\r\n\t\t--- Iterates through all the debug rays to see if they need to be cached or cleaned up\r\n\t\tif adornmentsInUse > 0 then\r\n\t\t\tfor i = adornmentsInUse, 1, -1 do\r\n\t\t\t\tif (os.clock() - VisualizerCache._AdornmentInUse[i].LastUse) >= DEFAULT_DEBUGGER_RAY_DURATION then\r\n\t\t\t\t\tlocal adornment: AdornmentData? = table.remove(VisualizerCache._AdornmentInUse, i)\r\n\r\n\t\t\t\t\tif adornment then\r\n\t\t\t\t\t\tVisualizerCache:ReturnAdornment(adornment)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend)\r\n\r\n\t--- Require all solvers\r\n\tfor castMode: string, enum: number in pairs(Hitbox.CastModes) do\r\n\t\tlocal moduleScript: Instance? = Solvers:FindFirstChild(castMode)\r\n\r\n\t\tif moduleScript then\r\n\t\t\tlocal load = require(moduleScript)\r\n\t\t\tsolversCache[enum] = load\r\n\t\tend\r\n\tend\r\nend\r\n\r\nInit()\r\n\r\nreturn Hitbox",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: HitboxCaster)>"
}