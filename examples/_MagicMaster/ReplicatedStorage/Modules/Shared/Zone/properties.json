{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: Zone)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: Zone)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: Zone)>",
  "Sandboxed": false,
  "ScriptGuid": "{B8789829-2B4C-4B19-A113-5E0434EE9E5F}",
  "Source": "-- LOCAL\nlocal players = game:GetService(\"Players\")\nlocal runService = game:GetService(\"RunService\")\nlocal heartbeat = runService.Heartbeat\nlocal localPlayer = runService:IsClient() and players.LocalPlayer\nlocal replicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal httpService = game:GetService(\"HttpService\")\nlocal Enum_ = require(script.Enum)\nlocal enum = Enum_.enums\nlocal Janitor = require(script.Janitor)\nlocal Signal = require(script.Signal)\nlocal ZonePlusReference = require(script.ZonePlusReference)\nlocal referenceObject = ZonePlusReference.getObject()\nlocal zoneControllerModule = script.ZoneController\nlocal trackerModule = zoneControllerModule.Tracker\nlocal collectiveWorldModelModule = zoneControllerModule.CollectiveWorldModel\nlocal ZoneController = require(zoneControllerModule)\nlocal referenceLocation = (game:GetService(\"RunService\"):IsClient() and \"Client\") or \"Server\"\nlocal referencePresent = referenceObject and referenceObject:FindFirstChild(referenceLocation)\nif referencePresent then\n\treturn require(referenceObject.Value)\nend\n\nlocal Zone = {}\nZone.__index = Zone\nif not referencePresent then\n\tZonePlusReference.addToReplicatedStorage()\nend\nZone.enum = enum\n\n\n\n-- CONSTRUCTORS\nfunction Zone.new(container)\n\tlocal self = {}\n\tsetmetatable(self, Zone)\n\t\n\t-- Validate container\n\tlocal INVALID_TYPE_WARNING = \"The zone container must be a model, folder, basepart or table!\"\n\tlocal containerType = typeof(container)\n\tif not(containerType == \"table\" or containerType == \"Instance\") then\n\t\terror(INVALID_TYPE_WARNING)\n\tend\n\n\t-- Configurable\n\tself.accuracy = enum.Accuracy.High\n\tself.autoUpdate = true\n\tself.respectUpdateQueue = true\n\t--self.maxPartsAddition = 20\n\t--self.ignoreRecommendedMaxParts = false\n\n\t-- Variable\n\tlocal janitor = Janitor.new()\n\tself.janitor = janitor\n\tself._updateConnections = janitor:add(Janitor.new(), \"destroy\")\n\tself.container = container\n\tself.zoneParts = {}\n\tself.overlapParams = {}\n\tself.region = nil\n\tself.volume = nil\n\tself.boundMin = nil\n\tself.boundMax = nil\n\tself.recommendedMaxParts = nil\n\tself.zoneId = httpService:GenerateGUID()\n\tself.activeTriggers = {}\n\tself.occupants = {}\n\tself.trackingTouchedTriggers = {}\n\tself.enterDetection = enum.Detection.Centre\n\tself.exitDetection = enum.Detection.Centre\n\tself._currentEnterDetection = nil -- This will update automatically internally\n\tself._currentExitDetection = nil -- This will also update automatically internally\n\tself.totalPartVolume = 0\n\tself.allZonePartsAreBlocks = true\n\tself.trackedItems = {}\n\tself.settingsGroupName = nil\n\tself.worldModel = workspace\n\tself.onItemDetails = {}\n\tself.itemsToUntrack = {}\n\n\t-- This updates _currentEnterDetection and _currentExitDetection right away to prevent nil comparisons\n\tZoneController.updateDetection(self)\n\n\t-- Signals\n\tself.updated = janitor:add(Signal.new(), \"destroy\")\n\tlocal triggerTypes = {\n\t\t\"player\",\n\t\t\"part\",\n\t\t\"localPlayer\",\n\t\t\"item\"\n\t}\n\tlocal triggerEvents = {\n\t\t\"entered\",\n\t\t\"exited\",\n\t}\n\tfor _, triggerType in pairs(triggerTypes) do\n\t\tlocal activeConnections = 0\n\t\tlocal previousActiveConnections = 0\n\t\tfor i, triggerEvent in pairs(triggerEvents) do\n\t\t\t-- this enables us to determine when a developer connects to an event\n\t\t\t-- so that we can act accoridngly (i.e. begin or end a checker loop)\n\t\t\tlocal signal = janitor:add(Signal.new(true), \"destroy\")\n\t\t\tlocal triggerEventUpper = triggerEvent:sub(1,1):upper()..triggerEvent:sub(2)\n\t\t\tlocal signalName = triggerType..triggerEventUpper\n\t\t\tself[signalName] = signal\n\t\t\tsignal.connectionsChanged:Connect(function(increment)\n\t\t\t\tif triggerType == \"localPlayer\" and not localPlayer and increment == 1 then\n\t\t\t\t\terror((\"Can only connect to 'localPlayer%s' on the client!\"):format(triggerEventUpper))\n\t\t\t\tend\n\t\t\t\tpreviousActiveConnections = activeConnections\n\t\t\t\tactiveConnections += increment\n\t\t\t\tif previousActiveConnections == 0 and activeConnections > 0 then\n\t\t\t\t\t-- At least 1 connection active, begin loop\n\t\t\t\t\tZoneController._registerConnection(self, triggerType, triggerEventUpper)\n\t\t\t\telseif previousActiveConnections > 0 and activeConnections == 0 then\n\t\t\t\t\t-- All connections have disconnected, end loop\n\t\t\t\t\tZoneController._deregisterConnection(self, triggerType)\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend\n\n\t-- Setup touched receiver functions where applicable\n\tZone.touchedConnectionActions = {}\n\tfor _, triggerType in pairs(triggerTypes) do\n\t\tlocal methodName = (\"_%sTouchedZone\"):format(triggerType)\n\t\tlocal correspondingMethod = self[methodName]\n\t\tif correspondingMethod then\n\t\t\tself.trackingTouchedTriggers[triggerType] = {}\n\t\t\tZone.touchedConnectionActions[triggerType] = function(touchedItem)\n\t\t\t\tcorrespondingMethod(self, touchedItem)\n\t\t\tend\n\t\tend\n\tend\n\n\t-- This constructs the zones boundaries, region, etc\n\tself:_update()\n\n\t-- Register/deregister zone\n\tZoneController._registerZone(self)\n\tjanitor:add(function()\n\t\tZoneController._deregisterZone(self)\n\tend, true)\n\t\n\treturn self\nend\n\nfunction Zone.fromRegion(cframe, size)\n\tlocal MAX_PART_SIZE = 2024\n\tlocal container = Instance.new(\"Model\")\n\tlocal function createCube(cubeCFrame, cubeSize)\n\t\tif cubeSize.X > MAX_PART_SIZE or cubeSize.Y > MAX_PART_SIZE or cubeSize.Z > MAX_PART_SIZE then\n\t\t\tlocal quarterSize = cubeSize * 0.25\n\t\t\tlocal halfSize = cubeSize * 0.5\n\t\t\tcreateCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)\n\t\t\tcreateCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)\n\t\telse\n\t\t\tlocal part = Instance.new(\"Part\")\n\t\t\tpart.CFrame = cubeCFrame\n\t\t\tpart.Size = cubeSize\n\t\t\tpart.Anchored = true\n\t\t\tpart.Parent = container\n\t\tend\n\tend\n\tcreateCube(cframe, size)\n\tlocal zone = Zone.new(container)\n\tzone:relocate()\n\treturn zone\nend\n\n\n\n-- PRIVATE METHODS\nfunction Zone:_calculateRegion(tableOfParts, dontRound)\n\tlocal bounds = {[\"Min\"] = {}, [\"Max\"] = {}}\n\tfor boundType, details in pairs(bounds) do\n\t\tdetails.Values = {}\n\t\tfunction details.parseCheck(v, currentValue)\n\t\t\tif boundType == \"Min\" then\n\t\t\t\treturn (v <= currentValue)\n\t\t\telseif boundType == \"Max\" then\n\t\t\t\treturn (v >= currentValue)\n\t\t\tend\n\t\tend\n\t\tfunction details:parse(valuesToParse)\n\t\t\tfor i,v in pairs(valuesToParse) do\n\t\t\t\tlocal currentValue = self.Values[i] or v\n\t\t\t\tif self.parseCheck(v, currentValue) then\n\t\t\t\t\tself.Values[i] = v\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tfor _, part in pairs(tableOfParts) do\n\t\tlocal sizeHalf = part.Size * 0.5\n\t\tlocal corners = {\n\t\t\tpart.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),\n\t\t\tpart.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, sizeHalf.Z),\n\t\t}\n\t\tfor _, cornerCFrame in pairs(corners) do\n\t\t\tlocal x, y, z = cornerCFrame:GetComponents()\n\t\t\tlocal values = {x, y, z}\n\t\t\tbounds.Min:parse(values)\n\t\t\tbounds.Max:parse(values)\n\t\tend\n\tend\n\tlocal minBound = {}\n\tlocal maxBound = {}\n\t-- Rounding a regions coordinates to multiples of 4 ensures the region optimises the region\n\t-- by ensuring it aligns on the voxel grid\n\tlocal function roundToFour(to_round)\n\t\tlocal ROUND_TO = 4\n\t\tlocal divided = (to_round+ROUND_TO/2) / ROUND_TO\n\t\tlocal rounded = ROUND_TO * math.floor(divided)\n\t\treturn rounded\n\tend\n\tfor boundName, boundDetail in pairs(bounds) do\n\t\tfor _, v in pairs(boundDetail.Values) do\n\t\t\tlocal newTable = (boundName == \"Min\" and minBound) or maxBound\n\t\t\tlocal newV = v\n\t\t\tif not dontRound then\n\t\t\t\tlocal roundOffset = (boundName == \"Min\" and -2) or 2\n\t\t\t\tnewV = roundToFour(v+roundOffset) -- +-2 to ensures the zones region is not rounded down/up\n\t\t\tend\n\t\t\ttable.insert(newTable, newV)\n\t\tend\n\tend\n\tlocal boundMin = Vector3.new(unpack(minBound))\n\tlocal boundMax = Vector3.new(unpack(maxBound))\n\tlocal region = Region3.new(boundMin, boundMax)\n\treturn region, boundMin, boundMax\nend\n\nfunction Zone:_displayBounds()\n\tif not self.displayBoundParts then\n\t\tself.displayBoundParts = true\n\t\tlocal boundParts = {BoundMin = self.boundMin, BoundMax = self.boundMax}\n\t\tfor boundName, boundCFrame in pairs(boundParts) do\n\t\t\tlocal part = Instance.new(\"Part\")\n\t\t\tpart.Anchored = true\n\t\t\tpart.CanCollide = false\n\t\t\tpart.Transparency = 0.5\n\t\t\tpart.Size = Vector3.new(1,1,1)\n\t\t\tpart.Color = Color3.fromRGB(255,0,0)\n\t\t\tpart.CFrame = CFrame.new(boundCFrame)\n\t\t\tpart.Name = boundName\n\t\t\tpart.Parent = workspace\n\t\t\tself.janitor:add(part, \"Destroy\")\n\t\tend\n\tend\nend\n\nfunction Zone:_update()\n\tlocal container = self.container\n\tlocal zoneParts = {}\n\tlocal updateQueue = 0\n\tself._updateConnections:clean()\n\n\tlocal containerType = typeof(container)\n\tlocal holders = {}\n\tlocal INVALID_TYPE_WARNING = \"The zone container must be a model, folder, basepart or table!\"\n\tif containerType == \"table\" then\n\t\tfor _, part in pairs(container) do\n\t\t\tif part:IsA(\"BasePart\") then\n\t\t\t\ttable.insert(zoneParts, part)\n\t\t\tend\n\t\tend\n\telseif containerType == \"Instance\" then\n\t\tif container:IsA(\"BasePart\") then\n\t\t\ttable.insert(zoneParts, container)\n\t\telse\n\t\t\ttable.insert(holders, container)\n\t\t\tfor _, part in pairs(container:GetDescendants()) do\n\t\t\t\tif part:IsA(\"BasePart\") then\n\t\t\t\t\ttable.insert(zoneParts, part)\n\t\t\t\telse\n\t\t\t\t\ttable.insert(holders, part)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tself.zoneParts = zoneParts\n\tself.overlapParams = {}\n\t\n\tlocal allZonePartsAreBlocksNew = true\n\tfor _, zonePart in pairs(zoneParts) do\n\t\tlocal success, shapeName = pcall(function() return zonePart.Shape.Name end)\n\t\tif shapeName ~= \"Block\" then\n\t\t\tallZonePartsAreBlocksNew = false\n\t\tend\n\tend\n\tself.allZonePartsAreBlocks = allZonePartsAreBlocksNew\n\t\n\tlocal zonePartsWhitelist = OverlapParams.new()\n\tzonePartsWhitelist.FilterType = Enum.RaycastFilterType.Whitelist\n\tzonePartsWhitelist.MaxParts = #zoneParts\n\tzonePartsWhitelist.FilterDescendantsInstances = zoneParts\n\tself.overlapParams.zonePartsWhitelist = zonePartsWhitelist\n\n\tlocal zonePartsIgnorelist = OverlapParams.new()\n\tzonePartsIgnorelist.FilterType = Enum.RaycastFilterType.Blacklist\n\tzonePartsIgnorelist.FilterDescendantsInstances = zoneParts\n\tself.overlapParams.zonePartsIgnorelist = zonePartsIgnorelist\n\t\n\t-- this will call update on the zone when the container parts size or position changes, and when a\n\t-- child is removed or added from a holder (anything which isn't a basepart)\n\tlocal function update()\n\t\tif self.autoUpdate then\n\t\t\tlocal executeTime = os.clock()\n\t\t\tif self.respectUpdateQueue then\n\t\t\t\tupdateQueue += 1\n\t\t\t\texecuteTime += 0.1\n\t\t\tend\n\t\t\tlocal updateConnection\n\t\t\tupdateConnection = runService.Heartbeat:Connect(function()\n\t\t\t\tif os.clock() >= executeTime then\n\t\t\t\t\tupdateConnection:Disconnect()\n\t\t\t\t\tif self.respectUpdateQueue then\n\t\t\t\t\t\tupdateQueue -= 1\n\t\t\t\t\tend\n\t\t\t\t\tif updateQueue == 0 and self.zoneId then\n\t\t\t\t\t\tself:_update()\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend\n\tlocal partProperties = {\"Size\", \"Position\"}\n\tlocal function verifyDefaultCollision(instance)\n\t\tif instance.CollisionGroupId ~= 0 then\n\t\t\terror(\"Zone parts must belong to the 'Default' (0) CollisionGroup! Consider using zone:relocate() if you wish to move zones outside of workspace to prevent them interacting with other parts.\")\n\t\tend\n\tend\n\tfor _, part in pairs(zoneParts) do\n\t\tfor _, prop in pairs(partProperties) do\n\t\t\tself._updateConnections:add(part:GetPropertyChangedSignal(prop):Connect(update), \"Disconnect\")\n\t\tend\n\t\tverifyDefaultCollision(part)\n\t\tself._updateConnections:add(part:GetPropertyChangedSignal(\"CollisionGroupId\"):Connect(function()\n\t\t\tverifyDefaultCollision(part)\n\t\tend), \"Disconnect\")\n\tend\n\tlocal containerEvents = {\"ChildAdded\", \"ChildRemoved\"}\n\tfor _, holder in pairs(holders) do\n\t\tfor _, event in pairs(containerEvents) do\n\t\t\tself._updateConnections:add(self.container[event]:Connect(function(child)\n\t\t\t\tif child:IsA(\"BasePart\") then\n\t\t\t\t\tupdate()\n\t\t\t\tend\n\t\t\tend), \"Disconnect\")\n\t\tend\n\tend\n\t\n\tlocal region, boundMin, boundMax = self:_calculateRegion(zoneParts)\n\tlocal exactRegion, _, _ = self:_calculateRegion(zoneParts, true)\n\tself.region = region\n\tself.exactRegion = exactRegion\n\tself.boundMin = boundMin\n\tself.boundMax = boundMax\n\tlocal rSize = region.Size\n\tself.volume = rSize.X*rSize.Y*rSize.Z\n\t\n\t-- Update: I was going to use this for the old part detection until the CanTouch property was released\n\t-- everything below is now irrelevant however I'll keep just in case I use again for future\n\t-------------------------------------------------------------------------------------------------\n\t-- When a zones region is determined, we also check for parts already existing within the zone\n\t-- these parts are likely never to move or interact with the zone, so we set the number of these\n\t-- to the baseline MaxParts value. 'recommendMaxParts' is then determined through the sum of this\n\t-- and maxPartsAddition. This ultimately optimises region checks as they can be generated with\n\t-- minimal MaxParts (i.e. recommendedMaxParts can be used instead of math.huge every time)\n\t--[[\n\tlocal result = self.worldModel:FindPartsInRegion3(region, nil, math.huge)\n\tlocal maxPartsBaseline = #result\n\tself.recommendedMaxParts = maxPartsBaseline + self.maxPartsAddition\n\t--]]\n\t\n\tself:_updateTouchedConnections()\n\t\n\tself.updated:Fire()\nend\n\nfunction Zone:_updateOccupants(trackerName, newOccupants)\n\tlocal previousOccupants = self.occupants[trackerName]\n\tif not previousOccupants then\n\t\tpreviousOccupants = {}\n\t\tself.occupants[trackerName] = previousOccupants\n\tend\n\tlocal signalsToFire = {}\n\tfor occupant, prevItem in pairs(previousOccupants) do\n\t\tlocal newItem = newOccupants[occupant]\n\t\tif newItem == nil or newItem ~= prevItem then\n\t\t\tpreviousOccupants[occupant] = nil\n\t\t\tif not signalsToFire.exited then\n\t\t\t\tsignalsToFire.exited = {}\n\t\t\tend\n\t\t\ttable.insert(signalsToFire.exited, occupant)\n\t\tend\n\tend\n\tfor occupant, _ in pairs(newOccupants) do\n\t\tif previousOccupants[occupant] == nil then\n\t\t\tlocal isAPlayer = occupant:IsA(\"Player\")\n\t\t\tpreviousOccupants[occupant] = (isAPlayer and occupant.Character) or true\n\t\t\tif not signalsToFire.entered then\n\t\t\t\tsignalsToFire.entered = {}\n\t\t\tend\n\t\t\ttable.insert(signalsToFire.entered, occupant)\n\t\tend\n\tend \n\treturn signalsToFire\nend\n\nfunction Zone:_formTouchedConnection(triggerType)\n\tlocal touchedJanitorName = \"_touchedJanitor\"..triggerType\n\tlocal touchedJanitor = self[touchedJanitorName]\n\tif touchedJanitor then\n\t\ttouchedJanitor:clean()\n\telse\n\t\ttouchedJanitor = self.janitor:add(Janitor.new(), \"destroy\")\n\t\tself[touchedJanitorName] = touchedJanitor\n\tend\n\tself:_updateTouchedConnection(triggerType)\nend\n\nfunction Zone:_updateTouchedConnection(triggerType)\n\tlocal touchedJanitorName = \"_touchedJanitor\"..triggerType\n\tlocal touchedJanitor = self[touchedJanitorName]\n\tif not touchedJanitor then return end\n\tfor _, basePart in pairs(self.zoneParts) do\n\t\ttouchedJanitor:add(basePart.Touched:Connect(self.touchedConnectionActions[triggerType], self), \"Disconnect\")\n\tend\nend\n\nfunction Zone:_updateTouchedConnections()\n\tfor triggerType, _ in pairs(self.touchedConnectionActions) do\n\t\tlocal touchedJanitorName = \"_touchedJanitor\"..triggerType\n\t\tlocal touchedJanitor = self[touchedJanitorName]\n\t\tif touchedJanitor then\n\t\t\ttouchedJanitor:cleanup()\n\t\t\tself:_updateTouchedConnection(triggerType)\n\t\tend\n\tend\nend\n\nfunction Zone:_disconnectTouchedConnection(triggerType)\n\tlocal touchedJanitorName = \"_touchedJanitor\"..triggerType\n\tlocal touchedJanitor = self[touchedJanitorName]\n\tif touchedJanitor then\n\t\ttouchedJanitor:cleanup()\n\t\tself[touchedJanitorName] = nil\n\tend\nend\n\nlocal function round(number, decimalPlaces)\n\treturn math.round(number * 10^decimalPlaces) * 10^-decimalPlaces\nend\nfunction Zone:_partTouchedZone(part)\n\tlocal trackingDict = self.trackingTouchedTriggers[\"part\"]\n\tif trackingDict[part] then return end\n\tlocal nextCheck = 0\n\tlocal verifiedEntrance = false\n\tlocal enterPosition = part.Position\n\tlocal enterTime = os.clock()\n\tlocal partJanitor = self.janitor:add(Janitor.new(), \"destroy\")\n\ttrackingDict[part] = partJanitor\n\tlocal instanceClassesToIgnore = {Seat = true, VehicleSeat = true}\n\tlocal instanceNamesToIgnore = {HumanoidRootPart = true}\n\tif not (instanceClassesToIgnore[part.ClassName] or not instanceNamesToIgnore[part.Name])  then\n\t\tpart.CanTouch = false\n\tend\n\t--\n\tlocal partVolume = round((part.Size.X * part.Size.Y * part.Size.Z), 5)\n\tself.totalPartVolume += partVolume\n\t--\n\tpartJanitor:add(heartbeat:Connect(function()\n\t\tlocal clockTime = os.clock()\n\t\tif clockTime >= nextCheck then\n\t\t\t----\n\t\t\tlocal cooldown = enum.Accuracy.getProperty(self.accuracy)\n\t\t\tnextCheck = clockTime + cooldown\n\t\t\t----\n\n\t\t\t-- We initially perform a singular point check as this is vastly more lightweight than a large part check\n\t\t\t-- If the former returns false, perform a whole part check in case the part is on the outer bounds.\n\t\t\tlocal withinZone = self:findPoint(part.CFrame)\n\t\t\tif not withinZone then\n\t\t\t\twithinZone = self:findPart(part)\n\t\t\tend\n\t\t\tif not verifiedEntrance then\n\t\t\t\tif withinZone then\n\t\t\t\t\tverifiedEntrance = true\n\t\t\t\t\tself.partEntered:Fire(part)\n\t\t\t\telseif (part.Position - enterPosition).Magnitude > 1.5 and clockTime - enterTime >= cooldown then\n\t\t\t\t\t-- Even after the part has exited the zone, we track it for a brief period of time based upon the criteria\n\t\t\t\t\t-- in the line above to ensure the .touched behaviours are not abused\n\t\t\t\t\tpartJanitor:cleanup()\n\t\t\t\tend\n\t\t\telseif not withinZone then\n\t\t\t\tverifiedEntrance = false\n\t\t\t\tenterPosition = part.Position\n\t\t\t\tenterTime = os.clock()\n\t\t\t\tself.partExited:Fire(part)\n\t\t\tend\n\t\tend\n\tend), \"Disconnect\")\n\tpartJanitor:add(function()\n\t\ttrackingDict[part] = nil\n\t\tpart.CanTouch = true\n\t\tself.totalPartVolume = round((self.totalPartVolume - partVolume), 5)\n\tend, true)\nend\n\nlocal partShapeActions = {\n\t[\"Ball\"] = function(part)\n\t\treturn \"GetPartBoundsInRadius\", {part.Position, part.Size.X}\n\tend,\n\t[\"Block\"] = function(part)\n\t\treturn \"GetPartBoundsInBox\", {part.CFrame, part.Size}\n\tend,\n\t[\"Other\"] = function(part)\n\t\treturn \"GetPartsInPart\", {part}\n\tend,\n}\nfunction Zone:_getRegionConstructor(part, overlapParams)\n\tlocal success, shapeName = pcall(function() return part.Shape.Name end)\n\tlocal methodName, args\n\tif success and self.allZonePartsAreBlocks then\n\t\tlocal action = partShapeActions[shapeName]\n\t\tif action then\n\t\t\tmethodName, args = action(part)\n\t\tend\n\tend\n\tif not methodName then\n\t\tmethodName, args = partShapeActions.Other(part)\n\tend\n\tif overlapParams then\n\t\ttable.insert(args, overlapParams)\n\tend\n\treturn methodName, args\nend\n\n\n\n-- PUBLIC METHODS\nfunction Zone:findLocalPlayer()\n\tif not localPlayer then\n\t\terror(\"Can only call 'findLocalPlayer' on the client!\")\n\tend\n\treturn self:findPlayer(localPlayer)\nend\n\nfunction Zone:_find(trackerName, item)\n\tZoneController.updateDetection(self)\n\tlocal tracker = ZoneController.trackers[trackerName]\n\tlocal touchingZones = ZoneController.getTouchingZones(item, false, self._currentEnterDetection, tracker)\n\tfor _, zone in pairs(touchingZones) do\n\t\tif zone == self then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nfunction Zone:findPlayer(player)\n\tlocal character = player.Character\n\tlocal humanoid = character and character:FindFirstChildOfClass(\"Humanoid\")\n\tif not humanoid then\n\t\treturn false\n\tend\n\treturn self:_find(\"player\", player.Character)\nend\n\nfunction Zone:findItem(item)\n\treturn self:_find(\"item\", item)\nend\n\nfunction Zone:findPart(part)\n\tlocal methodName, args = self:_getRegionConstructor(part, self.overlapParams.zonePartsWhitelist)\n\tlocal touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))\n\t--local touchingZoneParts = self.worldModel:GetPartsInPart(part, self.overlapParams.zonePartsWhitelist)\n\tif #touchingZoneParts > 0 then\n\t\treturn true, touchingZoneParts\n\tend\n\treturn false\nend\n\nfunction Zone:getCheckerPart()\n\tlocal checkerPart = self.checkerPart\n\tif not checkerPart then\n\t\tcheckerPart = self.janitor:add(Instance.new(\"Part\"), \"Destroy\")\n\t\tcheckerPart.Size = Vector3.new(0.1, 0.1, 0.1)\n\t\tcheckerPart.Name = \"ZonePlusCheckerPart\"\n\t\tcheckerPart.Anchored = true\n\t\tcheckerPart.Transparency = 1\n\t\tcheckerPart.CanCollide = false\n\t\tself.checkerPart = checkerPart\n\tend\n\tlocal checkerParent = self.worldModel\n\tif checkerParent == workspace then\n\t\tcheckerParent = ZoneController.getWorkspaceContainer()\n\tend\n\tif checkerPart.Parent ~= checkerParent then\n\t\tcheckerPart.Parent = checkerParent\n\tend\n\treturn checkerPart\nend\n\nfunction Zone:findPoint(positionOrCFrame)\n\tlocal cframe = positionOrCFrame\n\tif typeof(positionOrCFrame) == \"Vector3\" then\n\t\tcframe = CFrame.new(positionOrCFrame)\n\tend\n\tlocal checkerPart = self:getCheckerPart()\n\tcheckerPart.CFrame = cframe\n\t--checkerPart.Parent = self.worldModel\n\tlocal methodName, args = self:_getRegionConstructor(checkerPart, self.overlapParams.zonePartsWhitelist)\n\tlocal touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))\n\t--local touchingZoneParts = self.worldModel:GetPartsInPart(self.checkerPart, self.overlapParams.zonePartsWhitelist)\n\tif #touchingZoneParts > 0 then\n\t\treturn true, touchingZoneParts\n\tend\n\treturn false\nend\n\nfunction Zone:_getAll(trackerName)\n\tZoneController.updateDetection(self)\n\tlocal itemsArray = {}\n\tlocal zonesAndOccupants = ZoneController._getZonesAndItems(trackerName, {self = true}, self.volume, false, self._currentEnterDetection)\n\tlocal occupantsDict = zonesAndOccupants[self]\n\tif occupantsDict then\n\t\tfor item, _ in pairs(occupantsDict) do\n\t\t\ttable.insert(itemsArray, item)\n\t\tend\n\tend\n\treturn itemsArray\nend\n\nfunction Zone:getPlayers()\n\treturn self:_getAll(\"player\")\nend\n\nfunction Zone:getItems()\n\treturn self:_getAll(\"item\")\nend\n\nfunction Zone:getParts()\n\t-- This is designed for infrequent 'one off' use\n\t-- If you plan on checking for parts within a zone frequently, it's recommended you\n\t-- use the .partEntered and .partExited events instead.\n\tlocal partsArray = {}\n\tif self.activeTriggers[\"part\"] then\n\t\tlocal trackingDict = self.trackingTouchedTriggers[\"part\"]\n\t\tfor part, _ in pairs(trackingDict) do\n\t\t\ttable.insert(partsArray, part)\n\t\tend\n\t\treturn partsArray\n\tend\n\tlocal partsInRegion = self.worldModel:GetPartBoundsInBox(self.region.CFrame, self.region.Size, self.overlapParams.zonePartsIgnorelist)\n\tfor _, part in pairs(partsInRegion) do\n\t\tif self:findPart(part) then\n\t\t\ttable.insert(partsArray, part)\n\t\tend\n\tend\n\treturn partsArray\nend\n\nfunction Zone:getRandomPoint()\n\tlocal region = self.exactRegion\n\tlocal size = region.Size\n\tlocal cframe = region.CFrame\n\tlocal random = Random.new()\n\tlocal randomCFrame\n\tlocal success, touchingZoneParts\n\tlocal pointIsWithinZone\n\trepeat\n\t\trandomCFrame = cframe * CFrame.new(random:NextNumber(-size.X/2,size.X/2), random:NextNumber(-size.Y/2,size.Y/2), random:NextNumber(-size.Z/2,size.Z/2))\n\t\tsuccess, touchingZoneParts = self:findPoint(randomCFrame)\n\t\tif success then\n\t\t\tpointIsWithinZone = true\n\t\tend\n\tuntil pointIsWithinZone\n\tlocal randomVector = randomCFrame.Position\n\treturn randomVector, touchingZoneParts\nend\n\nfunction Zone:setAccuracy(enumIdOrName)\n\tlocal enumId = tonumber(enumIdOrName)\n\tif not enumId then\n\t\tenumId = enum.Accuracy[enumIdOrName]\n\t\tif not enumId then\n\t\t\terror((\"'%s' is an invalid enumName!\"):format(enumIdOrName))\n\t\tend\n\telse\n\t\tlocal enumName = enum.Accuracy.getName(enumId)\n\t\tif not enumName then\n\t\t\terror((\"%s is an invalid enumId!\"):format(enumId))\n\t\tend\n\tend\n\tself.accuracy = enumId\nend\n\nfunction Zone:setDetection(enumIdOrName)\n\tlocal enumId = tonumber(enumIdOrName)\n\tif not enumId then\n\t\tenumId = enum.Detection[enumIdOrName]\n\t\tif not enumId then\n\t\t\terror((\"'%s' is an invalid enumName!\"):format(enumIdOrName))\n\t\tend\n\telse\n\t\tlocal enumName = enum.Detection.getName(enumId)\n\t\tif not enumName then\n\t\t\terror((\"%s is an invalid enumId!\"):format(enumId))\n\t\tend\n\tend\n\tself.enterDetection = enumId\n\tself.exitDetection = enumId\nend\n\nfunction Zone:trackItem(instance)\n\tlocal isBasePart = instance:IsA(\"BasePart\")\n\tlocal isCharacter = false\n\tif not isBasePart then\n\t\tisCharacter = instance:FindFirstChildOfClass(\"Humanoid\") and instance:FindFirstChild(\"HumanoidRootPart\")\n\tend\n\n\tassert(isBasePart or isCharacter, \"Only BaseParts or Characters/NPCs can be tracked!\")\n\n\tif self.trackedItems[instance] then\n\t\treturn\n\tend\n\tif self.itemsToUntrack[instance] then\n\t\tself.itemsToUntrack[instance] = nil\n\tend\n\n\tlocal itemJanitor = self.janitor:add(Janitor.new(), \"destroy\")\n\tlocal itemDetail = {\n\t\tjanitor = itemJanitor,\n\t\titem = instance,\n\t\tisBasePart = isBasePart,\n\t\tisCharacter = isCharacter,\n\t}\n\tself.trackedItems[instance] = itemDetail\n\n\titemJanitor:add(instance.AncestryChanged:Connect(function()\n\t\tif not instance:IsDescendantOf(game) then\n\t\t\tself:untrackItem(instance)\n\t\tend\n\tend), \"Disconnect\")\n\n\tlocal Tracker = require(trackerModule)\n\tTracker.itemAdded:Fire(itemDetail)\nend\n\nfunction Zone:untrackItem(instance)\n\tlocal itemDetail = self.trackedItems[instance]\n\tif itemDetail then\n\t\titemDetail.janitor:destroy()\n\tend\n\tself.trackedItems[instance] = nil\n\n\tlocal Tracker = require(trackerModule)\n\tTracker.itemRemoved:Fire(itemDetail)\nend\n\nfunction Zone:bindToGroup(settingsGroupName)\n\tself:unbindFromGroup()\n\tlocal group = ZoneController.getGroup(settingsGroupName) or ZoneController.setGroup(settingsGroupName)\n\tgroup._memberZones[self.zoneId] = self\n\tself.settingsGroupName = settingsGroupName\nend\n\nfunction Zone:unbindFromGroup()\n\tif self.settingsGroupName then\n\t\tlocal group = ZoneController.getGroup(self.settingsGroupName)\n\t\tif group then\n\t\t\tgroup._memberZones[self.zoneId] = nil\n\t\tend\n\t\tself.settingsGroupName = nil\n\tend\nend\n\nfunction Zone:relocate()\n\tif self.hasRelocated then\n\t\treturn\n\tend\n\n\tlocal CollectiveWorldModel = require(collectiveWorldModelModule)\n\tlocal worldModel = CollectiveWorldModel.setupWorldModel(self)\n\tself.worldModel = worldModel\n\tself.hasRelocated = true\n\t\n\tlocal relocationContainer = self.container\n\tif typeof(relocationContainer) == \"table\" then\n\t\trelocationContainer = Instance.new(\"Folder\")\n\t\tfor _, zonePart in pairs(self.zoneParts) do\n\t\t\tzonePart.Parent = relocationContainer\n\t\tend\n\tend\n\tself.relocationContainer = self.janitor:add(relocationContainer, \"Destroy\", \"RelocationContainer\")\n\trelocationContainer.Parent = worldModel\nend\n\nfunction Zone:_onItemCallback(eventName, desiredValue, instance, callbackFunction)\n\tlocal detail = self.onItemDetails[instance]\n\tif not detail then\n\t\tdetail = {}\n\t\tself.onItemDetails[instance] = detail\n\tend\n\tif #detail == 0 then\n\t\tself.itemsToUntrack[instance] = true\n\tend\n\ttable.insert(detail, instance)\n\tself:trackItem(instance)\n\n\tlocal function triggerCallback()\n\t\tcallbackFunction()\n\t\tif self.itemsToUntrack[instance] then\n\t\t\tself.itemsToUntrack[instance] = nil\n\t\t\tself:untrackItem(instance)\n\t\tend\n\tend\n\n\tlocal inZoneAlready = self:findItem(instance)\n\tif inZoneAlready == desiredValue then\n\t\ttriggerCallback()\n\telse\n\t\tlocal connection\n\t\tconnection = self[eventName]:Connect(function(item)\n\t\t\tif connection and item == instance then\n\t\t\t\tconnection:Disconnect()\n\t\t\t\tconnection = nil\n\t\t\t\ttriggerCallback()\n\t\t\tend\n\t\tend)\n\t\t--[[\n\t\tif typeof(expireAfterSeconds) == \"number\" then\n\t\t\ttask.delay(expireAfterSeconds, function()\n\t\t\t\tif connection ~= nil then\n\t\t\t\t\tprint(\"EXPIRE!\")\n\t\t\t\t\tconnection:Disconnect()\n\t\t\t\t\tconnection = nil\n\t\t\t\t\ttriggerCallback()\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\t\t--]]\n\tend\nend\n\nfunction Zone:onItemEnter(...)\n\tself:_onItemCallback(\"itemEntered\", true, ...)\nend\n\nfunction Zone:onItemExit(...)\n\tself:_onItemCallback(\"itemExited\", false, ...)\nend\n\nfunction Zone:destroy()\n\tself:unbindFromGroup()\n\tself.janitor:destroy()\nend\nZone.Destroy = Zone.destroy\n\n\n\nreturn Zone",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: Zone)>"
}