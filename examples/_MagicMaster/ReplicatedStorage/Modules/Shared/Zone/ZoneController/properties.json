{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: ZoneController)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: ZoneController)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: ZoneController)>",
  "Sandboxed": false,
  "ScriptGuid": "{2F3C1844-C4D8-4A76-8975-22381CC35A03}",
  "Source": "-- CONFIG\nlocal WHOLE_BODY_DETECTION_LIMIT = 729000 -- This is roughly the volume where Region3 checks begin to exceed 0.5% in Script Performance\n\n\n\n-- LOCAL\nlocal Janitor = require(script.Parent.Janitor)\nlocal Enum_ = require(script.Parent.Enum)\nlocal Signal = require(script.Parent.Signal)\nlocal Tracker = require(script.Tracker)\nlocal CollectiveWorldModel = require(script.CollectiveWorldModel)\nlocal enum = Enum_.enums\nlocal players = game:GetService(\"Players\")\nlocal activeZones = {}\nlocal activeZonesTotalVolume = 0\nlocal activeTriggers = {}\nlocal registeredZones = {}\nlocal activeParts = {}\nlocal activePartToZone = {}\nlocal allParts = {}\nlocal allPartToZone = {}\nlocal activeConnections = 0\nlocal runService = game:GetService(\"RunService\")\nlocal heartbeat = runService.Heartbeat\nlocal heartbeatConnections = {}\nlocal localPlayer = runService:IsClient() and players.LocalPlayer\n\n\n\n-- PUBLIC\nlocal ZoneController = {}\nlocal trackers = {}\ntrackers.player = Tracker.new(\"player\")\ntrackers.item = Tracker.new(\"item\")\nZoneController.trackers = trackers\n\n\n\n-- LOCAL FUNCTIONS\nlocal function dictLength(dictionary)\n\tlocal count = 0\n\tfor _, _ in pairs(dictionary) do\n\t\tcount += 1\n\tend\n\treturn count\nend\n\nlocal function fillOccupants(zonesAndOccupantsTable, zone, occupant)\n\tlocal occupantsDict = zonesAndOccupantsTable[zone]\n\tif not occupantsDict then\n\t\toccupantsDict = {}\n\t\tzonesAndOccupantsTable[zone] = occupantsDict\n\tend\n\tlocal prevCharacter = occupant:IsA(\"Player\") and occupant.Character\n\toccupantsDict[occupant] = (prevCharacter or true)\nend\n\nlocal heartbeatActions = {\n\t[\"player\"] = function(recommendedDetection)\n\t\treturn ZoneController._getZonesAndItems(\"player\", activeZones, activeZonesTotalVolume, true, recommendedDetection)\n\tend,\n\t[\"localPlayer\"] = function(recommendedDetection)\n\t\tlocal zonesAndOccupants = {}\n\t\tlocal character = localPlayer.Character\n\t\tif not character then\n\t\t\treturn zonesAndOccupants\n\t\tend\n\t\tlocal touchingZones = ZoneController.getTouchingZones(character, true, recommendedDetection, trackers.player)\n\t\tfor _, zone in pairs(touchingZones) do\n\t\t\tif zone.activeTriggers[\"localPlayer\"] then\n\t\t\t\tfillOccupants(zonesAndOccupants, zone, localPlayer)\n\t\t\tend\n\t\tend\n\t\treturn zonesAndOccupants\n\tend,\n\t[\"item\"] = function(recommendedDetection)\n\t\treturn ZoneController._getZonesAndItems(\"item\", activeZones, activeZonesTotalVolume, true, recommendedDetection)\n\tend,\n}\n\n\n\n-- PRIVATE FUNCTIONS\nfunction ZoneController._registerZone(zone)\n   \tregisteredZones[zone] = true\n\tlocal registeredJanitor = zone.janitor:add(Janitor.new(), \"destroy\")\n\tzone._registeredJanitor = registeredJanitor\n\tregisteredJanitor:add(zone.updated:Connect(function()\n\t\tZoneController._updateZoneDetails()\n\tend), \"Disconnect\")\n   ZoneController._updateZoneDetails()\nend\n\nfunction ZoneController._deregisterZone(zone)\n\tregisteredZones[zone] = nil\n\tzone._registeredJanitor:destroy()\n\tzone._registeredJanitor = nil\n\tZoneController._updateZoneDetails()\nend\n\nfunction ZoneController._registerConnection(registeredZone, registeredTriggerType)\n\tlocal originalItems = dictLength(registeredZone.activeTriggers)\n\tactiveConnections += 1\n\tif originalItems == 0 then\n\t\tactiveZones[registeredZone] = true\n\t\tZoneController._updateZoneDetails()\n\tend\n\tlocal currentTriggerCount = activeTriggers[registeredTriggerType]\n\tactiveTriggers[registeredTriggerType] = (currentTriggerCount and currentTriggerCount+1) or 1\n\tregisteredZone.activeTriggers[registeredTriggerType] = true\n\tif registeredZone.touchedConnectionActions[registeredTriggerType] then\n\t\tregisteredZone:_formTouchedConnection(registeredTriggerType)\n\tend\n\tif heartbeatActions[registeredTriggerType] then\n\t\tZoneController._formHeartbeat(registeredTriggerType)\n\tend\nend\n\n-- This decides what to do if detection is 'Automatic'\n-- This is placed in ZoneController instead of the Zone object due to the ZoneControllers all-knowing group-minded logic\nfunction ZoneController.updateDetection(zone)\n\tlocal detectionTypes = {\n\t\t[\"enterDetection\"] = \"_currentEnterDetection\",\n\t\t[\"exitDetection\"] = \"_currentExitDetection\",\n\t}\n\tfor detectionType, currentDetectionName in pairs(detectionTypes) do\n\t\tlocal detection = zone[detectionType]\n\t\tlocal combinedTotalVolume = Tracker.getCombinedTotalVolumes()\n\t\tif detection == enum.Detection.Automatic then\n\t\t\tif combinedTotalVolume > WHOLE_BODY_DETECTION_LIMIT then\n\t\t\t\tdetection = enum.Detection.Centre\n\t\t\telse\n\t\t\t\tdetection = enum.Detection.WholeBody\n\t\t\tend\n\t\tend\n\t\tzone[currentDetectionName] = detection\n\tend\nend\n\nfunction ZoneController._formHeartbeat(registeredTriggerType)\n\tlocal heartbeatConnection = heartbeatConnections[registeredTriggerType]\n\tif heartbeatConnection then return end\n\t-- This will only ever connect once per triggerType per server\n\t-- This means instead of initiating a loop per-zone we can handle everything within\n\t-- a singular connection. This is particularly beneficial for player/item-orinetated\n\t-- checking, where a check only needs to be cast once per interval, as apposed\n\t-- to every zone per interval\n\t-- I utilise heartbeat with os.clock() to provide precision (where needed) and flexibility\n\tlocal nextCheck = 0\n\theartbeatConnection = heartbeat:Connect(function()\n\t\tlocal clockTime = os.clock()\n\t\tif clockTime >= nextCheck then\n\t\t\tlocal lowestAccuracy\n\t\t\tlocal lowestDetection\n\t\t\tfor zone, _ in pairs(activeZones) do\n\t\t\t\tif zone.activeTriggers[registeredTriggerType] then\n\t\t\t\t\tlocal zAccuracy = zone.accuracy\n\t\t\t\t\tif lowestAccuracy == nil or zAccuracy < lowestAccuracy then\n\t\t\t\t\t\tlowestAccuracy = zAccuracy\n\t\t\t\t\tend\n\t\t\t\t\tZoneController.updateDetection(zone)\n\t\t\t\t\tlocal zDetection = zone._currentEnterDetection\n\t\t\t\t\tif lowestDetection == nil or zDetection < lowestDetection then\n\t\t\t\t\t\tlowestDetection = zDetection\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal highestAccuracy = lowestAccuracy\n\t\t\tlocal zonesAndOccupants = heartbeatActions[registeredTriggerType](lowestDetection)\n\n\t\t\t-- If a zone belongs to a settingsGroup with 'onlyEnterOnceExitedAll = true' , and the occupant already exists in a member group, then\n\t\t\t-- ignore all incoming occupants for the other zones (preventing the enteredSignal from being fired until the occupant has left\n\t\t\t-- all other zones within the same settingGroup)\n\t\t\tlocal occupantsToBlock = {}\n\t\t\tlocal zonesToPotentiallyIgnore = {}\n\t\t\tfor zone, newOccupants in pairs(zonesAndOccupants) do\n\t\t\t\tlocal settingsGroup = (zone.settingsGroupName and ZoneController.getGroup(zone.settingsGroupName))\n\t\t\t\tif settingsGroup and settingsGroup.onlyEnterOnceExitedAll == true then\n\t\t\t\t\t--local currentOccupants = zone.occupants[registeredTriggerType]\n\t\t\t\t\t--if currentOccupants then\n\t\t\t\t\t\tfor newOccupant, _ in pairs(newOccupants) do\n\t\t\t\t\t\t\t--if currentOccupants[newOccupant] then\n\t\t\t\t\t\t\t\tlocal groupDetail = occupantsToBlock[zone.settingsGroupName]\n\t\t\t\t\t\t\t\tif not groupDetail then\n\t\t\t\t\t\t\t\t\tgroupDetail = {}\n\t\t\t\t\t\t\t\t\toccupantsToBlock[zone.settingsGroupName] = groupDetail\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tgroupDetail[newOccupant] = zone\n\t\t\t\t\t\t\t--end\n\t\t\t\t\t\tend\n\t\t\t\t\t\tzonesToPotentiallyIgnore[zone] = newOccupants\n\t\t\t\t\t--end\n\t\t\t\tend\n\t\t\tend\n\t\t\tfor zone, newOccupants in pairs(zonesToPotentiallyIgnore) do\n\t\t\t\tlocal groupDetail = occupantsToBlock[zone.settingsGroupName]\n\t\t\t\tif groupDetail then\n\t\t\t\t\tfor newOccupant, _ in pairs(newOccupants) do\n\t\t\t\t\t\tlocal occupantToKeepZone = groupDetail[newOccupant]\n\t\t\t\t\t\tif occupantToKeepZone and occupantToKeepZone ~= zone then\n\t\t\t\t\t\t\tnewOccupants[newOccupant] = nil\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- This deduces what signals should be fired\n\t\t\tlocal collectiveSignalsToFire = {{}, {}}\n\t\t\tfor zone, _ in pairs(activeZones) do\n\t\t\t\tif zone.activeTriggers[registeredTriggerType] then\n\t\t\t\t\tlocal zAccuracy = zone.accuracy\n\t\t\t\t\tlocal occupantsDict = zonesAndOccupants[zone] or {}\n\t\t\t\t\tlocal occupantsPresent = false\n\t\t\t\t\tfor k,v in pairs(occupantsDict) do\n\t\t\t\t\t\toccupantsPresent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tif occupantsPresent and zAccuracy > highestAccuracy then\n\t\t\t\t\t\thighestAccuracy = zAccuracy\n\t\t\t\t\tend\n\t\t\t\t\tlocal signalsToFire = zone:_updateOccupants(registeredTriggerType, occupantsDict)\n\t\t\t\t\tcollectiveSignalsToFire[1][zone] = signalsToFire.exited\n\t\t\t\t\tcollectiveSignalsToFire[2][zone] = signalsToFire.entered\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- This ensures all exited signals and called before entered signals\n\t\t\tlocal indexToSignalType = {\"Exited\", \"Entered\"}\n\t\t\tfor index, zoneAndOccupants in pairs(collectiveSignalsToFire) do\n\t\t\t\tlocal signalType = indexToSignalType[index]\n\t\t\t\tlocal signalName = registeredTriggerType..signalType\n\t\t\t\tfor zone, occupants in pairs(zoneAndOccupants) do\n\t\t\t\t\tlocal signal = zone[signalName]\n\t\t\t\t\tif signal then\n\t\t\t\t\t\tfor _, occupant in pairs(occupants) do\n\t\t\t\t\t\t\tsignal:Fire(occupant)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal cooldown = enum.Accuracy.getProperty(highestAccuracy)\n\t\t\tnextCheck = clockTime + cooldown\n\t\tend\n\tend)\n\theartbeatConnections[registeredTriggerType] = heartbeatConnection\nend\n\nfunction ZoneController._deregisterConnection(registeredZone, registeredTriggerType)\n\tactiveConnections -= 1\n\tif activeTriggers[registeredTriggerType] == 1 then\n\t\tactiveTriggers[registeredTriggerType] = nil\n\t\tlocal heartbeatConnection = heartbeatConnections[registeredTriggerType]\n\t\tif heartbeatConnection then\n\t\t\theartbeatConnections[registeredTriggerType] = nil\n\t\t\theartbeatConnection:Disconnect()\n\t\tend\n\telse\n\t\tactiveTriggers[registeredTriggerType] -= 1\n\tend\n\tregisteredZone.activeTriggers[registeredTriggerType] = nil\n\tif dictLength(registeredZone.activeTriggers) == 0 then\n\t\tactiveZones[registeredZone] = nil\n\t\tZoneController._updateZoneDetails()\n\tend\n\tif registeredZone.touchedConnectionActions[registeredTriggerType] then\n\t\tregisteredZone:_disconnectTouchedConnection(registeredTriggerType)\n\tend\nend\n\nfunction ZoneController._updateZoneDetails()\n\tactiveParts = {}\n\tactivePartToZone = {}\n\tallParts = {}\n\tallPartToZone = {}\n\tactiveZonesTotalVolume = 0\n\tfor zone, _ in pairs(registeredZones) do\n\t\tlocal isActive = activeZones[zone]\n\t\tif isActive then\n\t\t\tactiveZonesTotalVolume += zone.volume\n\t\tend\n\t\tfor _, zonePart in pairs(zone.zoneParts) do\n\t\t\tif isActive then\n\t\t\t\ttable.insert(activeParts, zonePart)\n\t\t\t\tactivePartToZone[zonePart] = zone\n\t\t\tend\n\t\t\ttable.insert(allParts, zonePart)\n\t\t\tallPartToZone[zonePart] = zone\n\t\tend\n\tend\nend\n\nfunction ZoneController._getZonesAndItems(trackerName, zonesDictToCheck, zoneCustomVolume, onlyActiveZones, recommendedDetection)\n\tlocal totalZoneVolume = zoneCustomVolume\n\tif not totalZoneVolume then\n\t\tfor zone, _ in pairs(zonesDictToCheck) do\n\t\t\ttotalZoneVolume += zone.volume\n\t\tend\n\tend\n\tlocal zonesAndOccupants = {}\n\tlocal tracker = trackers[trackerName]\n\tif tracker.totalVolume < totalZoneVolume then\n\t\t-- If the volume of all *characters/items* within the server is *less than* the total\n\t\t-- volume of all active zones (i.e. zones which listen for .playerEntered)\n\t\t-- then it's more efficient cast checks within each character and\n\t\t-- then determine the zones they belong to\n\t\tfor _, item in pairs(tracker.items) do\n\t\t\tlocal touchingZones = ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)\n\t\t\tfor _, zone in pairs(touchingZones) do\n\t\t\t\tif not onlyActiveZones or zone.activeTriggers[trackerName] then\n\t\t\t\t\tlocal finalItem = item\n\t\t\t\t\tif trackerName == \"player\" then\n\t\t\t\t\t\tfinalItem = players:GetPlayerFromCharacter(item)\n\t\t\t\t\tend\n\t\t\t\t\tif finalItem then\n\t\t\t\t\t\tfillOccupants(zonesAndOccupants, zone, finalItem)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\telse\n\t\t-- If the volume of all *active zones* within the server is *less than* the total\n\t\t-- volume of all characters/items, then it's more efficient to perform the\n\t\t-- checks directly within each zone to determine players inside\n\t\tfor zone, _ in pairs(zonesDictToCheck) do\n\t\t\tif not onlyActiveZones or zone.activeTriggers[trackerName] then\n\t\t\t\tlocal result = CollectiveWorldModel:GetPartBoundsInBox(zone.region.CFrame, zone.region.Size, tracker.whitelistParams)\n\t\t\t\tlocal finalItemsDict = {}\n\t\t\t\tfor _, itemOrChild in pairs(result) do\n\t\t\t\t\tlocal correspondingItem = tracker.partToItem[itemOrChild]\n\t\t\t\t\tif not finalItemsDict[correspondingItem] then\n\t\t\t\t\t\tfinalItemsDict[correspondingItem] = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfor item, _ in pairs(finalItemsDict) do\n\t\t\t\t\tif trackerName == \"player\" then\n\t\t\t\t\t\tlocal player = players:GetPlayerFromCharacter(item)\n\t\t\t\t\t\tif zone:findPlayer(player) then\n\t\t\t\t\t\t\tfillOccupants(zonesAndOccupants, zone, player)\n\t\t\t\t\t\tend\n\t\t\t\t\telseif zone:findItem(item) then\n\t\t\t\t\t\tfillOccupants(zonesAndOccupants, zone, item)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn zonesAndOccupants\nend\n\n\n\n-- PUBLIC FUNCTIONS\nfunction ZoneController.getZones()\n\tlocal registeredZonesArray = {}\n\tfor zone, _ in pairs(registeredZones) do\n\t\ttable.insert(registeredZonesArray, zone)\n\tend\n\treturn registeredZonesArray\nend\n\n--[[\n-- the player touched events which utilise active zones at the moment may change to the new CanTouch method for parts in the future\n-- hence im disabling this as it may be depreciated quite soon\nfunction ZoneController.getActiveZones()\n\tlocal zonesArray = {}\n\tfor zone, _ in pairs(activeZones) do\n\t\ttable.insert(zonesArray, zone)\n\tend\n\treturn zonesArray\nend\n--]]\n\nfunction ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)\n\tlocal exitDetection, finalDetection\n\tif tracker then\n\t\texitDetection = tracker.exitDetections[item]\n\t\ttracker.exitDetections[item] = nil\n\tend\n\tfinalDetection = exitDetection or recommendedDetection\n\n\tlocal itemSize, itemCFrame\n\tlocal itemIsBasePart = item:IsA(\"BasePart\")\n\tlocal itemIsCharacter = not itemIsBasePart\n\tlocal bodyPartsToCheck = {}\n\tif itemIsBasePart then\n\t\titemSize, itemCFrame = item.Size, item.CFrame\n\t\ttable.insert(bodyPartsToCheck, item)\n\telseif finalDetection == enum.Detection.WholeBody then\n\t\titemSize, itemCFrame = Tracker.getCharacterSize(item)\n\t\tbodyPartsToCheck = item:GetChildren()\n\telse\n\t\tlocal hrp = item:FindFirstChild(\"HumanoidRootPart\")\n\t\tif hrp then\n\t\t\titemSize, itemCFrame = hrp.Size, hrp.CFrame\n\t\t\ttable.insert(bodyPartsToCheck, hrp)\n\t\tend\n\tend\n\tif not itemSize or not itemCFrame then return {} end\n\n\t--[[\n\tlocal part = Instance.new(\"Part\")\n\tpart.Size = itemSize\n\tpart.CFrame = itemCFrame\n\tpart.Anchored = true\n\tpart.CanCollide = false\n\tpart.Color = Color3.fromRGB(255, 0, 0)\n\tpart.Transparency = 0.4\n\tpart.Parent = workspace\n\tgame:GetService(\"Debris\"):AddItem(part, 2)\n\t--]]\n\tlocal partsTable = (onlyActiveZones and activeParts) or allParts\n\tlocal partToZoneDict = (onlyActiveZones and activePartToZone) or allPartToZone\n\n\tlocal boundParams = OverlapParams.new()\n\tboundParams.FilterType = Enum.RaycastFilterType.Whitelist\n\tboundParams.MaxParts = #partsTable\n\tboundParams.FilterDescendantsInstances = partsTable\n\n\t-- This retrieves the bounds (the rough shape) of all parts touching the item/character\n\t-- If the corresponding zone is made up of *entirely* blocks then the bound will\n\t-- be the actual shape of the part.\n\tlocal touchingPartsDictionary = {}\n\tlocal zonesDict = {}\n\tlocal boundParts = CollectiveWorldModel:GetPartBoundsInBox(itemCFrame, itemSize, boundParams)\n\tlocal boundPartsThatRequirePreciseChecks = {}\n\tfor _, boundPart in pairs(boundParts) do\n\t\tlocal correspondingZone = partToZoneDict[boundPart]\n\t\tif correspondingZone and correspondingZone.allZonePartsAreBlocks then\n\t\t\tzonesDict[correspondingZone] = true\n\t\t\ttouchingPartsDictionary[boundPart] = correspondingZone\n\t\telse\n\t\t\ttable.insert(boundPartsThatRequirePreciseChecks, boundPart)\n\t\tend\n\tend\n\n\t-- If the bound parts belong to a zone that isn't entirely made up of blocks, then\n\t-- we peform additional checks using GetPartsInPart which enables shape\n\t-- geometries to be precisely determined for non-block baseparts.\n\tlocal totalRemainingBoundParts = #boundPartsThatRequirePreciseChecks\n\tlocal precisePartsCount = 0\n\tif totalRemainingBoundParts > 0 then\n\t\t\n\t\tlocal preciseParams = OverlapParams.new()\n\t\tpreciseParams.FilterType = Enum.RaycastFilterType.Whitelist\n\t\tpreciseParams.MaxParts = totalRemainingBoundParts\n\t\tpreciseParams.FilterDescendantsInstances = boundPartsThatRequirePreciseChecks\n\n\t\tlocal character = item\n\t\tfor _, bodyPart in pairs(bodyPartsToCheck) do\n\t\t\tlocal endCheck = false\n\t\t\tif not bodyPart:IsA(\"BasePart\") or (itemIsCharacter and Tracker.bodyPartsToIgnore[bodyPart.Name]) then\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\tlocal preciseParts = CollectiveWorldModel:GetPartsInPart(bodyPart, preciseParams)\n\t\t\tfor _, precisePart in pairs(preciseParts) do\n\t\t\t\tif not touchingPartsDictionary[precisePart] then\n\t\t\t\t\tlocal correspondingZone = partToZoneDict[precisePart]\n\t\t\t\t\tif correspondingZone then\n\t\t\t\t\t\tzonesDict[correspondingZone] = true\n\t\t\t\t\t\ttouchingPartsDictionary[precisePart] = correspondingZone\n\t\t\t\t\t\tprecisePartsCount += 1\n\t\t\t\t\tend\n\t\t\t\t\tif precisePartsCount == totalRemainingBoundParts then\n\t\t\t\t\t\tendCheck = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif endCheck then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\tlocal touchingZonesArray = {}\n\tlocal newExitDetection\n\tfor zone, _ in pairs(zonesDict) do\n\t\tif newExitDetection == nil or zone._currentExitDetection < newExitDetection then\n\t\t\tnewExitDetection = zone._currentExitDetection\n\t\tend\n\t\ttable.insert(touchingZonesArray, zone)\n\tend\n\tif newExitDetection and tracker then\n\t\ttracker.exitDetections[item] = newExitDetection\n\tend\n\treturn touchingZonesArray, touchingPartsDictionary\nend\n\nlocal settingsGroups = {}\nfunction ZoneController.setGroup(settingsGroupName, properties)\n\tlocal group = settingsGroups[settingsGroupName]\n\tif not group then\n\t\tgroup = {}\n\t\tsettingsGroups[settingsGroupName] = group\n\tend\n\t\n\n\t-- PUBLIC PROPERTIES --\n\tgroup.onlyEnterOnceExitedAll = true\n\t\n\t-- PRIVATE PROPERTIES --\n\tgroup._name = settingsGroupName\n\tgroup._memberZones = {}\n\n\n\tif typeof(properties) == \"table\" then\n\t\tfor k, v in pairs(properties) do\n\t\t\tgroup[k] = v\n\t\tend\n\tend\n\treturn group\nend\n\nfunction ZoneController.getGroup(settingsGroupName)\n\treturn settingsGroups[settingsGroupName]\nend\n\nlocal workspaceContainer\nlocal workspaceContainerName = string.format(\"ZonePlus%sContainer\", (runService:IsClient() and \"Client\") or \"Server\")\nfunction ZoneController.getWorkspaceContainer()\n\tlocal container = workspaceContainer or workspace:FindFirstChild(workspaceContainerName)\n\tif not container then\n\t\tcontainer = Instance.new(\"Folder\")\n\t\tcontainer.Name = workspaceContainerName\n\t\tcontainer.Parent = workspace\n\t\tworkspaceContainer = container\n\tend\n\treturn container\nend\n\n\n\nreturn ZoneController",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: ZoneController)>"
}