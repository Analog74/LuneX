{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: Tracker)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: Tracker)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: Tracker)>",
  "Sandboxed": false,
  "ScriptGuid": "{3AC1F29A-E37B-40A1-9B91-69451068C5B6}",
  "Source": "-- This enables data on volumes, HumanoidRootParts, etc to be handled on an event-basis, instead of being retrieved every interval\n\n-- LOCAL\nlocal players = game:GetService(\"Players\")\nlocal runService = game:GetService(\"RunService\")\nlocal heartbeat = runService.Heartbeat\nlocal Signal = require(script.Parent.Parent.Signal)\nlocal Janitor = require(script.Parent.Parent.Janitor)\n\n\n\n-- PUBLIC\nlocal Tracker = {}\nTracker.__index = Tracker\nlocal trackers = {}\nTracker.trackers = trackers\nTracker.itemAdded = Signal.new()\nTracker.itemRemoved = Signal.new()\nTracker.bodyPartsToIgnore = {\n\t-- We ignore these due to their insignificance (e.g. we ignore the lower and\n\t-- upper torso because the HumanoidRootPart also covers these areas)\n\t-- This ultimately reduces the burden on the player region checks\n\tUpperTorso = true,\n\tLowerTorso = true,\n\tTorso = true,\n\tLeftHand = true,\n\tRightHand = true,\n\tLeftFoot = true,\n\tRightFoot = true,\n}\n\n\n\n-- FUNCTIONS\nfunction Tracker.getCombinedTotalVolumes()\n\tlocal combinedVolume = 0\n\tfor tracker, _ in pairs(trackers) do\n\t\tcombinedVolume += tracker.totalVolume\n\tend\n\treturn combinedVolume\nend\n\nfunction Tracker.getCharacterSize(character)\n\tlocal head = character and character:FindFirstChild(\"Head\")\n\tlocal hrp = character and character:FindFirstChild(\"HumanoidRootPart\")\n\tif not(hrp and head) then return nil end\n\tif not head:IsA(\"BasePart\") then\n\t\thead = hrp\n\tend\n\tlocal headY = head.Size.Y\n\tlocal hrpSize = hrp.Size\n\tlocal charSize = (hrpSize * Vector3.new(2, 2, 1)) + Vector3.new(0, headY, 0)\n\tlocal charCFrame = hrp.CFrame * CFrame.new(0, headY/2 - hrpSize.Y/2, 0)\n\treturn charSize, charCFrame\nend\n\n\n\n-- CONSTRUCTOR\nfunction Tracker.new(name)\n\tlocal self = {}\n\tsetmetatable(self, Tracker)\n\t\n\tself.name = name\n\tself.totalVolume = 0\n\tself.parts = {}\n\tself.partToItem = {}\n\tself.items = {}\n\tself.whitelistParams = nil\n\tself.characters = {}\n\tself.baseParts = {}\n\tself.exitDetections = {}\n\tself.janitor = Janitor.new()\n\n\tif name == \"player\" then\n\t\tlocal function updatePlayerCharacters()\n\t\t\tlocal characters = {}\n\t\t\tfor _, player in pairs(players:GetPlayers()) do\n\t\t\t\tlocal character = player.Character\n\t\t\t\tif character then\n\t\t\t\t\tcharacters[character] = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tself.characters = characters\n\t\tend\n\t\t\n\t\tlocal function playerAdded(player)\n\t\t\tlocal function charAdded(character)\n\t\t\t\tlocal humanoid = character:WaitForChild(\"Humanoid\", 3)\n\t\t\t\tif humanoid then\n\t\t\t\t\tupdatePlayerCharacters()\n\t\t\t\t\tself:update()\n\t\t\t\t\tfor _, valueInstance in pairs(humanoid:GetChildren()) do\n\t\t\t\t\t\tif valueInstance:IsA(\"NumberValue\") then\n\t\t\t\t\t\t\tvalueInstance.Changed:Connect(function()\n\t\t\t\t\t\t\t\tself:update()\n\t\t\t\t\t\t\tend)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif player.Character then\n\t\t\t\tcharAdded(player.Character)\n\t\t\tend\n\t\t\tplayer.CharacterAdded:Connect(charAdded)\n\t\t\tplayer.CharacterRemoving:Connect(function(removingCharacter)\n\t\t\t\tself.exitDetections[removingCharacter] = nil\n\t\t\tend)\n\t\tend\n\t\t\n\t\tplayers.PlayerAdded:Connect(playerAdded)\n\t\tfor _, player in pairs(players:GetPlayers()) do\n\t\t\tplayerAdded(player)\n\t\tend\n\t\t\n\t\tplayers.PlayerRemoving:Connect(function(player)\n\t\t\tupdatePlayerCharacters()\n\t\t\tself:update()\n\t\tend)\n\n\n\telseif name == \"item\" then\n\t\tlocal function updateItem(itemDetail, newValue)\n\t\t\tif itemDetail.isCharacter then\n\t\t\t\tself.characters[itemDetail.item] = newValue\n\t\t\telseif itemDetail.isBasePart then\n\t\t\t\tself.baseParts[itemDetail.item] = newValue\n\t\t\tend\n\t\t\tself:update()\n\t\tend\n\t\tTracker.itemAdded:Connect(function(itemDetail)\n\t\t\tupdateItem(itemDetail, true)\n\t\tend)\n\t\tTracker.itemRemoved:Connect(function(itemDetail)\n\t\t\tself.exitDetections[itemDetail.item] = nil\n\t\t\tupdateItem(itemDetail, nil)\n\t\tend)\n\tend\n\n\ttrackers[self] = true\n\ttask.defer(self.update, self)\n\treturn self\nend\n\n\n\n-- METHODS\nfunction Tracker:_preventMultiFrameUpdates(methodName, ...)\n\t-- This prevents the funtion being called twice within a single frame\n\t-- If called more than once, the function will initally be delayed again until the next frame, then all others cancelled\n\tself._preventMultiDetails = self._preventMultiDetails or {}\n\tlocal detail = self._preventMultiDetails[methodName]\n\tif not detail then\n\t\tdetail = {\n\t\t\tcalling = false,\n\t\t\tcallsThisFrame = 0,\n\t\t\tupdatedThisFrame = false,\n\t\t}\n\t\tself._preventMultiDetails[methodName] = detail\n\tend\n\n\tdetail.callsThisFrame += 1\n\tif detail.callsThisFrame == 1 then\n\t\tlocal args = table.pack(...)\n\t\ttask.defer(function()\n\t\t\tlocal newCallsThisFrame = detail.callsThisFrame\n\t\t\tdetail.callsThisFrame = 0\n\t\t\tif newCallsThisFrame > 1 then\n\t\t\t\tself[methodName](self, unpack(args))\n\t\t\tend\n\t\tend)\n\t\treturn false\n\tend\n\treturn true\nend\n\nfunction Tracker:update()\n\tif self:_preventMultiFrameUpdates(\"update\") then\n\t\treturn\n\tend\n\t\n\tself.totalVolume = 0\n\tself.parts = {}\n\tself.partToItem = {}\n\tself.items = {}\n\t\n\t-- This tracks the bodyparts of a character\n\tfor character, _ in pairs(self.characters) do\n\t\tlocal charSize = Tracker.getCharacterSize(character)\n\t\tif not charSize then\n\t\t\tcontinue\n\t\tend\n\t\tlocal rSize = charSize\n\t\tlocal charVolume = rSize.X*rSize.Y*rSize.Z\n\t\tself.totalVolume += charVolume\n\t\t\n\t\tlocal characterJanitor = self.janitor:add(Janitor.new(), \"destroy\", \"trackCharacterParts-\"..self.name)\n\t\tlocal function updateTrackerOnParentChanged(instance)\n\t\t\tcharacterJanitor:add(instance.AncestryChanged:Connect(function()\n\t\t\t\tif not instance:IsDescendantOf(game) then\n\t\t\t\t\tif instance.Parent == nil and characterJanitor ~= nil then\n\t\t\t\t\t\tcharacterJanitor:destroy()\n\t\t\t\t\t\tcharacterJanitor = nil\n\t\t\t\t\t\tself:update()\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend), \"Disconnect\")\n\t\tend\n\n\t\tfor _, part in pairs(character:GetChildren()) do\n\t\t\tif part:IsA(\"BasePart\") and not Tracker.bodyPartsToIgnore[part.Name] then\n\t\t\t\tself.partToItem[part] = character\n\t\t\t\ttable.insert(self.parts, part)\n\t\t\t\tupdateTrackerOnParentChanged(part)\n\t\t\tend\n\t\tend\n\t\tupdateTrackerOnParentChanged(character)\n\t\ttable.insert(self.items, character)\n\tend\n\n\t-- This tracks any additional baseParts\n\tfor additionalPart, _ in pairs(self.baseParts) do\n\t\tlocal rSize = additionalPart.Size\n\t\tlocal partVolume = rSize.X*rSize.Y*rSize.Z\n\t\tself.totalVolume += partVolume\n\t\tself.partToItem[additionalPart] = additionalPart\n\t\ttable.insert(self.parts, additionalPart)\n\t\ttable.insert(self.items, additionalPart)\n\tend\n\t\n\t-- This creates the whitelist so that\n\tself.whitelistParams = OverlapParams.new()\n\tself.whitelistParams.FilterType = Enum.RaycastFilterType.Whitelist\n\tself.whitelistParams.MaxParts = #self.parts\n\tself.whitelistParams.FilterDescendantsInstances = self.parts\nend\n\n\n\nreturn Tracker",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: Tracker)>"
}