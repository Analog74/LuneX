{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: Signal)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: Signal)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: Signal)>",
  "Sandboxed": false,
  "ScriptGuid": "{F66F2A0D-BBB9-43BD-A7BC-51D99067B82E}",
  "Source": "--------------------------------------------------------------------------------\n--               Batched Yield-Safe Signal Implementation                     --\n-- This is a Signal class which has effectively identical behavior to a       --\n-- normal RBXScriptSignal, with the only difference being a couple extra      --\n-- stack frames at the bottom of the stack trace when an error is thrown.     --\n-- This implementation caches runner coroutines, so the ability to yield in   --\n-- the signal handlers comes at minimal extra cost over a naive signal        --\n-- implementation that either always or never spawns a thread.                --\n--                                                                            --\n-- API:                                                                       --\n--   local Signal = require(THIS MODULE)                                      --\n--   local sig = Signal.new()                                                 --\n--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --\n--   sig:Fire(arg1, arg2, ...)                                                --\n--   connection:Disconnect()                                                  --\n--   sig:DisconnectAll()                                                      --\n--   local arg1, arg2, ... = sig:Wait()                                       --\n--                                                                            --\n-- Licence:                                                                   --\n--   Licenced under the MIT licence.                                          --\n--                                                                            --\n-- Authors:                                                                   --\n--   stravant - July 31st, 2021 - Created the file.                           --\n--------------------------------------------------------------------------------\n\n-- The currently idle thread to run the next handler on\nlocal freeRunnerThread = nil\n\n-- Function which acquires the currently idle handler runner thread, runs the\n-- function fn on it, and then releases the thread, returning it to being the\n-- currently idle one.\n-- If there was a currently idle runner thread already, that's okay, that old\n-- one will just get thrown and eventually GCed.\nlocal function acquireRunnerThreadAndCallEventHandler(fn, ...)\n\tlocal acquiredRunnerThread = freeRunnerThread\n\tfreeRunnerThread = nil\n\tfn(...)\n\t-- The handler finished running, this runner thread is free again.\n\tfreeRunnerThread = acquiredRunnerThread\nend\n\n-- Coroutine runner that we create coroutines of. The coroutine can be \n-- repeatedly resumed with functions to run followed by the argument to run\n-- them with.\nlocal function runEventHandlerInFreeThread(...)\n\tacquireRunnerThreadAndCallEventHandler(...)\n\twhile true do\n\t\tacquireRunnerThreadAndCallEventHandler(coroutine.yield())\n\tend\nend\n\n-- Connection class\nlocal Connection = {}\nConnection.__index = Connection\n\nfunction Connection.new(signal, fn)\n\treturn setmetatable({\n\t\t_connected = true,\n\t\t_signal = signal,\n\t\t_fn = fn,\n\t\t_next = false,\n\t}, Connection)\nend\n\nfunction Connection:Disconnect()\n\tassert(self._connected, \"Can't disconnect a connection twice.\", 2)\n\tself._connected = false\n\n\t-- Unhook the node, but DON'T clear it. That way any fire calls that are\n\t-- currently sitting on this node will be able to iterate forwards off of\n\t-- it, but any subsequent fire calls will not hit it, and it will be GCed\n\t-- when no more fire calls are sitting on it.\n    local signal = self._signal\n\tif signal._handlerListHead == self then\n\t\tsignal._handlerListHead = self._next\n\telse\n\t\tlocal prev = signal._handlerListHead\n\t\twhile prev and prev._next ~= self do\n\t\t\tprev = prev._next\n\t\tend\n\t\tif prev then\n\t\t\tprev._next = self._next\n\t\tend\n\tend\n\n    if signal.connectionsChanged then\n\t\tsignal.totalConnections -= 1\n        signal.connectionsChanged:Fire(-1)\n    end\nend\n\n-- Make Connection strict\nsetmetatable(Connection, {\n\t__index = function(tb, key)\n\t\terror((\"Attempt to get Connection::%s (not a valid member)\"):format(tostring(key)), 2)\n\tend,\n\t__newindex = function(tb, key, value)\n\t\terror((\"Attempt to set Connection::%s (not a valid member)\"):format(tostring(key)), 2)\n\tend\n})\n\n-- Signal class\nlocal Signal = {}\nSignal.__index = Signal\n\nfunction Signal.new(createConnectionsChangedSignal)\n\tlocal self = setmetatable({\n\t\t_handlerListHead = false,\t\n\t}, Signal)\n    if createConnectionsChangedSignal then\n        self.totalConnections = 0\n\t\tself.connectionsChanged = Signal.new()\n\tend\n    return self\nend\n\nfunction Signal:Connect(fn)\n\tlocal connection = Connection.new(self, fn)\n\tif self._handlerListHead then\n\t\tconnection._next = self._handlerListHead\n\t\tself._handlerListHead = connection\n\telse\n\t\tself._handlerListHead = connection\n\tend\n\n\tif self.connectionsChanged then\n        self.totalConnections += 1\n\t\tself.connectionsChanged:Fire(1)\n\tend\n\treturn connection\nend\n\n-- Disconnect all handlers. Since we use a linked list it suffices to clear the\n-- reference to the head handler.\nfunction Signal:DisconnectAll()\n\tself._handlerListHead = false\n\n    if self.connectionsChanged then\n\t\tself.connectionsChanged:Fire(-self.totalConnections)\n\t\tself.connectionsChanged:Destroy()\n\t\tself.connectionsChanged = nil\n\t\tself.totalConnections = 0\n\tend\nend\nSignal.Destroy = Signal.DisconnectAll\nSignal.destroy = Signal.DisconnectAll\n\n-- Signal:Fire(...) implemented by running the handler functions on the\n-- coRunnerThread, and any time the resulting thread yielded without returning\n-- to us, that means that it yielded to the Roblox scheduler and has been taken\n-- over by Roblox scheduling, meaning we have to make a new coroutine runner.\nfunction Signal:Fire(...)\n\tlocal item = self._handlerListHead\n\twhile item do\n\t\tif item._connected then\n\t\t\tif not freeRunnerThread then\n\t\t\t\tfreeRunnerThread = coroutine.create(runEventHandlerInFreeThread)\n\t\t\tend\n\t\t\ttask.spawn(freeRunnerThread, item._fn, ...)\n\t\tend\n\t\titem = item._next\n\tend\nend\n\n-- Implement Signal:Wait() in terms of a temporary connection using\n-- a Signal:Connect() which disconnects itself.\nfunction Signal:Wait()\n\tlocal waitingCoroutine = coroutine.running()\n\tlocal cn;\n\tcn = self:Connect(function(...)\n\t\tcn:Disconnect()\n\t\ttask.spawn(waitingCoroutine, ...)\n\tend)\n\treturn coroutine.yield()\nend\n\n\nreturn Signal",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: Signal)>"
}