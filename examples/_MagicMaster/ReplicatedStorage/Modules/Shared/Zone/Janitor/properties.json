{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: Janitor)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: Janitor)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: Janitor)>",
  "Sandboxed": false,
  "ScriptGuid": "{B459DA13-6627-4F12-9474-7BB97856368F}",
  "Source": "-- Janitor\n-- Original by Validark\n-- Modifications by pobammer\n-- roblox-ts support by OverHash and Validark\n-- LinkToInstance fixed by Elttob.\n\nlocal RunService = game:GetService(\"RunService\")\nlocal Heartbeat = RunService.Heartbeat\n\nlocal IndicesReference = newproxy(true)\ngetmetatable(IndicesReference).__tostring = function()\n\treturn \"IndicesReference\"\nend\n\nlocal LinkToInstanceIndex = newproxy(true)\ngetmetatable(LinkToInstanceIndex).__tostring = function()\n\treturn \"LinkToInstanceIndex\"\nend\n\nlocal METHOD_NOT_FOUND_ERROR = \"Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s\"\n--local NOT_A_PROMISE = \"Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))\"\n\nlocal Janitor = {\n\tClassName = \"Janitor\";\n\t__index = {\n\t\tCurrentlyCleaning = true;\n\t\t[IndicesReference] = nil;\n\t};\n}\n\nlocal TypeDefaults = {\n\t[\"function\"] = true;\n\tRBXScriptConnection = \"Disconnect\";\n}\n\n--[[**\n\tInstantiates a new Janitor object.\n\t@returns [t:Janitor]\n**--]]\nfunction Janitor.new()\n\treturn setmetatable({\n\t\tCurrentlyCleaning = false;\n\t\t[IndicesReference] = nil;\n\t}, Janitor)\nend\n\n--[[**\n\tDetermines if the passed object is a Janitor.\n\t@param [t:any] Object The object you are checking.\n\t@returns [t:boolean] Whether or not the object is a Janitor.\n**--]]\nfunction Janitor.Is(Object)\n\treturn type(Object) == \"table\" and getmetatable(Object) == Janitor\nend\n\nJanitor.is = Janitor.Is\n\n--[[**\n\tAdds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.\n\t@param [t:any] Object The object you want to clean up.\n\t@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.\n\t@param [t:any?] Index The index that can be used to clean up the object manually.\n\t@returns [t:any] The object that was passed.\n**--]]\nfunction Janitor.__index:Add(Object, MethodName, Index)\n\tif Index == nil then\n\t\tIndex = newproxy(false)\n\tend\n\n\tif Index then\n\t\tself:Remove(Index)\n\n\t\tlocal This = self[IndicesReference]\n\t\tif not This then\n\t\t\tThis = {}\n\t\t\tself[IndicesReference] = This\n\t\tend\n\n\t\tThis[Index] = Object\n\tend\n\t--[[\n\tif Promise.is(Object) then\n\t\tlocal Id = newproxy(false)\n\t\tif Object:getStatus() == Promise.Status.Started then\n\t\t\tlocal NewPromise = self:Add(Promise.resolve(Object), \"cancel\", Id)\n\t\t\tNewPromise:finallyCall(self.Remove, self, Id)\n\t\t\treturn NewPromise, Id\n\t\telse\n\t\t\treturn Object\n\t\tend\n\tend--]]\n\n\tMethodName = MethodName or TypeDefaults[typeof(Object)] or \"Destroy\"\n\tif type(Object) ~= \"function\" and not Object[MethodName] then\n\t\twarn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))\n\tend\n\n\tself[Object] = MethodName\n\treturn Object, Index\nend\n\nJanitor.__index.Give = Janitor.__index.Add\n\n-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.\n\n--[[**\n\tAdds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.\n\t@param [t:Promise] PromiseObject The promise you want to add to the janitor.\n\t@returns [t:Promise]\n**--]]\n--[[\nfunction Janitor.__index:AddPromise(PromiseObject)\n\tif not Promise.is(PromiseObject) then\n\t\terror(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))\n\tend\n\n\tif PromiseObject:getStatus() == Promise.Status.Started then\n\t\tlocal Id = newproxy(false)\n\t\tlocal NewPromise = self:Add(Promise.resolve(PromiseObject), \"cancel\", Id)\n\t\tNewPromise:finallyCall(self.Remove, self, Id)\n\t\treturn NewPromise, Id\n\telse\n\t\treturn PromiseObject\n\tend\nend\n--]]\n\n--Janitor.__index.GivePromise = Janitor.__index.AddPromise\n\n-- This will assume whether or not the object is a Promise or a regular object.\nfunction Janitor.__index:AddObject(Object)\n\tlocal Id = newproxy(false)\n\t--[[\n\tif Promise.is(Object) then\n\t\tif Object:getStatus() == Promise.Status.Started then\n\t\t\tlocal NewPromise = self:Add(Promise.resolve(Object), \"cancel\", Id)\n\t\t\tNewPromise:finallyCall(self.Remove, self, Id)\n\t\t\treturn NewPromise, Id\n\t\telse\n\t\t\treturn Object\n\t\tend\n\telse\n\t\treturn self:Add(Object, false, Id), Id\n\tend---]]\n\treturn self:Add(Object, false, Id), Id\nend\n\nJanitor.__index.GiveObject = Janitor.__index.AddObject\n\n--[[**\n\tCleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.\n\t@param [t:any] Index The index you want to remove.\n\t@returns [t:Janitor] The same janitor, for chaining reasons.\n**--]]\nfunction Janitor.__index:Remove(Index)\n\tlocal This = self[IndicesReference]\n\n\tif This then\n\t\tlocal Object = This[Index]\n\n\t\tif Object then\n\t\t\tlocal MethodName = self[Object]\n\n\t\t\tif MethodName then\n\t\t\t\tif MethodName == true then\n\t\t\t\t\tObject()\n\t\t\t\telse\n\t\t\t\t\tlocal ObjectMethod = Object[MethodName]\n\t\t\t\t\tif ObjectMethod then\n\t\t\t\t\t\tObjectMethod(Object)\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tself[Object] = nil\n\t\t\tend\n\n\t\t\tThis[Index] = nil\n\t\tend\n\tend\n\n\treturn self\nend\n\n--[[**\n\tGets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.\n\t@param [t:any] Index The index that the object is stored under.\n\t@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.\n**--]]\nfunction Janitor.__index:Get(Index)\n\tlocal This = self[IndicesReference]\n\tif This then\n\t\treturn This[Index]\n\tend\nend\n\n--[[**\n\tCalls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).\n\t@returns [t:void]\n**--]]\nfunction Janitor.__index:Cleanup()\n\tif not self.CurrentlyCleaning then\n\t\tself.CurrentlyCleaning = nil\n\t\tfor Object, MethodName in next, self do\n\t\t\tif Object == IndicesReference then\n\t\t\t\tcontinue\n\t\t\tend\n\n\t\t\t-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.\n\t\t\tlocal TypeOf = type(Object)\n\t\t\tif TypeOf == \"string\" or TypeOf == \"number\" then\n\t\t\t\tself[Object] = nil\n\t\t\t\tcontinue\n\t\t\tend\n\n\t\t\tif MethodName == true then\n\t\t\t\tObject()\n\t\t\telse\n\t\t\t\tlocal ObjectMethod = Object[MethodName]\n\t\t\t\tif ObjectMethod then\n\t\t\t\t\tObjectMethod(Object)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tself[Object] = nil\n\t\tend\n\n\t\tlocal This = self[IndicesReference]\n\t\tif This then\n\t\t\tfor Index in next, This do\n\t\t\t\tThis[Index] = nil\n\t\t\tend\n\n\t\t\tself[IndicesReference] = {}\n\t\tend\n\n\t\tself.CurrentlyCleaning = false\n\tend\nend\n\nJanitor.__index.Clean = Janitor.__index.Cleanup\n\n--[[**\n\tCalls `:Cleanup()` and renders the Janitor unusable.\n\t@returns [t:void]\n**--]]\nfunction Janitor.__index:Destroy()\n\tself:Cleanup()\n\t--table.clear(self)\n\t--setmetatable(self, nil)\nend\n\nJanitor.__call = Janitor.__index.Cleanup\n\n--- Makes the Janitor clean up when the instance is destroyed\n-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed\n-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)\n-- @author Corecii\nlocal Disconnect = {Connected = true}\nDisconnect.__index = Disconnect\nfunction Disconnect:Disconnect()\n\tif self.Connected then\n\t\tself.Connected = false\n\t\tself.Connection:Disconnect()\n\tend\nend\n\nfunction Disconnect:__tostring()\n\treturn \"Disconnect<\" .. tostring(self.Connected) .. \">\"\nend\n\n--[[**\n\t\"Links\" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will \"link\" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.\n\t@param [t:Instance] Object The instance you want to link the Janitor to.\n\t@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.\n\t@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.\n**--]]\nfunction Janitor.__index:LinkToInstance(Object, AllowMultiple)\n\tlocal Connection\n\tlocal IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex\n\tlocal IsNilParented = Object.Parent == nil\n\tlocal ManualDisconnect = setmetatable({}, Disconnect)\n\n\tlocal function ChangedFunction(_DoNotUse, NewParent)\n\t\tif ManualDisconnect.Connected then\n\t\t\t_DoNotUse = nil\n\t\t\tIsNilParented = NewParent == nil\n\n\t\t\tif IsNilParented then\n\t\t\t\tcoroutine.wrap(function()\n\t\t\t\t\tHeartbeat:Wait()\n\t\t\t\t\tif not ManualDisconnect.Connected then\n\t\t\t\t\t\treturn\n\t\t\t\t\telseif not Connection.Connected then\n\t\t\t\t\t\tself:Cleanup()\n\t\t\t\t\telse\n\t\t\t\t\t\twhile IsNilParented and Connection.Connected and ManualDisconnect.Connected do\n\t\t\t\t\t\t\tHeartbeat:Wait()\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\tif ManualDisconnect.Connected and IsNilParented then\n\t\t\t\t\t\t\tself:Cleanup()\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend)()\n\t\t\tend\n\t\tend\n\tend\n\n\tConnection = Object.AncestryChanged:Connect(ChangedFunction)\n\tManualDisconnect.Connection = Connection\n\n\tif IsNilParented then\n\t\tChangedFunction(nil, Object.Parent)\n\tend\n\n\tObject = nil\n\treturn self:Add(ManualDisconnect, \"Disconnect\", IndexToUse)\nend\n\n--[[**\n\tLinks several instances to a janitor, which is then returned.\n\t@param [t:...Instance] ... All the instances you want linked.\n\t@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.\n**--]]\nfunction Janitor.__index:LinkToInstances(...)\n\tlocal ManualCleanup = Janitor.new()\n\tfor _, Object in ipairs({...}) do\n\t\tManualCleanup:Add(self:LinkToInstance(Object, true), \"Disconnect\")\n\tend\n\n\treturn ManualCleanup\nend\n\nfor FunctionName, Function in next, Janitor.__index do\n\tlocal NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)\n\tJanitor.__index[NewFunctionName] = Function\nend\n\nreturn Janitor",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: Janitor)>"
}