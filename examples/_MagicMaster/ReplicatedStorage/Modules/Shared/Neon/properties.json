{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: Neon)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: Neon)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: Neon)>",
  "Sandboxed": false,
  "ScriptGuid": "{652540FE-05EE-49DA-999E-AE33F07E586D}",
  "Source": "-- fractality\n\n\nlocal module = {}\n\n\nlocal RunService = game:GetService'RunService'\nlocal camera = workspace.CurrentCamera\n\n\ndo\n\tlocal function IsNotNaN(x)\n\t\treturn x == x\n\tend\n\tlocal continue = IsNotNaN(camera:ScreenPointToRay(0,0).Origin.x)\n\twhile not continue do\n\t\tRunService.RenderStepped:wait()\n\t\tcontinue = IsNotNaN(camera:ScreenPointToRay(0,0).Origin.x)\n\tend\nend\n\nlocal binds = {}\nlocal root = Instance.new('Folder', camera)\nroot.Name = 'neon'\n\n\nlocal GenUid; do -- Generate unique names for RenderStepped bindings\n\tlocal id = 0\n\tfunction GenUid()\n\t\tid = id + 1\n\t\treturn 'neon::'..tostring(id)\n\tend\nend\n\nlocal DrawQuad; do\n\tlocal acos, max, pi, sqrt = math.acos, math.max, math.pi, math.sqrt\n\tlocal sz = 0.2\n\t\n\tfunction DrawTriangle(v1, v2, v3, p0, p1) -- I think Stravant wrote this function\n\t\tlocal s1 = (v1 - v2).magnitude\n\t\tlocal s2 = (v2 - v3).magnitude\n\t\tlocal s3 = (v3 - v1).magnitude\n\t\tlocal smax = max(s1, s2, s3)\n\t\tlocal A, B, C\n\t\tif s1 == smax then\n\t\t\tA, B, C = v1, v2, v3\n\t\telseif s2 == smax then\n\t\t\tA, B, C = v2, v3, v1\n\t\telseif s3 == smax then\n\t\t\tA, B, C = v3, v1, v2\n\t\tend\n\t\n\t\tlocal para = ( (B-A).x*(C-A).x + (B-A).y*(C-A).y + (B-A).z*(C-A).z ) / (A-B).magnitude\n\t\tlocal perp = sqrt((C-A).magnitude^2 - para*para)\n\t\tlocal dif_para = (A - B).magnitude - para\n\t\n\t\tlocal st = CFrame.new(B, A)\n\t\tlocal za = CFrame.Angles(pi/2,0,0)\n\t\n\t\tlocal cf0 = st\n\t\n\t\tlocal Top_Look = (cf0 * za).lookVector\n\t\tlocal Mid_Point = A + CFrame.new(A, B).lookVector * para\n\t\tlocal Needed_Look = CFrame.new(Mid_Point, C).lookVector\n\t\tlocal dot = Top_Look.x*Needed_Look.x + Top_Look.y*Needed_Look.y + Top_Look.z*Needed_Look.z\n\t\n\t\tlocal ac = CFrame.Angles(0, 0, acos(dot))\n\t\n\t\tcf0 = cf0 * ac\n\t\tif ((cf0 * za).lookVector - Needed_Look).magnitude > 0.01 then\n\t\t\tcf0 = cf0 * CFrame.Angles(0, 0, -2*acos(dot))\n\t\tend\n\t\tcf0 = cf0 * CFrame.new(0, perp/2, -(dif_para + para/2))\n\t\n\t\tlocal cf1 = st * ac * CFrame.Angles(0, pi, 0)\n\t\tif ((cf1 * za).lookVector - Needed_Look).magnitude > 0.01 then\n\t\t\tcf1 = cf1 * CFrame.Angles(0, 0, 2*acos(dot))\n\t\tend\n\t\tcf1 = cf1 * CFrame.new(0, perp/2, dif_para/2)\n\t\n\t\tif not p0 then\n\t\t\tp0 = Instance.new('Part')\n\t\t\tp0.FormFactor = 'Custom'\n\t\t\tp0.TopSurface = 0\n\t\t\tp0.BottomSurface = 0\n\t\t\tp0.Anchored = true\n\t\t\tp0.CanCollide = false\n\t\t\tp0.Material = 'Glass'\n\t\t\tp0.Size = Vector3.new(sz, sz, sz)\n\t\t\tlocal mesh = Instance.new('SpecialMesh', p0)\n\t\t\tmesh.MeshType = 2\n\t\t\tmesh.Name = 'WedgeMesh'\n\t\tend\n\t\tp0.WedgeMesh.Scale = Vector3.new(0, perp/sz, para/sz)\n\t\tp0.CFrame = cf0\n\t\t\n\t\tif not p1 then\n\t\t\tp1 = p0:clone()\n\t\tend\n\t\tp1.WedgeMesh.Scale = Vector3.new(0, perp/sz, dif_para/sz)\n\t\tp1.CFrame = cf1\n\t\t\n\t\treturn p0, p1\n\tend\n\n\tfunction DrawQuad(v1, v2, v3, v4, parts)\n\t\tparts[1], parts[2] = DrawTriangle(v1, v2, v3, parts[1], parts[2])\n\t\tparts[3], parts[4] = DrawTriangle(v3, v2, v4, parts[3], parts[4])\n\tend\nend\n\n\n--------------------------------\n---- Module API --------------------------------\n----------------------------------------------------------------\n\n\n-- Create a part binding for a GuiObject.\nfunction module:BindFrame(frame, properties)\n\tif binds[frame] then\n\t\treturn binds[frame].parts\n\tend\n\t\n\tlocal uid = GenUid()\n\tlocal parts = {}\n\tlocal f = Instance.new('Folder', root)\n\tf.Name = frame.Name\n\t\n\tlocal parents = {} -- construct hierarchy tree for rotation\n\tdo\n\t\tlocal function add(child)\n\t\t\tif child:IsA'GuiObject' then\n\t\t\t\tparents[#parents + 1] = child\n\t\t\t\tadd(child.Parent)\n\t\t\tend\n\t\tend\n\t\tadd(frame)\n\tend\n\t\n\tlocal function UpdateOrientation(fetchProps)\n\t\tlocal zIndex = 1 - 0.05*frame.ZIndex\n\t\t-- the transparency inversion bug still surfaces when there's z-fighting\n\t\tlocal tl, br = frame.AbsolutePosition, frame.AbsolutePosition + frame.AbsoluteSize\n\t\tlocal tr, bl = Vector2.new(br.x, tl.y), Vector2.new(tl.x, br.y)\n\t\tdo\n\t\t\tlocal rot = 0;\n\t\t\tfor _, v in ipairs(parents) do\n\t\t\t\trot = rot + v.Rotation\n\t\t\tend\n\t\t\tif rot ~= 0 and rot%180 ~= 0 then\n\t\t\t\tlocal mid = tl:lerp(br, 0.5)\n\t\t\t\tlocal s, c = math.sin(math.rad(rot)), math.cos(math.rad(rot))\n\t\t\t\tlocal vec = tl\n\t\t\t\ttl = Vector2.new(c*(tl.x - mid.x) - s*(tl.y - mid.y), s*(tl.x - mid.x) + c*(tl.y - mid.y)) + mid\n\t\t\t\ttr = Vector2.new(c*(tr.x - mid.x) - s*(tr.y - mid.y), s*(tr.x - mid.x) + c*(tr.y - mid.y)) + mid\n\t\t\t\tbl = Vector2.new(c*(bl.x - mid.x) - s*(bl.y - mid.y), s*(bl.x - mid.x) + c*(bl.y - mid.y)) + mid\n\t\t\t\tbr = Vector2.new(c*(br.x - mid.x) - s*(br.y - mid.y), s*(br.x - mid.x) + c*(br.y - mid.y)) + mid\n\t\t\tend\n\t\tend\n\t\tDrawQuad(\n\t\t\tcamera:ScreenPointToRay(tl.x, tl.y, zIndex).Origin, \n\t\t\tcamera:ScreenPointToRay(tr.x, tr.y, zIndex).Origin, \n\t\t\tcamera:ScreenPointToRay(bl.x, bl.y, zIndex).Origin, \n\t\t\tcamera:ScreenPointToRay(br.x, br.y, zIndex).Origin, \n\t\t\tparts\n\t\t)\n\t\tif fetchProps then\n\t\t\tfor _, pt in pairs(parts) do\n\t\t\t\tpt.Parent = f\n\t\t\tend\n\t\t\tfor propName, propValue in pairs(properties) do\n\t\t\t\tfor _, pt in pairs(parts) do\n\t\t\t\t\tpt[propName] = propValue\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tUpdateOrientation(true)\n\tRunService:BindToRenderStep(uid, 2000, UpdateOrientation)\n\t\n\tbinds[frame] = {\n\t\tuid = uid;\n\t\tparts = parts;\n\t}\n\treturn binds[frame].parts\nend\n\n-- Applies the `properties` table to bound parts.\nfunction module:Modify(frame, properties)\n\tlocal parts = module:GetBoundParts(frame)\n\tif parts then\n\t\tfor propName, propValue in pairs(properties) do\n\t\t\tfor _, pt in pairs(parts) do\n\t\t\t\tpt[propName] = propValue\n\t\t\tend\n\t\tend\n\telse\n\t\twarn(('No part bindings exist for %s'):format(frame:GetFullName()))\n\tend\nend\n\n-- Removes the part binding from a gui object if one exists.\nfunction module:UnbindFrame(frame)\n\tlocal cb = binds[frame]\n\tif cb then\n\t\tRunService:UnbindFromRenderStep(cb.uid)\n\t\tfor _, v in pairs(cb.parts) do\n\t\t\tv:Destroy()\n\t\tend\n\t\tbinds[frame] = nil\n\telse\n\t\twarn(('No part bindings exist for %s'):format(frame:GetFullName()))\n\tend\nend\n\n-- Returns true if a part binding exists for the gui object.\nfunction module:HasBinding(frame)\n\treturn binds[frame] ~= nil\nend\n\n-- Returns an array using this.\nfunction module:GetBoundParts(frame)\n\treturn binds[frame] and binds[frame].parts\nend\n\n\nreturn module\n",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: Neon)>"
}