{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: LightningBolt)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: LightningBolt)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: LightningBolt)>",
  "Sandboxed": false,
  "ScriptGuid": "{DE72F730-889C-44EA-8BEC-21FAE40A6346}",
  "Source": "--Procedural Lightning Module. By Quasiduck\n--License: See GitHub\n--See README for guide on how to use or scroll down to see all properties in LightningBolt.new\n--All properties update in real-time except PartCount which requires a new LightningBolt to change\n--i.e. You can change a property at any time and it will still update the look of the bolt\n\nlocal clock = os.clock\n\n\n\n\n\n\nlocal function DiscretePulse(input, s, k, f, t, min, max) --input should be between 0 and 1. See https://www.desmos.com/calculator/hg5h4fpfim for demonstration.\n\treturn math.clamp( (k)/(2*f) - math.abs( (input - t*s + 0.5*(k)) / (f) ), min, max )\nend\n\nlocal function NoiseBetween(x, y, z, min, max)\n\treturn min + (max - min)*(math.noise(x, y, z) + 0.5)\nend\n\nlocal function CubicBezier(p0, p1, p2, p3, t)\n\treturn p0*(1 - t)^3 + p1*3*t*(1 - t)^2 + p2*3*(1 - t)*t^2 + p3*t^3\nend\n\nlocal BoltPart = Instance.new(\"Part\")\nBoltPart.TopSurface, BoltPart.BottomSurface = 0, 0\nBoltPart.Anchored, BoltPart.CanCollide = true, false\nBoltPart.Shape = \"Cylinder\"\nBoltPart.Name = \"BoltPart\"\nBoltPart.CanTouch = false\nBoltPart.CastShadow = false\nBoltPart.CanQuery = false\nBoltPart.Material = Enum.Material.Neon\nBoltPart.Color = Color3.new(1, 1, 1)\nBoltPart.Transparency = 1\n\nlocal rng = Random.new()\nlocal xInverse = CFrame.lookAt(Vector3.new(), Vector3.new(1, 0, 0)):Inverse()\n\nlocal ActiveBranches = {}\n\nlocal LightningBolt = {}\nLightningBolt.__index = LightningBolt\n\n--Small tip: You don't need to use actual Roblox Attachments below. You can also create \"fake\" ones as follows:\n--[[\nlocal A1, A2 = {}, {}\nA1.WorldPosition, A1.WorldAxis = chosenPos1, chosenAxis1\nA2.WorldPosition, A2.WorldAxis = chosenPos2, chosenAxis2\nlocal NewBolt = LightningBolt.new(A1, A2, 40)\n--]]\n\nfunction LightningBolt.new(Attachment0, Attachment1, PartCount)\n\tlocal self = setmetatable({}, LightningBolt)\n\t\n\t--Main (default) Properties--\n\t\n\t\t--Bolt Appearance Properties--\n\t\t\tself.Enabled = true --Hides bolt without destroying any parts when false\n\t\t\tself.Attachment0, self.Attachment1 = Attachment0, Attachment1 --Bolt originates from Attachment0 and ends at Attachment1\n\t\t\tself.CurveSize0, self.CurveSize1 = 0, 0 --Works similarly to beams. See https://dk135eecbplh9.cloudfront.net/assets/blt160ad3fdeadd4ff2/BeamCurve1.png\n\t\t\tself.MinRadius, self.MaxRadius = 0, 2.4 --Governs the amplitude of fluctuations throughout the bolt\n\t\t\tself.Frequency = 1 --Governs the frequency of fluctuations throughout the bolt. Lower this to remove jittery-looking lightning\n\t\t\tself.AnimationSpeed = 7 --Governs how fast the bolt oscillates (i.e. how fast the fluctuating wave travels along bolt)\n\t\t\tself.Thickness = 1 --The thickness of the bolt\n\t\t\tself.MinThicknessMultiplier, self.MaxThicknessMultiplier = 0.2, 1 --Multiplies Thickness value by a fluctuating random value between MinThicknessMultiplier and MaxThicknessMultiplier along the Bolt\n\t\n\t\t--Bolt Kinetic Properties--\n\t\t\t--Allows for fading in (or out) of the bolt with time. Can also create a \"projectile\" bolt\n\t\t\t--Recommend setting AnimationSpeed to 0 if used as projectile (for better aesthetics)\n\t\t\t--Works by passing a \"wave\" function which travels from left to right where the wave height represents opacity (opacity being 1 - Transparency)\n\t\t\t--See https://www.desmos.com/calculator/hg5h4fpfim to help customise the shape of the wave with the below properties\n\t\t\tself.MinTransparency, self.MaxTransparency = 0, 1 --See https://www.desmos.com/calculator/hg5h4fpfim\n\t\t\tself.PulseSpeed = 2 --Bolt arrives at Attachment1 1/PulseSpeed seconds later. See https://www.desmos.com/calculator/hg5h4fpfim\n\t\t\tself.PulseLength = 1000000 --See https://www.desmos.com/calculator/hg5h4fpfim\n\t\t\tself.FadeLength = 0.2 --See https://www.desmos.com/calculator/hg5h4fpfim\n\t\t\tself.ContractFrom = 0.5 --Parts shorten or grow once their Transparency exceeds this value. Set to a value above 1 to turn effect off. See https://imgur.com/OChA441\n\t\n\t\t--Bolt Color Properties--\n\t\t\tself.Color = Color3.new(1, 1, 1) --Can be a Color3 or ColorSequence\n\t\t\tself.ColorOffsetSpeed = 3 --Sets speed at which ColorSequence travels along Bolt\n\t\n\t--\n\t\n\tself.Parts = {} --The BoltParts which make up the Bolt\n\t\n\t\n\tlocal a0, a1 = Attachment0, Attachment1\n\tlocal parent = workspace.CurrentCamera\n\tlocal p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*self.CurveSize0, a1.WorldPosition - a1.WorldAxis*self.CurveSize1, a1.WorldPosition\n\tlocal PrevPoint, bezier0 = p0, p0\n\tlocal MainBranchN = PartCount or 30\n\t\n\tfor i = 1, MainBranchN do\n\t\tlocal t1 = i/MainBranchN\n\t\tlocal bezier1 = CubicBezier(p0, p1, p2, p3, t1)\n\t\tlocal NextPoint = i ~= MainBranchN and (CFrame.lookAt(bezier0, bezier1)).Position or bezier1\n\t\tlocal BPart = BoltPart:Clone()\n\t\tBPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, 0, 0)\n\t\tBPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse\n\t\tBPart.Parent = parent\n\t\tBPart.Locked, BPart.CastShadow = true, false\n\t\tself.Parts[i] = BPart\n\t\tPrevPoint, bezier0 = NextPoint, bezier1\n\tend\n\t\n\tself.PartsHidden = false\n\tself.DisabledTransparency = 1\n\tself.StartT = clock()\n\tself.RanNum = math.random()*100\n\tself.RefIndex = #ActiveBranches + 1\n\t\n\tActiveBranches[self.RefIndex] = self\n\t\n\treturn self\nend\n\nfunction LightningBolt:Destroy()\n\tActiveBranches[self.RefIndex] = nil\n\t\n\tfor i = 1, #self.Parts do\n\t\tself.Parts[i]:Destroy()\n\t\t\n\t\tif i%100 == 0 then wait() end\n\tend\n\t\n\tself = nil\nend\n\nlocal offsetAngle = math.cos(math.rad(90))\n\ngame:GetService(\"RunService\").Heartbeat:Connect(function ()\n\t\n\tfor _, ThisBranch in pairs(ActiveBranches) do\n\t\tif ThisBranch.Enabled == true then\n\t\t\tThisBranch.PartsHidden = false\n\t\t\tlocal MinOpa, MaxOpa = 1 - ThisBranch.MaxTransparency, 1 - ThisBranch.MinTransparency\n\t\t\tlocal MinRadius, MaxRadius = ThisBranch.MinRadius, ThisBranch.MaxRadius\n\t\t\tlocal thickness = ThisBranch.Thickness\n\t\t\tlocal Parts = ThisBranch.Parts\n\t\t\tlocal PartsN = #Parts\n\t\t\tlocal RanNum = ThisBranch.RanNum\n\t\t\tlocal StartT = ThisBranch.StartT\n\t\t\tlocal spd = ThisBranch.AnimationSpeed\n\t\t\tlocal freq = ThisBranch.Frequency\n\t\t\tlocal MinThick, MaxThick = ThisBranch.MinThicknessMultiplier, ThisBranch.MaxThicknessMultiplier\n\t\t\tlocal a0, a1, CurveSize0, CurveSize1 = ThisBranch.Attachment0, ThisBranch.Attachment1, ThisBranch.CurveSize0, ThisBranch.CurveSize1\n\t\t\tlocal p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*CurveSize0, a1.WorldPosition - a1.WorldAxis*CurveSize1, a1.WorldPosition\n\t\t\tlocal timePassed = clock() - StartT\n\t\t\tlocal PulseLength, PulseSpeed, FadeLength = ThisBranch.PulseLength, ThisBranch.PulseSpeed, ThisBranch.FadeLength\n\t\t\tlocal Color = ThisBranch.Color\n\t\t\tlocal ColorOffsetSpeed = ThisBranch.ColorOffsetSpeed\n\t\t\tlocal contractf = 1 - ThisBranch.ContractFrom\n\t\t\tlocal PrevPoint, bezier0 = p0, p0\n\t\t\t\n\t\t\tif timePassed < (PulseLength + 1) / PulseSpeed then\n\t\t\t\t\n\t\t\t\tfor i = 1, PartsN do\n\t\t\t\t\t--local spd = NoiseBetween(i/PartsN, 1.5, 0.1*i/PartsN, -MinAnimationSpeed, MaxAnimationSpeed) --Can enable to have an alternative animation which doesn't shift the noisy lightning \"Texture\" along the bolt\n\t\t\t\t\tlocal BPart = Parts[i]\n\t\t\t\t\tlocal t1 = i/PartsN\n\t\t\t\t\tlocal Opacity = DiscretePulse(t1, PulseSpeed, PulseLength, FadeLength, timePassed, MinOpa, MaxOpa)\n\t\t\t\t\tlocal bezier1 = CubicBezier(p0, p1, p2, p3, t1)\n\t\t\t\t\tlocal time = -timePassed --minus to ensure bolt waves travel from a0 to a1\n\t\t\t\t\tlocal input, input2 = (spd*time) + freq*10*t1 - 0.2 + RanNum*4, 5*((spd*0.01*time) / 10 + freq*t1) + RanNum*4\n\t\t\t\t\tlocal noise0 = NoiseBetween(5*input, 1.5, 5*0.2*input2, 0, 0.1*2*math.pi) + NoiseBetween(0.5*input, 1.5, 0.5*0.2*input2, 0, 0.9*2*math.pi)\n\t\t\t\t\tlocal noise1 = NoiseBetween(3.4, input2, input, MinRadius, MaxRadius)*math.exp(-5000*(t1 - 0.5)^10)\n\t\t\t\t\tlocal thicknessNoise = NoiseBetween(2.3, input2, input, MinThick, MaxThick)\n\t\t\t\t\tlocal NextPoint = i ~= PartsN and (CFrame.new(bezier0, bezier1)*CFrame.Angles(0, 0, noise0)*CFrame.Angles(math.acos(math.clamp(NoiseBetween(input2, input, 2.7, offsetAngle, 1), -1, 1)), 0, 0)*CFrame.new(0, 0, -noise1)).Position or bezier1\n\t\t\t\t\t\n\t\t\t\t\tif Opacity > contractf then\n\t\t\t\t\t\tBPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)\n\t\t\t\t\t\tBPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse\n\t\t\t\t\t\tBPart.Transparency = 1 - Opacity\n\t\t\t\t\telseif Opacity > contractf - 1/(PartsN*FadeLength) then\n\t\t\t\t\t\tlocal interp = (1 - (Opacity - (contractf - 1/(PartsN*FadeLength)))*PartsN*FadeLength)*(t1 < timePassed*PulseSpeed - 0.5*PulseLength and 1 or -1)\n\t\t\t\t\t\tBPart.Size = Vector3.new((1 - math.abs(interp))*(NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)\n\t\t\t\t\t\tBPart.CFrame = CFrame.lookAt(PrevPoint + (NextPoint - PrevPoint)*(math.max(0, interp) + 0.5*(1 - math.abs(interp))), NextPoint)*xInverse\n\t\t\t\t\t\tBPart.Transparency = 1 - Opacity\n\t\t\t\t\telse\n\t\t\t\t\t\tBPart.Transparency = 1\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif typeof(Color) == \"Color3\" then\n\t\t\t\t\t\tBPart.Color = Color\n\t\t\t\t\telse --ColorSequence\n\t\t\t\t\t\tt1 = (RanNum + t1 - timePassed*ColorOffsetSpeed)%1\n\t\t\t\t\t\tlocal keypoints = Color.Keypoints \n\t\t\t\t\t\tfor i = 1, #keypoints - 1 do --convert colorsequence onto lightning\n\t\t\t\t\t\t\tif keypoints[i].Time < t1 and t1 < keypoints[i+1].Time then\n\t\t\t\t\t\t\t\tBPart.Color = keypoints[i].Value:lerp(keypoints[i+1].Value, (t1 - keypoints[i].Time)/(keypoints[i+1].Time - keypoints[i].Time))\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tPrevPoint, bezier0 = NextPoint, bezier1\n\t\t\t\tend\n\t\t\t\t\n\t\t\telse\n\t\t\t\t\n\t\t\t\tThisBranch:Destroy()\n\t\t\t\t\n\t\t\tend\n\t\t\t\n\t\telse --Enabled = false\n\t\t\t\n\t\t\tif ThisBranch.PartsHidden == false then\n\t\t\t\tThisBranch.PartsHidden = true\n\t\t\t\tlocal datr = ThisBranch.DisabledTransparency\n\t\t\t\tfor i = 1, #ThisBranch.Parts do\n\t\t\t\t\tThisBranch.Parts[i].Transparency = datr\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\tend\n\tend\n\t\nend)\n\nreturn LightningBolt",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: LightningBolt)>"
}