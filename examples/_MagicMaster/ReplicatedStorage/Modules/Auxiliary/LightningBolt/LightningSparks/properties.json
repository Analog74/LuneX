{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: LightningSparks)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: LightningSparks)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: LightningSparks)>",
  "Sandboxed": false,
  "ScriptGuid": "{67C053BC-870B-477A-85E4-E8AFA8A6F627}",
  "Source": "--Adds sparks effect to a Lightning Bolt\nlocal LightningBolt = require(script.Parent)\n\nlocal ActiveSparks = {}\n\n\nlocal rng = Random.new()\nlocal LightningSparks = {}\nLightningSparks.__index = LightningSparks\n\nfunction LightningSparks.new(LightningBolt, MaxSparkCount)\n\tlocal self = setmetatable({}, LightningSparks)\n\t\n\t--Main (default) properties--\n\t\n\t\tself.Enabled = true --Stops spawning sparks when false\n\t\tself.LightningBolt = LightningBolt --Bolt which sparks fly out of\n\t\tself.MaxSparkCount = MaxSparkCount or 10 --Max number of sparks visible at any given instance\n\t\tself.MinSpeed, self.MaxSpeed = 4, 6 --Min and max PulseSpeeds of sparks\n\t\tself.MinDistance, self.MaxDistance = 3, 6 --Governs how far sparks travel away from main bolt\n\t\tself.MinPartsPerSpark, self.MaxPartsPerSpark = 8, 10 --Adjustable\n\t\n\t--\n\t\n\tself.SparksN = 0\n\tself.SlotTable = {}\n\tself.RefIndex = #ActiveSparks + 1\n\t\n\tActiveSparks[self.RefIndex] = self\n\t\n\treturn self\nend\n\nfunction LightningSparks:Destroy()\n\tActiveSparks[self.RefIndex] = nil\n\t\n\tfor i, v in pairs(self.SlotTable) do\n\t\tif v.Parts[1].Parent == nil then\n\t\t\tself.SlotTable[i] = nil --Removes reference to prevent memory leak\n\t\tend\n\tend\n\t\n\tself = nil\nend\n\nfunction RandomVectorOffset(v, maxAngle) --returns uniformly-distributed random unit vector no more than maxAngle radians away from v\n    return (CFrame.lookAt(Vector3.new(), v)*CFrame.Angles(0, 0, rng:NextNumber(0, 2*math.pi))*CFrame.Angles(math.acos(rng:NextNumber(math.cos(maxAngle), 1)), 0, 0)).LookVector\nend \n\ngame:GetService(\"RunService\").Heartbeat:Connect(function ()\n\t\n\tfor _, ThisSpark in pairs(ActiveSparks) do\n\t\t\n\t\tif ThisSpark.Enabled == true and ThisSpark.SparksN < ThisSpark.MaxSparkCount then\n\t\t\t\n\t\t\tlocal Bolt = ThisSpark.LightningBolt\n\t\t\t\n\t\t\tif Bolt.Parts[1].Parent == nil then\n\t\t\t\tThisSpark:Destroy()\n\t\t\t\treturn \n\t\t\tend\n\t\t\t\n\t\t\tlocal BoltParts = Bolt.Parts\n\t\t\tlocal BoltPartsN = #BoltParts\n\t\t\t\t\n\t\t\tlocal opaque_parts = {}\n\t\t\t\n\t\t\tfor part_i = 1, #BoltParts do --Fill opaque_parts table\n\t\t\t\t\n\t\t\t\tif BoltParts[part_i].Transparency < 0.3 then --minimum opacity required to be able to generate a spark there\n\t\t\t\t\topaque_parts[#opaque_parts + 1] = (part_i - 0.5) / BoltPartsN\n\t\t\t\tend\n\t\t\t\t\n\t\t\tend\n\t\t\t\n\t\t\tlocal minSlot, maxSlot \n\t\t\t\n\t\t\tif #opaque_parts ~= 0 then\n\t\t\t\tminSlot, maxSlot = math.ceil(opaque_parts[1]*ThisSpark.MaxSparkCount), math.ceil(opaque_parts[#opaque_parts]*ThisSpark.MaxSparkCount)\n\t\t\tend\n\t\t\t\n\t\t\tfor _ = 1, rng:NextInteger(1, ThisSpark.MaxSparkCount - ThisSpark.SparksN) do\n\t\t\t\t\n\t\t\t\tif #opaque_parts == 0 then break end\n\t\t\t\t\n\t\t\t\tlocal available_slots = {}\n\t\t\t\t\n\t\t\t\tfor slot_i = minSlot, maxSlot do --Fill available_slots table\n\t\t\t\t\t\n\t\t\t\t\tif ThisSpark.SlotTable[slot_i] == nil then --check slot doesn't have existing spark\n\t\t\t\t\t\tavailable_slots[#available_slots + 1] = slot_i\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif #available_slots ~= 0 then \n\t\t\t\t\t\n\t\t\t\t\tlocal ChosenSlot = available_slots[rng:NextInteger(1, #available_slots)]\n\t\t\t\t\tlocal localTrng = rng:NextNumber(-0.5, 0.5)\n\t\t\t\t\tlocal ChosenT = (ChosenSlot - 0.5 + localTrng)/ThisSpark.MaxSparkCount\n\t\t\t\t\t\n\t\t\t\t\tlocal dist, ChosenPart = 10, 1\n\t\t\t\t\t\n\t\t\t\t\tfor opaque_i = 1, #opaque_parts do\n\t\t\t\t\t\tlocal testdist = math.abs(opaque_parts[opaque_i] - ChosenT)\n\t\t\t\t\t\tif testdist < dist then\n\t\t\t\t\t\t\tdist, ChosenPart = testdist, math.floor((opaque_parts[opaque_i]*BoltPartsN + 0.5) + 0.5)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tlocal Part = BoltParts[ChosenPart]\n\t\t\t\t\t\n\t\t\t\t\t--Make new spark--\n\t\t\t\t\t\n\t\t\t\t\tlocal A1, A2 = {}, {}\n\t\t\t\t\tA1.WorldPosition = Part.Position + localTrng*Part.CFrame.RightVector*Part.Size.X\n\t\t\t\t\tA2.WorldPosition = A1.WorldPosition + RandomVectorOffset(Part.CFrame.RightVector, math.pi/4)*rng:NextNumber(ThisSpark.MinDistance, ThisSpark.MaxDistance)\n\t\t\t\t\tA1.WorldAxis = (A2.WorldPosition - A1.WorldPosition).Unit\n\t\t\t\t\tA2.WorldAxis = A1.WorldAxis\n\t\t\t\t\tlocal NewSpark = LightningBolt.new(A1, A2, rng:NextInteger(ThisSpark.MinPartsPerSpark, ThisSpark.MaxPartsPerSpark))\n\t\t\t\t\t\n\t\t\t\t\t--NewSpark.MaxAngleOffset = math.rad(70)\n\t\t\t\t\tNewSpark.MinRadius, NewSpark.MaxRadius = 0, 0.8\n\t\t\t\t\tNewSpark.AnimationSpeed = 0\n\t\t\t\t\tNewSpark.Thickness = Part.Size.Y / 2\n\t\t\t\t\tNewSpark.MinThicknessMultiplier, NewSpark.MaxThicknessMultiplier = 1, 1\n\t\t\t\t\tNewSpark.PulseLength = 0.5\n\t\t\t\t\tNewSpark.PulseSpeed = rng:NextNumber(ThisSpark.MinSpeed, ThisSpark.MaxSpeed)\n\t\t\t\t\tNewSpark.FadeLength = 0.25\n\t\t\t\t\tlocal cH, cS, cV = Color3.toHSV(Part.Color)\n\t\t\t\t\tNewSpark.Color = Color3.fromHSV(cH, 0.5, cV)\n\t\t\t\t\t\n\t\t\t\t\tThisSpark.SlotTable[ChosenSlot] = NewSpark\n\t\t\t\t\t\n\t\t\t\t\t--\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\tend\n\t\t\t\n\t\tend\n\t\t\n\t\t\n\t\t\n\t\t--Update SparksN--\n\t\t\n\t\tlocal slotsInUse = 0\n\t\t\n\t\tfor i, v in pairs(ThisSpark.SlotTable) do\n\t\t\tif v.Parts[1].Parent ~= nil then\n\t\t\t\tslotsInUse = slotsInUse + 1\n\t\t\telse\n\t\t\t\tThisSpark.SlotTable[i] = nil --Removes reference to prevent memory leak\n\t\t\tend\n\t\tend\n\t\t\n\t\tThisSpark.SparksN = slotsInUse\n\t\t\n\t\t--\n\tend\n\t\nend)\n\nreturn LightningSparks",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: LightningSparks)>"
}