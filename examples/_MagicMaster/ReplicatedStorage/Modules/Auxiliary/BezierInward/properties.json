{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: BezierInward)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: BezierInward)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: BezierInward)>",
  "Sandboxed": false,
  "ScriptGuid": "{92b029ef-ca1e-4556-a324-593d946f0449}",
  "Source": "-- Localization\nlocal Random = Random.new()\n\n-- Services\nlocal ReplicatedStorage = game:GetService('ReplicatedStorage')\nlocal ServerScriptService = game:GetService('ServerScriptService')\n\nlocal RunService = game:GetService('RunService')\n\n-- Modules\nlocal ServerModules = ServerScriptService:WaitForChild('Modules')\nlocal Bezier = require(ServerModules.Bezier)\nlocal MockPart = require(ServerModules.MockPart)\n\n-- Auxiliary functons\nlocal DisconnectConnections = function( Connections )\n\tfor _, v in ipairs( Connections ) do\n\t\tv:Disconnect()\n\tend\nend\n\nlocal InwardBezierModule = { }\nInwardBezierModule.Connections = { }\n\nInwardBezierModule.Init = function( Part, Properties )\n\ttable.insert( InwardBezierModule.Connections, Part )\n\t\n\t-- Attributes / Properties\n\tlocal Speed = Properties.Speed or 2\t\t-- How fast the charging parts go in the main part.\n\tlocal Radius = Properties.Radius or 10\t    -- How wide the spawning area of the curving parts are.\n\tlocal Interval = Properties.Interval or 0.1\t-- Interval per part spawn in seconds\n\tlocal Index = Properties.Index or math.huge -- How many parts will spawn?\n\tlocal SpeedMultiplier = Properties.SpeedMultiplier or 1\t-- The speed is multiplied by the SpeedMultiplier, can be random.\n\tlocal Curveffset = Properties.CurveOffset or 5 -- The offset of the curvature.\n\t\n\t-- Start the charging effect.\n\tfor _ = 1, Index do\n\t\tif not table.find( InwardBezierModule.Connections, Part ) then break end\n\t\t\n\t\t-- Default values for curve offset\n\t\tlocal DefaultCurveOffset = Vector3.new(Random:NextNumber(-Curveffset, Curveffset), Random:NextNumber(-Curveffset,Curveffset), Random:NextNumber(-Curveffset, Curveffset)) or Vector3.new(Random:NextNumber(-15, 15), Random:NextNumber(-5, 10), Random:NextNumber(-15, 15))\t-- Default values to be input in curve offset if property CurveOffset is not passed.\n\t\t\n\t\tlocal Offset = CFrame.new(Random:NextNumber(-Radius, Radius), Random:NextNumber(-Radius, Radius), Random:NextNumber(-Radius, Radius))\t-- Offset of the parts from center determined by the radius.\n\t\tlocal CurveOffset = DefaultCurveOffset -- Determines the path of the bezier curve.\n\t\t\n\t\tlocal MockPart = MockPart(Part.CFrame * Offset) -- Create an invisible part server-side\n\t\tMockPart.Name = 'ClientInward'\n\t\t\n\t\t-- Map the start, end and midpoint positions for the motion.\n\t\tlocal Start = MockPart.CFrame\n\t\tlocal End = Part.CFrame\n\t\tlocal Midpoint = Start.Position:Lerp(End.Position, 0.5) + CurveOffset\n\t\t\n\t\tlocal Connection\n\t\tlocal Elapsed = 0\n\t\t\n\t\tConnection = RunService.Heartbeat:Connect(function(Delta)\n\t\t\tElapsed += Delta * ( Speed * SpeedMultiplier )\n\t\t\t\n\t\t\tlocal Curve = Bezier.QuadBezier(Elapsed, Start.Position, Midpoint, End.Position)\n\t\t\t\n\t\t\tif ( Elapsed >= 1 ) then\n\t\t\t\tMockPart.Position = End.Position\n\t\t\t\tMockPart:Destroy()\n\t\t\t\tConnection:Disconnect()\n\t\t\t\treturn\n\t\t\telse\n\t\t\t\tMockPart.Position = Curve\n\t\t\tend\n\t\tend)\n\t\t\n\t\ttask.wait(Interval)\n\tend\nend\n\nInwardBezierModule.Deinit = function( Part )\n\tfor Index, Key in ipairs( InwardBezierModule.Connections ) do\n\t\tif Key == Part then\n\t\t\tprint('Removed connection.')\n\t\t\ttable.remove(InwardBezierModule.Connections, Index)\n\t\tend\n\tend\nend\n\nreturn InwardBezierModule",
  "SourceAssetId": -1,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: BezierInward)>"
}