{
  "Attributes": {},
  "Capabilities": "<FAILED: Unsupported variant type: Discriminant(37) (property: Capabilities, class: ModuleScript, instance: ProfileService)>",
  "HistoryId": "<FAILED: Unsupported variant type: Discriminant(35) (property: HistoryId, class: ModuleScript, instance: ProfileService)>",
  "LinkedSource": "<FAILED: Unsupported variant type: Discriminant(8) (property: LinkedSource, class: ModuleScript, instance: ProfileService)>",
  "Sandboxed": false,
  "ScriptGuid": "{7BC1CC88-ED61-4FAC-8799-DB903C8701A2}",
  "Source": "-- local Madwork = _G.Madwork\n--[[\n{Madwork}\n\n-[ProfileService]---------------------------------------\n\t(STANDALONE VERSION)\n\tDataStore profiles - universal session-locked savable table API\n\t\n\tOfficial documentation:\n\t\thttps://madstudioroblox.github.io/ProfileService/\n\n\tDevForum discussion:\n\t\thttps://devforum.roblox.com/t/ProfileService/667805\n\t\n\tWARNINGS FOR \"Profile.Data\" VALUES:\n\t \t! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;\n\t\t! Do not create mixed tables (some values indexed by number and others by string key), as only\n\t\t     the data indexed by number will be replicated.\n\t\t! Do not index tables by anything other than numbers and strings.\n\t\t! Do not reference Roblox Instances\n\t\t! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing\n\t\t! Do not reference functions\n\t\t\n\tWARNING: Calling ProfileStore:LoadProfileAsync() with a \"profile_key\" which wasn't released in the SAME SESSION will result\n\t\tin an error! If you want to \"ProfileStore:LoadProfileAsync()\" instead of using the already loaded profile, :Release()\n\t\tthe old Profile object.\n\t\t\n\tMembers:\n\t\n\t\tProfileService.ServiceLocked         [bool]\n\t\t\n\t\tProfileService.IssueSignal           [ScriptSignal](error_message, profile_store_name, profile_key)\n\t\tProfileService.CorruptionSignal      [ScriptSignal](profile_store_name, profile_key)\n\t\tProfileService.CriticalStateSignal   [ScriptSignal](is_critical_state)\n\t\n\tFunctions:\n\t\n\t\tProfileService.GetProfileStore(profile_store_name, profile_template) --> [ProfileStore]\n\t\t\t-- WARNING: Only one ProfileStore can exist for a given profile_store_name in a game session!\n\t\t\n\t\t* Parameter description for \"ProfileService.GetProfileStore()\":\n\t\t\n\t\t\tprofile_store_name   [string] -- DataStore name\n\t\t\tprofile_template     []:\n\t\t\t\t{}                        [table] -- Profiles will default to given table (hard-copy) when no data was saved previously\n\t\t\t\t\n\tMembers [ProfileStore]:\n\t\n\t\tProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore\n\t\t\n\tMethods [ProfileStore]:\n\t\n\t\tProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile / nil] not_released_handler(place_id, game_job_id)\n\t\tProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))\n\t\t\t-- Returns GlobalUpdates object if update was successful, otherwise returns nil\n\t\t\n\t\tProfileStore:ViewProfileAsync(profile_key) --> [Profile / nil] -- Notice #1: Profile object methods will not be available;\n\t\t\tNotice #2: Profile object members will be nil (Profile.Data = nil, Profile.MetaData = nil) if the profile hasn't\n\t\t\tbeen created, with the exception of Profile.GlobalUpdates which could be empty or populated by\n\t\t\tProfileStore:GlobalUpdateProfileAsync()\n\t\t\t\n\t\tProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool] -- Completely wipes out profile data from the\n\t\t\tDataStore / mock DataStore with no way to recover it.\n\t\t\n\t\t* Parameter description for \"ProfileStore:LoadProfileAsync()\":\n\t\t\n\t\t\tprofile_key            [string] -- DataStore key\n\t\t\tnot_released_handler = \"ForceLoad\" -- Force loads profile on first call\n\t\t\tOR\n\t\t\tnot_released_handler = \"Steal\" -- Steals the profile ignoring it's session lock\n\t\t\tOR\n\t\t\tnot_released_handler   [function] (place_id, game_job_id) --> [string] (\"Repeat\" / \"Cancel\" / \"ForceLoad\")\n\t\t\t\t-- \"not_released_handler\" will be triggered in cases where the profile is not released by a session. This\n\t\t\t\tfunction may yield for as long as desirable and must return one of three string values:\n\t\t\t\t\t[\"Repeat\"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again\n\t\t\t\t\t[\"Cancel\"] - ProfileStore:LoadProfileAsync() will immediately return nil\n\t\t\t\t\t[\"ForceLoad\"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards\n\t\t\t\t\t\tand release the profile for another session that has loaded the profile\n\t\t\t\t\t[\"Steal\"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying\n\t\t\t\t\t\ta session lock for this session.\n\t\t\t\t\t\t\n\t\t* Parameter description for \"ProfileStore:GlobalUpdateProfileAsync()\":\n\t\t\n\t\t\tprofile_key      [string] -- DataStore key\n\t\t\tupdate_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods\n\t\t\t\t(update_handler can't yield)\n\t\t\n\tMembers [Profile]:\n\t\n\t\tProfile.Data            [table] -- Writable table that gets saved automatically and once the profile is released\n\t\tProfile.MetaData        [table] (Read-only) -- Information about this profile\n\t\t\n\t\t\tProfile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation\n\t\t\tProfile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded\n\t\t\tProfile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a\n\t\t\t\tgame session is currently having this profile loaded; nil if released\n\t\t\tProfile.MetaData.MetaTags            [table] {[\"tag_name\"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data\n\t\t\tProfile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore\n\t\t\t\t(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after\n\t\t\t\tthey pile up)\n\t\t\n\t\tProfile.GlobalUpdates   [GlobalUpdates]\n\t\t\n\tMethods [Profile]:\n\t\n\t\t-- SAFE METHODS - Will not error after profile expires:\n\t\tProfile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to\n\t\t\t\n\t\tProfile:GetMetaTag(tag_name) --> value\n\t\t\n\t\tProfile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure\n\t\t\n\t\tProfile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil) -- WARNING: Profiles can be released externally if another session\n\t\t\tforce-loads this profile - use :ListenToRelease() to handle player leaving cleanup.\n\t\t\t\n\t\tProfile:Release() -- Call after the session has finished working with this profile\n\t\t\te.g., after the player leaves (Profile object will become expired) (Does not yield)\n\t\t\n\t\t-- DANGEROUS METHODS - Will error if the profile is expired:\n\t\t-- MetaTags - Save and read values stored in Profile.MetaData for storing info about the\n\t\t\tprofile itself like \"Profile:SetMetaTag(\"FirstTimeLoad\", true)\"\n\t\tProfile:SetMetaTag(tag_name, value)\n\t\t\n\t\tProfile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)\n\n\t\t\n\tMethods [GlobalUpdates]:\n\t\n\t-- ALWAYS PUBLIC:\n\t\tGlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}\n\t\tGlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}\n\t\t\n\t-- ONLY WHEN FROM \"Profile.GlobalUpdates\":\n\t\tGlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)\n\t\tGlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)\n\t\t-- WARNING: GlobalUpdates:LockUpdate() and GlobalUpdates:ClearLockedUpdate() will error after profile expires\n\t\tGlobalUpdates:LockActiveUpdate(update_id)\n\t\tGlobalUpdates:ClearLockedUpdate(update_id)\n\t\t\n\t-- EXPOSED TO \"update_handler\" DURING ProfileStore:GlobalUpdateProfileAsync() CALL\n\t\tGlobalUpdates:AddActiveUpdate(update_data)\n\t\tGlobalUpdates:ChangeActiveUpdate(update_id, update_data)\n\t\tGlobalUpdates:ClearActiveUpdate(update_id)\n\t\t\n--]]\n\nlocal SETTINGS = {\n\n\tAutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)\n\tLoadProfileRepeatDelay = 15, -- Seconds between successive DataStore calls for the same key\n\tForceLoadMaxSteps = 4, -- Steps taken before ForceLoad request steals the active session for a profile\n\tAssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead\n\t-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.\n\n\tIssueCountForCriticalState = 5, -- Issues to collect to announce critical state\n\tIssueLast = 120, -- Seconds\n\tCriticalStateLast = 120, -- Seconds\n\n}\n\nlocal Madwork -- Standalone Madwork reference for portable version of ProfileService\ndo\n\t-- ScriptConnection object:\n\tlocal ScriptConnection = {\n\t\t-- _listener = function -- [function]\n\t\t-- _listener_table = {} -- [table] -- Table from which the function entry will be removed\n\t}\n\n\tfunction ScriptConnection:Disconnect()\n\t\tlocal listener = self._listener\n\t\tif listener ~= nil then\n\t\t\tlocal listener_table = self._listener_table\n\t\t\tfor i = 1, #listener_table do\n\t\t\t\tif listener == listener_table[i] then\n\t\t\t\t\ttable.remove(listener_table, i)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tself._listener = nil\n\t\tend\n\tend\n\n\tfunction ScriptConnection.NewArrayScriptConnection(listener_table, listener) --> [ScriptConnection]\n\t\treturn {\n\t\t\t_listener = listener,\n\t\t\t_listener_table = listener_table,\n\t\t\tDisconnect = ScriptConnection.Disconnect\n\t\t}\n\tend\n\n\t-- ScriptSignal object:\n\tlocal ScriptSignal = {\n\t\t-- _listeners = {}\n\t}\n\n\tfunction ScriptSignal:Connect(listener) --> [ScriptConnection]\n\t\tif type(listener) ~= \"function\" then\n\t\t\terror(\"[ScriptSignal]: Only functions can be passed to ScriptSignal:Connect()\")\n\t\tend\n\t\ttable.insert(self._listeners, listener)\n\t\treturn {\n\t\t\t_listener = listener,\n\t\t\t_listener_table = self._listeners,\n\t\t\tDisconnect = ScriptConnection.Disconnect\n\t\t}\n\tend\n\n\tfunction ScriptSignal:Fire(...)\n\t\tfor _, listener in ipairs(self._listeners) do\n\t\t\tlistener(...)\n\t\tend\n\tend\n\n\tfunction ScriptSignal.NewScriptSignal() --> [ScriptSignal]\n\t\treturn {\n\t\t\t_listeners = {},\n\t\t\tConnect = ScriptSignal.Connect,\n\t\t\tFire = ScriptSignal.Fire\n\t\t}\n\tend\n\n\tlocal RunService = game:GetService(\"RunService\")\n\tlocal Heartbeat = RunService.Heartbeat\n\n\tMadwork = {\n\t\tNewScriptSignal = ScriptSignal.NewScriptSignal,\n\t\tNewArrayScriptConnection = ScriptConnection.NewArrayScriptConnection,\n\t\tHeartbeatWait = function(wait_time) --> time_elapsed\n\t\t\tif wait_time == nil or wait_time == 0 then\n\t\t\t\treturn Heartbeat:Wait()\n\t\t\telse\n\t\t\t\tlocal time_elapsed = 0\n\t\t\t\twhile time_elapsed <= wait_time do\n\t\t\t\t\tlocal time_waited = Heartbeat:Wait()\n\t\t\t\t\ttime_elapsed = time_elapsed + time_waited\n\t\t\t\tend\n\t\t\t\treturn time_elapsed\n\t\t\tend\n\t\tend,\n\t\tConnectToOnClose = function(task, run_in_studio_mode)\n\t\t\tif game:GetService(\"RunService\"):IsStudio() == false or run_in_studio_mode == true then\n\t\t\t\tgame:BindToClose(task)\n\t\t\tend\n\t\tend,\n\t}\nend\n\n----- Service Table -----\n\nlocal ProfileService = {\n\n\tServiceLocked = false, -- Set to true once the server is shutting down\n\n\tIssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error\n\tCorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has\n\t-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value\n\n\tCriticalState = false, -- Set to true while DataStore service is throwing too many errors\n\tCriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true\n\t-- (You may alert players with this, or set up analytics)\n\n\tServiceIssueCount = 0,\n\n\t_active_profile_stores = {\n\t\t--[[\n\t\t\t{\n\t\t\t\t_profile_store_name = \"\", -- [string] -- DataStore name\n\t\t\t\t_profile_template = {} / nil, -- [table / nil]\n\t\t\t\t_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)\n\t\t\t\t\n\t\t\t\t_loaded_profiles = {\n\t\t\t\t\t[profile_key] = {\n\t\t\t\t\t\tData = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes\n\t\t\t\t\t\tMetaData = {}, -- [table] -- Updated with every auto-save\n\t\t\t\t\t\tGlobalUpdates = {, -- [GlobalUpdates]\n\t\t\t\t\t\t\t_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\t\t\t\t\t\t\t_pending_update_lock = {update_id, ...} / nil, -- [table / nil]\n\t\t\t\t\t\t\t_pending_update_clear = {update_id, ...} / nil, -- [table / nil]\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t_new_active_update_listeners = {listener, ...} / nil, -- [table / nil]\n\t\t\t\t\t\t\t_new_locked_update_listeners = {listener, ...} / nil, -- [table / nil]\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t_profile = Profile / nil, -- [Profile / nil]\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t_update_handler_mode = true / nil, -- [bool / nil]\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t_profile_store = ProfileStore, -- [ProfileStore]\n\t\t\t\t\t\t_profile_key = \"\", -- [string]\n\t\t\t\t\t\t\n\t\t\t\t\t\t_release_listeners = {listener, ...} / nil, -- [table / nil]\n\t\t\t\t\t\t\n\t\t\t\t\t\t_view_mode = true / nil, -- [bool / nil]\n\t\t\t\t\t\t\n\t\t\t\t\t\t_load_timestamp = os.clock(),\n\t\t\t\t\t\t\n\t\t\t\t\t\t_is_user_mock = false, -- ProfileStore.Mock\n\t\t\t\t\t},\n\t\t\t\t\t...\n\t\t\t\t},\n\t\t\t\t_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},\n\t\t\t\t\n\t\t\t\t_mock_loaded_profiles = {[profile_key] = Profile, ...},\n\t\t\t\t_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},\n\t\t\t\t_is_pending = false, -- Waiting for live access check\n\t\t\t},\n\t\t\t...\n\t\t--]]\n\t},\n\n\t_auto_save_list = { -- loaded profile table which will be circularly auto-saved\n\t\t--[[\n\t\t\tProfile,\n\t\t\t...\n\t\t--]]\n\t},\n\n\t_issue_queue = {}, -- [table] {issue_time, ...}\n\t_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start\n\n\t-- Debug:\n\t_mock_data_store = {},\n\t_user_mock_data_store = {},\n\n\t_use_mock_data_store = false,\n\n}\n\n--[[\n\tSaved profile structure:\n\t\n\tDataStoreProfile = {\n\t\tData = {},\n\t\tMetaData = {\n\t\t\tProfileCreateTime = 0,\n\t\t\tSessionLoadCount = 0,\n\t\t\tActiveSession = {place_id, game_job_id} / nil,\n\t\t\tForceLoadSession = {place_id, game_job_id} / nil,\n\t\t\tMetaTags = {},\n\t\t\tLastUpdate = 0, -- os.time()\n\t\t},\n\t\tGlobalUpdates = {\n\t\t\tupdate_index,\n\t\t\t{\n\t\t\t\t{update_id, version_id, update_locked, update_data},\n\t\t\t\t...\n\t\t\t}\n\t\t},\n\t}\n\t\n\tOR\n\t\n\tDataStoreProfile = {\n\t\tGlobalUpdates = {\n\t\t\tupdate_index,\n\t\t\t{\n\t\t\t\t{update_id, version_id, update_locked, update_data},\n\t\t\t\t...\n\t\t\t}\n\t\t},\n\t}\n--]]\n\n----- Private Variables -----\n\nlocal ActiveProfileStores = ProfileService._active_profile_stores\nlocal AutoSaveList = ProfileService._auto_save_list\nlocal IssueQueue = ProfileService._issue_queue\n\nlocal DataStoreService = game:GetService(\"DataStoreService\")\nlocal RunService = game:GetService(\"RunService\")\n\nlocal PlaceId = game.PlaceId\nlocal JobId = game.JobId\n\nlocal AutoSaveIndex = 1 -- Next profile to auto save\nlocal LastAutoSave = os.clock()\n\nlocal LoadIndex = 0\n\nlocal ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles\nlocal ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles\n\nlocal CriticalStateStart = 0 -- os.clock()\n\nlocal IsStudio = RunService:IsStudio()\nlocal IsLiveCheckActive = false\n\nlocal UseMockDataStore = false\nlocal MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled\n\nlocal UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock\nlocal UseMockTag = {}\n\n----- Utils -----\n\nlocal function DeepCopyTable(t)\n\tlocal copy = {}\n\tfor key, value in pairs(t) do\n\t\tif type(value) == \"table\" then\n\t\t\tcopy[key] = DeepCopyTable(value)\n\t\telse\n\t\t\tcopy[key] = value\n\t\tend\n\tend\n\treturn copy\nend\n\nlocal function ReconcileTable(target, template)\n\tfor k, v in pairs(template) do\n\t\tif type(k) == \"string\" then -- Only string keys will be reconciled\n\t\t\tif target[k] == nil then\n\t\t\t\tif type(v) == \"table\" then\n\t\t\t\t\ttarget[k] = DeepCopyTable(v)\n\t\t\t\telse\n\t\t\t\t\ttarget[k] = v\n\t\t\t\tend\n\t\t\telseif type(target[k]) == \"table\" and type(v) == \"table\" then\n\t\t\t\tReconcileTable(target[k], v)\n\t\t\tend\n\t\tend\n\tend\nend\n\n----- Private functions -----\n\nlocal function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required\n\twhile IsLiveCheckActive == true do\n\t\tMadwork.HeartbeatWait()\n\tend\nend\n\nlocal function WaitForPendingProfileStore(profile_store)\n\twhile profile_store._is_pending == true do\n\t\tMadwork.HeartbeatWait()\n\tend\nend\n\nlocal function RegisterIssue(error_message, profile_store_name, profile_key) -- Called when a DataStore API call errors\n\twarn(\"[ProfileService]: DataStore API error (Store:\\\"\" .. profile_store_name .. \"\\\";Key:\\\"\" .. profile_key .. \"\\\") - \\\"\" .. tostring(error_message) .. \"\\\"\")\n\ttable.insert(IssueQueue, os.clock()) -- Adding issue time to queue\n\tProfileService.IssueSignal:Fire(tostring(error_message), profile_store_name, profile_key)\nend\n\nlocal function RegisterCorruption(profile_store_name, profile_key) -- Called when a corrupted profile is loaded\n\twarn(\"[ProfileService]: Profile corruption - ProfileStore = \\\"\" .. profile_store_name .. \"\\\", Key = \\\"\" .. profile_key .. \"\\\"\")\n\tProfileService.CorruptionSignal:Fire(profile_store_name, profile_key)\nend\n\nlocal function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function)\n\tlocal profile_store = mock_data_store[profile_store_name]\n\tif profile_store == nil then\n\t\tprofile_store = {}\n\t\tmock_data_store[profile_store_name] = profile_store\n\tend\n\tlocal transform = transform_function(profile_store[key])\n\tif transform == nil then\n\t\treturn nil\n\telse\n\t\tprofile_store[key] = DeepCopyTable(transform)\n\t\treturn DeepCopyTable(profile_store[key])\n\tend\nend\n\nlocal function IsThisSession(session_tag)\n\treturn session_tag[1] == PlaceId and session_tag[2] == JobId\nend\n\n--[[\nupdate_settings = {\n\tExistingProfileHandle = function(latest_data),\n\tMissingProfileHandle = function(latest_data),\n\tEditProfile = function(lastest_data),\n\t\n\tWipeProfile = nil / true,\n}\n--]]\nlocal function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock)\n\tlocal loaded_data\n\tlocal wipe_status = false\n\tlocal success, error_message = pcall(function()\n\t\tif update_settings.WipeProfile ~= true then\n\t\t\tlocal transform_function = function(latest_data)\n\t\t\t\tif latest_data == \"PROFILE_WIPED\" then\n\t\t\t\t\tlatest_data = nil -- Profile was previously wiped - ProfileService will act like it was empty\n\t\t\t\tend\n\n\t\t\t\tlocal missing_profile = false\n\t\t\t\tlocal data_corrupted = false\n\t\t\t\tlocal global_updates_data = {0, {}}\n\n\t\t\t\tif latest_data == nil then\n\t\t\t\t\tmissing_profile = true\n\t\t\t\telseif type(latest_data) ~= \"table\" then\n\t\t\t\t\tmissing_profile = true\n\t\t\t\t\tdata_corrupted = true\n\t\t\t\tend\n\n\t\t\t\tif type(latest_data) == \"table\" then\n\t\t\t\t\t-- Case #1: Profile was loaded\n\t\t\t\t\tif type(latest_data.Data) == \"table\" and\n\t\t\t\t\t\ttype(latest_data.MetaData) == \"table\" and\n\t\t\t\t\t\ttype(latest_data.GlobalUpdates) == \"table\" then\n\n\t\t\t\t\t\tlatest_data.WasCorrupted = false -- Must be set to false if set previously\n\t\t\t\t\t\tglobal_updates_data = latest_data.GlobalUpdates\n\t\t\t\t\t\tif update_settings.ExistingProfileHandle ~= nil then\n\t\t\t\t\t\t\tupdate_settings.ExistingProfileHandle(latest_data)\n\t\t\t\t\t\tend\n\t\t\t\t\t\t-- Case #2: Profile was not loaded but GlobalUpdate data exists\n\t\t\t\t\telseif latest_data.Data == nil and\n\t\t\t\t\t\tlatest_data.MetaData == nil and\n\t\t\t\t\t\ttype(latest_data.GlobalUpdates) == \"table\" then\n\n\t\t\t\t\t\tlatest_data.WasCorrupted = false -- Must be set to false if set previously\n\t\t\t\t\t\tglobal_updates_data = latest_data.GlobalUpdates\n\t\t\t\t\t\tmissing_profile = true\n\t\t\t\t\telse\n\t\t\t\t\t\tmissing_profile = true\n\t\t\t\t\t\tdata_corrupted = true\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists\n\t\t\t\tif missing_profile == true then\n\t\t\t\t\tlatest_data = {\n\t\t\t\t\t\t-- Data = nil,\n\t\t\t\t\t\t-- MetaData = nil,\n\t\t\t\t\t\tGlobalUpdates = global_updates_data,\n\t\t\t\t\t}\n\t\t\t\t\tif update_settings.MissingProfileHandle ~= nil then\n\t\t\t\t\t\tupdate_settings.MissingProfileHandle(latest_data)\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t-- Editing profile:\n\t\t\t\tif update_settings.EditProfile ~= nil then\n\t\t\t\t\tupdate_settings.EditProfile(latest_data)\n\t\t\t\tend\n\n\t\t\t\t-- Data corruption handling (Silently override with empty profile) (Also run Case #1)\n\t\t\t\tif data_corrupted == true then\n\t\t\t\t\tlatest_data.WasCorrupted = true -- Temporary tag that will be removed on first save\n\t\t\t\tend\n\n\t\t\t\treturn latest_data\n\t\t\tend\n\t\t\tif is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock\n\t\t\t\tloaded_data = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_name, profile_key, transform_function)\n\t\t\t\tMadwork.HeartbeatWait() -- Simulate API call yield\n\t\t\telseif UseMockDataStore == true then -- Used when API access is disabled\n\t\t\t\tloaded_data = MockUpdateAsync(MockDataStore, profile_store._profile_store_name, profile_key, transform_function)\n\t\t\t\tMadwork.HeartbeatWait() -- Simulate API call yield\n\t\t\telse\n\t\t\t\tloaded_data = profile_store._global_data_store:UpdateAsync(profile_key, transform_function)\n\t\t\tend\n\t\telse\n\t\t\tif is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock\n\t\t\t\tlocal mock_data_store = UserMockDataStore[profile_store._profile_store_name]\n\t\t\t\tif mock_data_store ~= nil then\n\t\t\t\t\tmock_data_store[profile_key] = nil\n\t\t\t\tend\n\t\t\t\twipe_status = true\n\t\t\t\tMadwork.HeartbeatWait() -- Simulate API call yield\n\t\t\telseif UseMockDataStore == true then -- Used when API access is disabled\n\t\t\t\tlocal mock_data_store = MockDataStore[profile_store._profile_store_name]\n\t\t\t\tif mock_data_store ~= nil then\n\t\t\t\t\tmock_data_store[profile_key] = nil\n\t\t\t\tend\n\t\t\t\twipe_status = true\n\t\t\t\tMadwork.HeartbeatWait() -- Simulate API call yield\n\t\t\telse\n\t\t\t\tloaded_data = profile_store._global_data_store:UpdateAsync(profile_key, function()\n\t\t\t\t\treturn \"PROFILE_WIPED\" -- It's impossible to set DataStore keys to nil after they have been set\n\t\t\t\tend)\n\t\t\t\tif loaded_data == \"PROFILE_WIPED\" then\n\t\t\t\t\twipe_status = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)\n\tif update_settings.WipeProfile == true then\n\t\treturn wipe_status\n\telseif success == true and type(loaded_data) == \"table\" then\n\t\t-- Corruption handling:\n\t\tif loaded_data.WasCorrupted == true then\n\t\t\tRegisterCorruption(profile_store._profile_store_name, profile_key)\n\t\tend\n\t\t-- Return loaded_data:\n\t\treturn loaded_data\n\telse\n\t\tRegisterIssue((error_message ~= nil) and error_message or \"Undefined error\", profile_store._profile_store_name, profile_key)\n\t\t-- Return nothing:\n\t\treturn nil\n\tend\nend\n\nlocal function RemoveProfileFromAutoSave(profile)\n\tlocal auto_save_index = table.find(AutoSaveList, profile)\n\tif auto_save_index ~= nil then\n\t\ttable.remove(AutoSaveList, auto_save_index)\n\t\tif auto_save_index < AutoSaveIndex then\n\t\t\tAutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well\n\t\tend\n\t\tif AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1\n\t\t\tAutoSaveIndex = 1\n\t\tend\n\tend\nend\n\nlocal function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon\n\t-- Add at AutoSaveIndex and move AutoSaveIndex right:\n\ttable.insert(AutoSaveList, AutoSaveIndex, profile)\n\tif #AutoSaveList > 1 then\n\t\tAutoSaveIndex = AutoSaveIndex + 1\n\telseif #AutoSaveList == 1 then\n\t\t-- First profile created - make sure it doesn't get immediately auto saved:\n\t\tLastAutoSave = os.clock()\n\tend\nend\n\nlocal function ReleaseProfileInternally(profile)\n\t-- 1) Remove profile object from ProfileService references: --\n\t-- Clear reference in ProfileStore:\n\tlocal profile_store = profile._profile_store\n\tlocal loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles\n\tloaded_profiles[profile._profile_key] = nil\n\tif next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive\n\t\tlocal index = table.find(ActiveProfileStores, profile_store)\n\t\tif index ~= nil then\n\t\t\ttable.remove(ActiveProfileStores, index)\n\t\tend\n\tend\n\t-- Clear auto update reference:\n\tRemoveProfileFromAutoSave(profile)\n\t-- 2) Trigger release listeners: --\n\tlocal place_id\n\tlocal game_job_id\n\tlocal active_session = profile.MetaData.ActiveSession\n\tif active_session ~= nil then\n\t\tplace_id = active_session[1]\n\t\tgame_job_id = active_session[2]\n\tend\n\tfor _, listener in ipairs(profile._release_listeners) do\n\t\tlistener(place_id, game_job_id)\n\tend\n\tprofile._release_listeners = {}\nend\n\nlocal function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)\n\tlocal global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]\n\tlocal pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}\n\tlocal pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}\n\t-- \"old_\" or \"new_\" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\tfor _, new_global_update in ipairs(new_global_updates_data[2]) do\n\t\t-- Find old global update with the same update_id:\n\t\tlocal old_global_update\n\t\tfor _, global_update in ipairs(old_global_updates_data[2]) do\n\t\t\tif global_update[1] == new_global_update[1] then\n\t\t\t\told_global_update = global_update\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\t-- A global update is new when it didn't exist before or its version_id or update_locked state changed:\n\t\tlocal is_new = false\n\t\tif old_global_update == nil then\n\t\t\tis_new = true\n\t\telseif new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then\n\t\t\tis_new = true\n\t\tend\n\t\tif is_new == true then\n\t\t\t-- Active global updates:\n\t\t\tif new_global_update[3] == false then\n\t\t\t\t-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)\n\t\t\t\tlocal is_pending_lock = false\n\t\t\t\tfor _, update_id in ipairs(pending_update_lock) do\n\t\t\t\t\tif new_global_update[1] == update_id then\n\t\t\t\t\t\tis_pending_lock = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif is_pending_lock == false then\n\t\t\t\t\t-- Trigger new active update listeners:\n\t\t\t\t\tfor _, listener in ipairs(global_updates_object._new_active_update_listeners) do\n\t\t\t\t\t\tlistener(new_global_update[1], new_global_update[4])\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- Locked global updates:\n\t\t\tif new_global_update[3] == true then\n\t\t\t\t-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)\n\t\t\t\tlocal is_pending_clear = false\n\t\t\t\tfor _, update_id in ipairs(pending_update_clear) do\n\t\t\t\t\tif new_global_update[1] == update_id then\n\t\t\t\t\t\tis_pending_clear = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif is_pending_clear == false then\n\t\t\t\t\t-- Trigger new locked update listeners:\n\t\t\t\t\tfor _, listener in ipairs(global_updates_object._new_locked_update_listeners) do\n\t\t\t\t\t\tlistener(new_global_update[1], new_global_update[4])\n\t\t\t\t\t\t-- Check if listener marked the update to be cleared:\n\t\t\t\t\t\t-- Normally there should be only one listener per profile for new locked global updates, but\n\t\t\t\t\t\t-- in case several listeners are connected we will not trigger more listeners after one listener\n\t\t\t\t\t\t-- marks the locked global update to be cleared.\n\t\t\t\t\t\tfor _, update_id in ipairs(pending_update_clear) do\n\t\t\t\t\t\t\tif new_global_update[1] == update_id then\n\t\t\t\t\t\t\t\tis_pending_clear = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\tif is_pending_clear == true then\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function SaveProfileAsync(profile, release_from_session)\n\tif type(profile.Data) ~= \"table\" then\n\t\tRegisterCorruption(profile._profile_store._profile_store_name, profile._profile_key)\n\t\terror(\"[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! ProfileStore = \\\"\" .. profile._profile_store._profile_store_name .. \"\\\", Key = \\\"\" .. profile._profile_key .. \"\\\"\")\n\tend\n\tif release_from_session == true then\n\t\tReleaseProfileInternally(profile)\n\tend\n\tActiveProfileSaveJobs = ActiveProfileSaveJobs + 1\n\tlocal last_session_load_count = profile.MetaData.SessionLoadCount\n\t-- Compare \"SessionLoadCount\" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again\n\tlocal repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed\n\twhile repeat_save_flag == true do\n\t\tif release_from_session ~= true then\n\t\t\trepeat_save_flag = false\n\t\tend\n\t\tlocal loaded_data = StandardProfileUpdateAsyncDataStore(\n\t\t\tprofile._profile_store,\n\t\t\tprofile._profile_key,\n\t\t\t{\n\t\t\t\tExistingProfileHandle = nil,\n\t\t\t\tMissingProfileHandle = nil,\n\t\t\t\tEditProfile = function(latest_data)\n\t\t\t\t\t-- 1) Check if this session still owns the profile: --\n\t\t\t\t\tlocal active_session = latest_data.MetaData.ActiveSession\n\t\t\t\t\tlocal force_load_session = latest_data.MetaData.ForceLoadSession\n\t\t\t\t\tlocal session_load_count = latest_data.MetaData.SessionLoadCount\n\t\t\t\t\tlocal session_owns_profile = false\n\t\t\t\t\tlocal force_load_pending = false\n\t\t\t\t\tif type(active_session) == \"table\" then\n\t\t\t\t\t\tsession_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count\n\t\t\t\t\tend\n\t\t\t\t\tif type(force_load_session) == \"table\" then\n\t\t\t\t\t\tforce_load_pending = not IsThisSession(force_load_session)\n\t\t\t\t\tend\n\n\t\t\t\t\tif session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile\n\t\t\t\t\t\t-- 2) Manage global updates: --\n\t\t\t\t\t\tlocal latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\t\t\t\t\t\tlocal latest_global_updates_list = latest_global_updates_data[2]\n\n\t\t\t\t\t\tlocal global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]\n\t\t\t\t\t\tlocal pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}\n\t\t\t\t\t\tlocal pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}\n\t\t\t\t\t\t-- Active update locking:\n\t\t\t\t\t\tfor i = 1, #latest_global_updates_list do\n\t\t\t\t\t\t\tfor _, lock_id in ipairs(pending_update_lock) do\n\t\t\t\t\t\t\t\tif latest_global_updates_list[i][1] == lock_id then\n\t\t\t\t\t\t\t\t\tlatest_global_updates_list[i][3] = true\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\t-- Locked update clearing:\n\t\t\t\t\t\tfor _, clear_id in ipairs(pending_update_clear) do\n\t\t\t\t\t\t\tfor i = 1, #latest_global_updates_list do\n\t\t\t\t\t\t\t\tif latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then\n\t\t\t\t\t\t\t\t\ttable.remove(latest_global_updates_list, i)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\t-- 3) Save profile data: --\n\t\t\t\t\t\tlatest_data.Data = profile.Data\n\t\t\t\t\t\tlatest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData\n\t\t\t\t\t\tlatest_data.MetaData.LastUpdate = os.time()\n\t\t\t\t\t\tif release_from_session == true or force_load_pending == true then\n\t\t\t\t\t\t\tlatest_data.MetaData.ActiveSession = nil\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend,\n\t\t\t},\n\t\t\tprofile._is_user_mock\n\t\t)\n\t\tif loaded_data ~= nil then\n\t\t\trepeat_save_flag = false\n\t\t\t-- 4) Set latest data in profile: --\n\t\t\t-- Setting global updates:\n\t\t\tlocal global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]\n\t\t\tlocal old_global_updates_data = global_updates_object._updates_latest\n\t\t\tlocal new_global_updates_data = loaded_data.GlobalUpdates\n\t\t\tglobal_updates_object._updates_latest = new_global_updates_data\n\t\t\t-- Setting MetaData:\n\t\t\tlocal keep_session_meta_tag_reference = profile.MetaData.MetaTags\n\t\t\tprofile.MetaData = loaded_data.MetaData\n\t\t\tprofile.MetaData.MetaTagsLatest = profile.MetaData.MetaTags\n\t\t\tprofile.MetaData.MetaTags = keep_session_meta_tag_reference\n\t\t\t-- 5) Check if session still owns the profile: --\n\t\t\tlocal active_session = loaded_data.MetaData.ActiveSession\n\t\t\tlocal force_load_session = loaded_data.MetaData.ForceLoadSession\n\t\t\tlocal session_load_count = loaded_data.MetaData.SessionLoadCount\n\t\t\tlocal session_owns_profile = false\n\t\t\tif type(active_session) == \"table\" then\n\t\t\t\tsession_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count\n\t\t\tend\n\t\t\tlocal is_active = profile:IsActive()\n\t\t\tif session_owns_profile == true then\n\t\t\t\t-- 6) Check for new global updates: --\n\t\t\t\tif is_active == true then -- Profile could've been released before the saving thread finished\n\t\t\t\t\tCheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- Session no longer owns the profile:\n\t\t\t\t-- 7) Release profile if it hasn't been released yet: --\n\t\t\t\tif is_active == true then\n\t\t\t\t\tReleaseProfileInternally(profile)\n\t\t\t\tend\n\t\t\tend\n\t\telseif repeat_save_flag == true then\n\t\t\tMadwork.HeartbeatWait() -- Prevent infinite loop in case DataStore API does not yield\n\t\tend\n\tend\n\tActiveProfileSaveJobs = ActiveProfileSaveJobs - 1\nend\n\n----- Public functions -----\n\n-- GlobalUpdates object:\n\nlocal GlobalUpdates = {\n\t--[[\n\t\t_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\t\t_pending_update_lock = {update_id, ...} / nil, -- [table / nil]\n\t\t_pending_update_clear = {update_id, ...} / nil, -- [table / nil]\n\t\t\n\t\t_new_active_update_listeners = {listener, ...} / nil, -- [table / nil]\n\t\t_new_locked_update_listeners = {listener, ...} / nil, -- [table / nil]\n\t\t\n\t\t_profile = Profile / nil, -- [Profile / nil]\n\t\t\n\t\t_update_handler_mode = true / nil, -- [bool / nil]\n\t--]]\n}\nGlobalUpdates.__index = GlobalUpdates\n\n-- ALWAYS PUBLIC:\nfunction GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}\n\tlocal query_list = {}\n\tfor _, global_update in ipairs(self._updates_latest[2]) do\n\t\tif global_update[3] == false then\n\t\t\tlocal is_pending_lock = false\n\t\t\tif self._pending_update_lock ~= nil then\n\t\t\t\tfor _, update_id in ipairs(self._pending_update_lock) do\n\t\t\t\t\tif global_update[1] == update_id then\n\t\t\t\t\t\tis_pending_lock = true -- Exclude global updates pending to be locked\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif is_pending_lock == false then\n\t\t\t\ttable.insert(query_list, {global_update[1], global_update[4]})\n\t\t\tend\n\t\tend\n\tend\n\treturn query_list\nend\n\nfunction GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}\n\tlocal query_list = {}\n\tfor _, global_update in ipairs(self._updates_latest[2]) do\n\t\tif global_update[3] == true then\n\t\t\tlocal is_pending_clear = false\n\t\t\tif self._pending_update_clear ~= nil then\n\t\t\t\tfor _, update_id in ipairs(self._pending_update_clear) do\n\t\t\t\t\tif global_update[1] == update_id then\n\t\t\t\t\t\tis_pending_clear = true -- Exclude global updates pending to be cleared\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif is_pending_clear == false then\n\t\t\t\ttable.insert(query_list, {global_update[1], global_update[4]})\n\t\t\tend\n\t\tend\n\tend\n\treturn query_list\nend\n\n-- ONLY WHEN FROM \"Profile.GlobalUpdates\":\nfunction GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)\n\tif type(listener) ~= \"function\" then\n\t\terror(\"[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()\")\n\tend\n\tlocal profile = self._profile\n\tif self._update_handler_mode == true then\n\t\terror(\"[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._new_active_update_listeners == nil then\n\t\terror(\"[ProfileService]: Can't listen to new global updates in view mode\")\n\telseif profile:IsActive() == false then -- Check if profile is expired\n\t\treturn { -- Do not connect listener if the profile is expired\n\t\t\tDisconnect = function() end,\n\t\t}\n\tend\n\t-- Connect listener:\n\ttable.insert(self._new_active_update_listeners, listener)\n\treturn Madwork.NewArrayScriptConnection(self._new_active_update_listeners, listener)\nend\n\nfunction GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)\n\tif type(listener) ~= \"function\" then\n\t\terror(\"[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()\")\n\tend\n\tlocal profile = self._profile\n\tif self._update_handler_mode == true then\n\t\terror(\"[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._new_locked_update_listeners == nil then\n\t\terror(\"[ProfileService]: Can't listen to new global updates in view mode\")\n\telseif profile:IsActive() == false then -- Check if profile is expired\n\t\treturn { -- Do not connect listener if the profile is expired\n\t\t\tDisconnect = function() end,\n\t\t}\n\tend\n\t-- Connect listener:\n\ttable.insert(self._new_locked_update_listeners, listener)\n\treturn Madwork.NewArrayScriptConnection(self._new_locked_update_listeners, listener)\nend\n\nfunction GlobalUpdates:LockActiveUpdate(update_id)\n\tif type(update_id) ~= \"number\" then\n\t\terror(\"[ProfileService]: Invalid update_id\")\n\tend\n\tlocal profile = self._profile\n\tif self._update_handler_mode == true then\n\t\terror(\"[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._pending_update_lock == nil then\n\t\terror(\"[ProfileService]: Can't lock active global updates in view mode\")\n\telseif profile:IsActive() == false then -- Check if profile is expired\n\t\terror(\"[ProfileService]: PROFILE EXPIRED - Can't lock active global updates\")\n\tend\n\t-- Check if global update exists with given update_id\n\tlocal global_update_exists = nil\n\tfor _, global_update in ipairs(self._updates_latest[2]) do\n\t\tif global_update[1] == update_id then\n\t\t\tglobal_update_exists = global_update\n\t\t\tbreak\n\t\tend\n\tend\n\tif global_update_exists ~= nil then\n\t\tlocal is_pending_lock = false\n\t\tfor _, lock_update_id in ipairs(self._pending_update_lock) do\n\t\t\tif update_id == lock_update_id then\n\t\t\t\tis_pending_lock = true -- Exclude global updates pending to be locked\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock\n\t\t\ttable.insert(self._pending_update_lock, update_id)\n\t\tend\n\telse\n\t\terror(\"[ProfileService]: Passed non-existant update_id\")\n\tend\nend\n\nfunction GlobalUpdates:ClearLockedUpdate(update_id)\n\tif type(update_id) ~= \"number\" then\n\t\terror(\"[ProfileService]: Invalid update_id\")\n\tend\n\tlocal profile = self._profile\n\tif self._update_handler_mode == true then\n\t\terror(\"[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._pending_update_clear == nil then\n\t\terror(\"[ProfileService]: Can't clear locked global updates in view mode\")\n\telseif profile:IsActive() == false then -- Check if profile is expired\n\t\terror(\"[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates\")\n\tend\n\t-- Check if global update exists with given update_id\n\tlocal global_update_exists = nil\n\tfor _, global_update in ipairs(self._updates_latest[2]) do\n\t\tif global_update[1] == update_id then\n\t\t\tglobal_update_exists = global_update\n\t\t\tbreak\n\t\tend\n\tend\n\tif global_update_exists ~= nil then\n\t\tlocal is_pending_clear = false\n\t\tfor _, clear_update_id in ipairs(self._pending_update_clear) do\n\t\t\tif update_id == clear_update_id then\n\t\t\t\tis_pending_clear = true -- Exclude global updates pending to be cleared\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear\n\t\t\ttable.insert(self._pending_update_clear, update_id)\n\t\tend\n\telse\n\t\terror(\"[ProfileService]: Passed non-existant update_id\")\n\tend\nend\n\n-- EXPOSED TO \"update_handler\" DURING ProfileStore:GlobalUpdateProfileAsync() CALL\nfunction GlobalUpdates:AddActiveUpdate(update_data)\n\tif type(update_data) ~= \"table\" then\n\t\terror(\"[ProfileService]: Invalid update_data\")\n\tend\n\tif self._new_active_update_listeners ~= nil then\n\t\terror(\"[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._update_handler_mode ~= true then\n\t\terror(\"[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()\")\n\tend\n\t-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\tlocal updates_latest = self._updates_latest\n\tlocal update_index = updates_latest[1] + 1 -- Incrementing global update index\n\tupdates_latest[1] = update_index\n\t-- Add new active global update:\n\ttable.insert(updates_latest[2], {update_index, 1, false, update_data})\nend\n\nfunction GlobalUpdates:ChangeActiveUpdate(update_id, update_data)\n\tif type(update_id) ~= \"number\" then\n\t\terror(\"[ProfileService]: Invalid update_id\")\n\tend\n\tif type(update_data) ~= \"table\" then\n\t\terror(\"[ProfileService]: Invalid update_data\")\n\tend\n\tif self._new_active_update_listeners ~= nil then\n\t\terror(\"[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._update_handler_mode ~= true then\n\t\terror(\"[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()\")\n\tend\n\t-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\tlocal updates_latest = self._updates_latest\n\tlocal get_global_update = nil\n\tfor _, global_update in ipairs(updates_latest[2]) do\n\t\tif update_id == global_update[1] then\n\t\t\tget_global_update = global_update\n\t\t\tbreak\n\t\tend\n\tend\n\tif get_global_update ~= nil then\n\t\tif get_global_update[3] == true then\n\t\t\terror(\"[ProfileService]: Can't change locked global update\")\n\t\tend\n\t\tget_global_update[2] = get_global_update[2] + 1 -- Increment version id\n\t\tget_global_update[4] = update_data -- Set new global update data\n\telse\n\t\terror(\"[ProfileService]: Passed non-existant update_id\")\n\tend\nend\n\nfunction GlobalUpdates:ClearActiveUpdate(update_id)\n\tif type(update_id) ~= \"number\" then\n\t\terror(\"[ProfileService]: Invalid update_id argument\")\n\tend\n\tif self._new_active_update_listeners ~= nil then\n\t\terror(\"[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()\")\n\telseif self._update_handler_mode ~= true then\n\t\terror(\"[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()\")\n\tend\n\t-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}\n\tlocal updates_latest = self._updates_latest\n\tlocal get_global_update_index = nil\n\tlocal get_global_update = nil\n\tfor index, global_update in ipairs(updates_latest[2]) do\n\t\tif update_id == global_update[1] then\n\t\t\tget_global_update_index = index\n\t\t\tget_global_update = global_update\n\t\t\tbreak\n\t\tend\n\tend\n\tif get_global_update ~= nil then\n\t\tif get_global_update[3] == true then\n\t\t\terror(\"[ProfileService]: Can't clear locked global update\")\n\t\tend\n\t\ttable.remove(updates_latest[2], get_global_update_index) -- Remove active global update\n\telse\n\t\terror(\"[ProfileService]: Passed non-existant update_id\")\n\tend\nend\n\n-- Profile object:\n\nlocal Profile = {\n\t--[[\n\t\tData = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes\n\t\tMetaData = {}, -- [table] -- Updated with every auto-save\n\t\tGlobalUpdates = GlobalUpdates, -- [GlobalUpdates]\n\t\t\n\t\t_profile_store = ProfileStore, -- [ProfileStore]\n\t\t_profile_key = \"\", -- [string]\n\t\t\n\t\t_release_listeners = {listener, ...} / nil, -- [table / nil]\n\t\t\n\t\t_view_mode = true / nil, -- [bool / nil]\n\t\t\n\t\t_load_timestamp = os.clock(),\n\t\t\n\t\t_is_user_mock = false, -- ProfileStore.Mock\n\t--]]\n}\nProfile.__index = Profile\n\nfunction Profile:IsActive() --> [bool]\n\tlocal loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles\n\treturn loaded_profiles[self._profile_key] == self\nend\n\nfunction Profile:GetMetaTag(tag_name) --> value\n\tlocal meta_data = self.MetaData\n\tif meta_data == nil then\n\t\treturn nil\n\t\t-- error(\"[ProfileService]: This Profile hasn't been loaded before - MetaData not available\")\n\tend\n\treturn self.MetaData.MetaTags[tag_name]\nend\n\nfunction Profile:SetMetaTag(tag_name, value)\n\tif type(tag_name) ~= \"string\" then\n\t\terror(\"[ProfileService]: tag_name must be a string\")\n\telseif string.len(tag_name) == 0 then\n\t\terror(\"[ProfileService]: Invalid tag_name\")\n\tend\n\tif self._view_mode == true then\n\t\terror(\"[ProfileService]: Can't set meta tag in view mode\")\n\tend\n\tif self:IsActive() == false then\n\t\terror(\"[ProfileService]: PROFILE EXPIRED - Meta tags can't be set\")\n\tend\n\tself.MetaData.MetaTags[tag_name] = value\nend\n\nfunction Profile:Reconcile()\n\tReconcileTable(self.Data, self._profile_store._profile_template)\nend\n\nfunction Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)\n\tif type(listener) ~= \"function\" then\n\t\terror(\"[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()\")\n\tend\n\tif self._view_mode == true then\n\t\terror(\"[ProfileService]: Can't listen to Profile release in view mode\")\n\tend\n\tif self:IsActive() == false then\n\t\t-- Call release listener immediately if profile is expired\n\t\tlocal place_id\n\t\tlocal game_job_id\n\t\tlocal active_session = self.MetaData.ActiveSession\n\t\tif active_session ~= nil then\n\t\t\tplace_id = active_session[1]\n\t\t\tgame_job_id = active_session[2]\n\t\tend\n\t\tlistener(place_id, game_job_id)\n\t\treturn {\n\t\t\tDisconnect = function() end,\n\t\t}\n\telse\n\t\ttable.insert(self._release_listeners, listener)\n\t\treturn Madwork.NewArrayScriptConnection(self._release_listeners, listener)\n\tend\nend\n\nfunction Profile:Save()\n\tif self._view_mode == true then\n\t\terror(\"[ProfileService]: Can't save Profile in view mode\")\n\tend\n\tif self:IsActive() == false then\n\t\terror(\"[ProfileService]: PROFILE EXPIRED - Can't save Profile\")\n\tend\n\t-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:\n\tRemoveProfileFromAutoSave(self)\n\tAddProfileToAutoSave(self)\n\t-- Call save function in a new thread:\n\tcoroutine.wrap(SaveProfileAsync)(self)\nend\n\nfunction Profile:Release()\n\tif self._view_mode == true then\n\t\terror(\"[ProfileService]: Can't release Profile in view mode\")\n\tend\n\tif self:IsActive() == true then\n\t\tcoroutine.wrap(SaveProfileAsync)(self, true) -- Call save function in a new thread with release_from_session = true\n\tend\nend\n\n-- ProfileStore object:\n\nlocal ProfileStore = {\n\t--[[\n\t\tMock = {},\n\t\n\t\t_profile_store_name = \"\", -- [string] -- DataStore name\n\t\t_profile_template = {}, -- [table]\n\t\t_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)\n\t\t\n\t\t_loaded_profiles = {[profile_key] = Profile, ...},\n\t\t_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},\n\t\t\n\t\t_mock_loaded_profiles = {[profile_key] = Profile, ...},\n\t\t_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},\n\t--]]\n}\nProfileStore.__index = ProfileStore\n\nfunction ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)\n\tif self._profile_template == nil then\n\t\terror(\"[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore\")\n\tend\n\tif type(profile_key) ~= \"string\" then\n\t\terror(\"[ProfileService]: profile_key must be a string, got \"..typeof(profile_key))\n\telseif string.len(profile_key) == 0 then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\tend\n\tif type(not_released_handler) ~= \"function\" and not_released_handler ~= \"ForceLoad\" and not_released_handler ~= \"Steal\" then\n\t\terror(\"[ProfileService]: Invalid not_released_handler\")\n\tend\n\n\tif ProfileService.ServiceLocked == true then\n\t\treturn nil\n\tend\n\n\tWaitForPendingProfileStore(self)\n\n\tlocal is_user_mock = _use_mock == UseMockTag\n\n\t-- Check if profile with profile_key isn't already loaded in this session:\n\tfor _, profile_store in ipairs(ActiveProfileStores) do\n\t\tif profile_store._profile_store_name == self._profile_store_name then\n\t\t\tlocal loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles\n\t\t\tif loaded_profiles[profile_key] ~= nil then\n\t\t\t\terror(\"[ProfileService]: Profile of ProfileStore \\\"\" .. self._profile_store_name .. \"\\\" with key \\\"\" .. profile_key .. \"\\\" is already loaded in this session\")\n\t\t\t\t-- Are you using Profile:Release() properly?\n\t\t\tend\n\t\tend\n\tend\n\n\tActiveProfileLoadJobs = ActiveProfileLoadJobs + 1\n\tlocal force_load = not_released_handler == \"ForceLoad\"\n\tlocal force_load_steps = 0\n\tlocal request_force_load = force_load -- First step of ForceLoad\n\tlocal steal_session = false -- Second step of ForceLoad\n\tlocal aggressive_steal = not_released_handler == \"Steal\" -- Developer invoked steal\n\twhile ProfileService.ServiceLocked == false do\n\t\t-- Load profile:\n\t\t-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,\n\t\t-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare\n\t\t-- game breaking errors where a player rejoins the server super fast.\n\t\tlocal profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs\n\t\tlocal loaded_data\n\t\tlocal load_id = LoadIndex + 1\n\t\tLoadIndex = load_id\n\t\tlocal profile_load_job = profile_load_jobs[profile_key] -- {load_id, loaded_data}\n\t\tif profile_load_job ~= nil then\n\t\t\tprofile_load_job[1] = load_id -- Yoink load job\n\t\t\twhile profile_load_job[2] == nil do -- Wait for job to finish\n\t\t\t\tMadwork.HeartbeatWait()\n\t\t\tend\n\t\t\tif profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked\n\t\t\t\tloaded_data = profile_load_job[2]\n\t\t\t\tprofile_load_jobs[profile_key] = nil\n\t\t\telse\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tprofile_load_job = {load_id, nil}\n\t\t\tprofile_load_jobs[profile_key] = profile_load_job\n\t\t\tprofile_load_job[2] = StandardProfileUpdateAsyncDataStore(\n\t\t\t\tself,\n\t\t\t\tprofile_key,\n\t\t\t\t{\n\t\t\t\t\tExistingProfileHandle = function(latest_data)\n\t\t\t\t\t\tif ProfileService.ServiceLocked == false then\n\t\t\t\t\t\t\tlocal active_session = latest_data.MetaData.ActiveSession\n\t\t\t\t\t\t\tlocal force_load_session = latest_data.MetaData.ForceLoadSession\n\t\t\t\t\t\t\t-- IsThisSession(active_session)\n\t\t\t\t\t\t\tif active_session == nil then\n\t\t\t\t\t\t\t\tlatest_data.MetaData.ActiveSession = {PlaceId, JobId}\n\t\t\t\t\t\t\t\tlatest_data.MetaData.ForceLoadSession = nil\n\t\t\t\t\t\t\telseif type(active_session) == \"table\" then\n\t\t\t\t\t\t\t\tif IsThisSession(active_session) == false then\n\t\t\t\t\t\t\t\t\tlocal last_update = latest_data.MetaData.LastUpdate\n\t\t\t\t\t\t\t\t\tif last_update ~= nil then\n\t\t\t\t\t\t\t\t\t\tif os.time() - last_update > SETTINGS.AssumeDeadSessionLock then\n\t\t\t\t\t\t\t\t\t\t\tlatest_data.MetaData.ActiveSession = {PlaceId, JobId}\n\t\t\t\t\t\t\t\t\t\t\tlatest_data.MetaData.ForceLoadSession = nil\n\t\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\tif steal_session == true or aggressive_steal == true then\n\t\t\t\t\t\t\t\t\t\tlocal force_load_uninterrupted = false\n\t\t\t\t\t\t\t\t\t\tif force_load_session ~= nil then\n\t\t\t\t\t\t\t\t\t\t\tforce_load_uninterrupted = IsThisSession(force_load_session)\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\tif force_load_uninterrupted == true or aggressive_steal == true then\n\t\t\t\t\t\t\t\t\t\t\tlatest_data.MetaData.ActiveSession = {PlaceId, JobId}\n\t\t\t\t\t\t\t\t\t\t\tlatest_data.MetaData.ForceLoadSession = nil\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\telseif request_force_load == true then\n\t\t\t\t\t\t\t\t\t\tlatest_data.MetaData.ForceLoadSession = {PlaceId, JobId}\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tlatest_data.MetaData.ForceLoadSession = nil\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t\tMissingProfileHandle = function(latest_data)\n\t\t\t\t\t\tlatest_data.Data = DeepCopyTable(self._profile_template)\n\t\t\t\t\t\tlatest_data.MetaData = {\n\t\t\t\t\t\t\tProfileCreateTime = os.time(),\n\t\t\t\t\t\t\tSessionLoadCount = 0,\n\t\t\t\t\t\t\tActiveSession = {PlaceId, JobId},\n\t\t\t\t\t\t\tForceLoadSession = nil,\n\t\t\t\t\t\t\tMetaTags = {},\n\n\t\t\t\t\t\t}\n\t\t\t\t\tend,\n\t\t\t\t\tEditProfile = function(latest_data)\n\t\t\t\t\t\tif ProfileService.ServiceLocked == false then\n\t\t\t\t\t\t\tlocal active_session = latest_data.MetaData.ActiveSession\n\t\t\t\t\t\t\tif active_session ~= nil and IsThisSession(active_session) == true then\n\t\t\t\t\t\t\t\tlatest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1\n\t\t\t\t\t\t\t\tlatest_data.MetaData.LastUpdate = os.time()\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t},\n\t\t\t\tis_user_mock\n\t\t\t)\n\t\t\tif profile_load_job[1] == load_id then -- Load job hasn't been yoinked\n\t\t\t\tloaded_data = profile_load_job[2]\n\t\t\t\tprofile_load_jobs[profile_key] = nil\n\t\t\telse\n\t\t\t\treturn nil -- Load job yoinked\n\t\t\tend\n\t\tend\n\t\t-- Handle load_data:\n\t\tif loaded_data ~= nil then\n\t\t\tlocal active_session = loaded_data.MetaData.ActiveSession\n\t\t\tif type(active_session) == \"table\" then\n\t\t\t\tif IsThisSession(active_session) == true then\n\t\t\t\t\t-- Special component in MetaTags:\n\t\t\t\t\tloaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)\n\t\t\t\t\t-- Case #1: Profile is now taken by this session:\n\t\t\t\t\t-- Create Profile object:\n\t\t\t\t\tlocal global_updates_object = {\n\t\t\t\t\t\t_updates_latest = loaded_data.GlobalUpdates,\n\t\t\t\t\t\t_pending_update_lock = {},\n\t\t\t\t\t\t_pending_update_clear = {},\n\n\t\t\t\t\t\t_new_active_update_listeners = {},\n\t\t\t\t\t\t_new_locked_update_listeners = {},\n\n\t\t\t\t\t\t_profile = nil,\n\t\t\t\t\t}\n\t\t\t\t\tsetmetatable(global_updates_object, GlobalUpdates)\n\t\t\t\t\tlocal profile = {\n\t\t\t\t\t\tData = loaded_data.Data,\n\t\t\t\t\t\tMetaData = loaded_data.MetaData,\n\t\t\t\t\t\tGlobalUpdates = global_updates_object,\n\n\t\t\t\t\t\t_profile_store = self,\n\t\t\t\t\t\t_profile_key = profile_key,\n\n\t\t\t\t\t\t_release_listeners = {},\n\n\t\t\t\t\t\t_load_timestamp = os.clock(),\n\n\t\t\t\t\t\t_is_user_mock = is_user_mock,\n\t\t\t\t\t}\n\t\t\t\t\tsetmetatable(profile, Profile)\n\t\t\t\t\tglobal_updates_object._profile = profile\n\t\t\t\t\t-- Referencing Profile object in ProfileStore:\n\t\t\t\t\tif next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive\n\t\t\t\t\t\ttable.insert(ActiveProfileStores, self)\n\t\t\t\t\tend\n\t\t\t\t\tif is_user_mock == true then\n\t\t\t\t\t\tself._mock_loaded_profiles[profile_key] = profile\n\t\t\t\t\telse\n\t\t\t\t\t\tself._loaded_profiles[profile_key] = profile\n\t\t\t\t\tend\n\t\t\t\t\t-- Adding profile to AutoSaveList;\n\t\t\t\t\tAddProfileToAutoSave(profile)\n\t\t\t\t\t-- Special case - finished loading profile, but session is shutting down:\n\t\t\t\t\tif ProfileService.ServiceLocked == true then\n\t\t\t\t\t\tSaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished\n\t\t\t\t\t\tprofile = nil -- nil will be returned by this call\n\t\t\t\t\tend\n\t\t\t\t\t-- Return Profile object:\n\t\t\t\t\tActiveProfileLoadJobs = ActiveProfileLoadJobs - 1\n\t\t\t\t\treturn profile\n\t\t\t\telse\n\t\t\t\t\t-- Case #2: Profile is taken by some other session:\n\t\t\t\t\tif force_load == true then\n\t\t\t\t\t\tlocal force_load_session = loaded_data.MetaData.ForceLoadSession\n\t\t\t\t\t\tlocal force_load_uninterrupted = false\n\t\t\t\t\t\tif force_load_session ~= nil then\n\t\t\t\t\t\t\tforce_load_uninterrupted = IsThisSession(force_load_session)\n\t\t\t\t\t\tend\n\t\t\t\t\t\tif force_load_uninterrupted == true then\n\t\t\t\t\t\t\tif request_force_load == false then\n\t\t\t\t\t\t\t\tforce_load_steps = force_load_steps + 1\n\t\t\t\t\t\t\t\tif force_load_steps == SETTINGS.ForceLoadMaxSteps then\n\t\t\t\t\t\t\t\t\tsteal_session = true\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t-- Another session tried to force load this profile:\n\t\t\t\t\t\t\tActiveProfileLoadJobs = ActiveProfileLoadJobs - 1\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\tend\n\t\t\t\t\t\trequest_force_load = false -- Only request a force load once\n\t\t\t\t\telseif aggressive_steal == true then\n\t\t\t\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\t\t\t\telse\n\t\t\t\t\t\tlocal handler_result = not_released_handler(active_session[1], active_session[2])\n\t\t\t\t\t\tif handler_result == \"Repeat\" then\n\t\t\t\t\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\t\t\t\t\telseif handler_result == \"Cancel\" then\n\t\t\t\t\t\t\tActiveProfileLoadJobs = ActiveProfileLoadJobs - 1\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\telseif handler_result == \"ForceLoad\" then\n\t\t\t\t\t\t\tforce_load = true\n\t\t\t\t\t\t\trequest_force_load = true\n\t\t\t\t\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\t\t\t\t\telseif handler_result == \"Steal\" then\n\t\t\t\t\t\t\taggressive_steal = true\n\t\t\t\t\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terror(\"[ProfileService]: Invalid return from not_released_handler\")\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tActiveProfileLoadJobs = ActiveProfileLoadJobs - 1\n\t\t\t\terror(\"[ProfileService]: Invalid ActiveSession value in Profile.MetaData - Fatal corruption\") -- It's unlikely this will ever fire\n\t\t\tend\n\t\telse\n\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\tend\n\tend\n\tActiveProfileLoadJobs = ActiveProfileLoadJobs - 1\n\treturn nil -- If loop breaks return nothing\nend\n\nfunction ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))\n\tif type(profile_key) ~= \"string\" then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\telseif string.len(profile_key) == 0 then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\tend\n\tif type(update_handler) ~= \"function\" then\n\t\terror(\"[ProfileService]: Invalid update_handler\")\n\tend\n\n\tif ProfileService.ServiceLocked == true then\n\t\treturn nil\n\tend\n\n\tWaitForPendingProfileStore(self)\n\n\twhile ProfileService.ServiceLocked == false do\n\t\t-- Updating profile:\n\t\tlocal loaded_data = StandardProfileUpdateAsyncDataStore(\n\t\t\tself,\n\t\t\tprofile_key,\n\t\t\t{\n\t\t\t\tExistingProfileHandle = nil,\n\t\t\t\tMissingProfileHandle = nil,\n\t\t\t\tEditProfile = function(latest_data)\n\t\t\t\t\t-- Running update_handler:\n\t\t\t\t\tlocal global_updates_object = {\n\t\t\t\t\t\t_updates_latest = latest_data.GlobalUpdates,\n\t\t\t\t\t\t_update_handler_mode = true,\n\t\t\t\t\t}\n\t\t\t\t\tsetmetatable(global_updates_object, GlobalUpdates)\n\t\t\t\t\tupdate_handler(global_updates_object)\n\t\t\t\tend,\n\t\t\t},\n\t\t\t_use_mock == UseMockTag\n\t\t)\n\t\t-- Handling loaded_data:\n\t\tif loaded_data ~= nil then\n\t\t\t-- Return GlobalUpdates object (Update successful):\n\t\t\tlocal global_updates_object = {\n\t\t\t\t_updates_latest = loaded_data.GlobalUpdates,\n\t\t\t}\n\t\t\tsetmetatable(global_updates_object, GlobalUpdates)\n\t\t\treturn global_updates_object\n\t\telse\n\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again\n\t\tend\n\tend\n\treturn nil -- Return nothing (Update unsuccessful)\nend\n\nfunction ProfileStore:ViewProfileAsync(profile_key, _use_mock) --> [Profile / nil]\n\tif type(profile_key) ~= \"string\" then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\telseif string.len(profile_key) == 0 then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\tend\n\n\tif ProfileService.ServiceLocked == true then\n\t\treturn nil\n\tend\n\n\tWaitForPendingProfileStore(self)\n\n\twhile ProfileService.ServiceLocked == false do\n\t\t-- Load profile:\n\t\tlocal loaded_data = StandardProfileUpdateAsyncDataStore(\n\t\t\tself,\n\t\t\tprofile_key,\n\t\t\t{\n\t\t\t\tExistingProfileHandle = nil,\n\t\t\t\tMissingProfileHandle = nil,\n\t\t\t\tEditProfile = nil,\n\t\t\t},\n\t\t\t_use_mock == UseMockTag\n\t\t)\n\t\t-- Handle load_data:\n\t\tif loaded_data ~= nil then\n\t\t\t-- Create Profile object:\n\t\t\tlocal global_updates_object = {\n\t\t\t\t_updates_latest = loaded_data.GlobalUpdates,\n\t\t\t\t_profile = nil,\n\t\t\t}\n\t\t\tsetmetatable(global_updates_object, GlobalUpdates)\n\t\t\tlocal profile = {\n\t\t\t\tData = loaded_data.Data,\n\t\t\t\tMetaData = loaded_data.MetaData,\n\t\t\t\tGlobalUpdates = global_updates_object,\n\n\t\t\t\t_profile_store = self,\n\t\t\t\t_profile_key = profile_key,\n\n\t\t\t\t_view_mode = true,\n\n\t\t\t\t_load_timestamp = os.clock(),\n\t\t\t}\n\t\t\tsetmetatable(profile, Profile)\n\t\t\tglobal_updates_object._profile = profile\n\t\t\t-- Returning Profile object:\n\t\t\treturn profile\n\t\telse\n\t\t\tMadwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay\n\t\tend\n\tend\n\treturn nil -- If loop breaks return nothing\nend\n\nfunction ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]\n\tif type(profile_key) ~= \"string\" then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\telseif string.len(profile_key) == 0 then\n\t\terror(\"[ProfileService]: Invalid profile_key\")\n\tend\n\n\tif ProfileService.ServiceLocked == true then\n\t\treturn false\n\tend\n\n\tWaitForPendingProfileStore(self)\n\n\treturn StandardProfileUpdateAsyncDataStore(\n\t\tself,\n\t\tprofile_key,\n\t\t{\n\t\t\tWipeProfile = true\n\t\t},\n\t\t_use_mock == UseMockTag\n\t)\nend\n\n-- New ProfileStore:\n\nfunction ProfileService.GetProfileStore(profile_store_name, profile_template) --> [ProfileStore]\n\tif type(profile_store_name) ~= \"string\" then\n\t\terror(\"[ProfileService]: profile_store_name must be a string\")\n\telseif string.len(profile_store_name) == 0 then\n\t\terror(\"[ProfileService]: Invalid profile_store_name\")\n\tend\n\n\tif type(profile_template) ~= \"table\" then\n\t\terror(\"[ProfileService]: Invalid profile_template\")\n\tend\n\n\tlocal profile_store\n\tprofile_store = {\n\t\tMock = {\n\t\t\tLoadProfileAsync = function(_, profile_key, not_released_handler)\n\t\t\t\treturn profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)\n\t\t\tend,\n\t\t\tGlobalUpdateProfileAsync = function(_, profile_key, update_handler)\n\t\t\t\treturn profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)\n\t\t\tend,\n\t\t\tViewProfileAsync = function(_, profile_key)\n\t\t\t\treturn profile_store:ViewProfileAsync(profile_key, UseMockTag)\n\t\t\tend,\n\t\t\tWipeProfileAsync = function(_, profile_key)\n\t\t\t\treturn profile_store:WipeProfileAsync(profile_key, UseMockTag)\n\t\t\tend\n\t\t},\n\n\t\t_profile_store_name = profile_store_name,\n\t\t_profile_template = profile_template,\n\t\t_global_data_store = nil,\n\t\t_loaded_profiles = {},\n\t\t_profile_load_jobs = {},\n\t\t_mock_loaded_profiles = {},\n\t\t_mock_profile_load_jobs = {},\n\t\t_is_pending = false,\n\t}\n\tif IsLiveCheckActive == true then\n\t\tprofile_store._is_pending = true\n\t\tcoroutine.wrap(function()\n\t\t\tWaitForLiveAccessCheck()\n\t\t\tif UseMockDataStore == false then\n\t\t\t\tprofile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name)\n\t\t\tend\n\t\t\tprofile_store._is_pending = false\n\t\tend)()\n\telse\n\t\tif UseMockDataStore == false then\n\t\t\tprofile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name)\n\t\tend\n\tend\n\tsetmetatable(profile_store, ProfileStore)\n\treturn profile_store\nend\n\n----- Initialize -----\n\nif IsStudio == true then\n\tIsLiveCheckActive = true\n\tcoroutine.wrap(function()\n\t\tlocal status, message = pcall(function()\n\t\t\t-- This will error if current instance has no Studio API access:\n\t\t\tDataStoreService:GetDataStore(\"____PS\"):SetAsync(\"____PS\", os.time())\n\t\tend)\n\t\tlocal no_internet_access = status == false and string.find(message, \"ConnectFail\", 1, true) ~= nil\n\t\tif no_internet_access == true then\n\t\t\twarn(\"[ProfileService]: No internet access - check your network connection\")\n\t\tend\n\t\tif status == false and\n\t\t\t(string.find(message, \"403\", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled\n\t\t\t\tstring.find(message, \"must publish\", 1, true) ~= nil or -- Game must be published to access live keys\n\t\t\t\tno_internet_access == true) then -- No internet access\n\n\t\t\tUseMockDataStore = true\n\t\t\tProfileService._use_mock_data_store = true\n\t\t\tprint(\"[ProfileService]: Roblox API services unavailable - data will not be saved\")\n\t\telse\n\t\t\tprint(\"[ProfileService]: Roblox API services available - data will be saved\")\n\t\tend\n\t\tIsLiveCheckActive = false\n\tend)()\nend\n\n----- Connections -----\n\n-- Auto saving and issue queue managing:\nRunService.Heartbeat:Connect(function()\n\t-- 1) Auto saving: --\n\tlocal auto_save_list_length = #AutoSaveList\n\tif auto_save_list_length > 0 then\n\t\tlocal auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length\n\t\tlocal os_clock = os.clock()\n\t\twhile os_clock - LastAutoSave > auto_save_index_speed do\n\t\t\tLastAutoSave = LastAutoSave + auto_save_index_speed\n\t\t\tlocal profile = AutoSaveList[AutoSaveIndex]\n\t\t\tif os_clock - profile._load_timestamp < SETTINGS.AutoSaveProfiles then\n\t\t\t\t-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:\n\t\t\t\tprofile = nil\n\t\t\t\tfor i = 1, auto_save_list_length - 1 do\n\t\t\t\t\t-- Move auto save index to the right:\n\t\t\t\t\tAutoSaveIndex = AutoSaveIndex + 1\n\t\t\t\t\tif AutoSaveIndex > auto_save_list_length then\n\t\t\t\t\t\tAutoSaveIndex = 1\n\t\t\t\t\tend\n\t\t\t\t\tprofile = AutoSaveList[AutoSaveIndex]\n\t\t\t\t\tif os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse\n\t\t\t\t\t\tprofile = nil\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- Move auto save index to the right:\n\t\t\tAutoSaveIndex = AutoSaveIndex + 1\n\t\t\tif AutoSaveIndex > auto_save_list_length then\n\t\t\t\tAutoSaveIndex = 1\n\t\t\tend\n\t\t\t-- Perform save call:\n\t\t\t-- print(\"[ProfileService]: Auto updating profile - profile_store_name = \\\"\" .. profile._profile_store._profile_store_name .. \"\\\"; profile_key = \\\"\" .. profile._profile_key .. \"\\\"\")\n\t\t\tif profile ~= nil then\n\t\t\t\tcoroutine.wrap(SaveProfileAsync)(profile) -- Auto save profile in new thread\n\t\t\tend\n\t\tend\n\tend\n\t-- 2) Issue queue: --\n\t-- Critical state handling:\n\tif ProfileService.CriticalState == false then\n\t\tif #IssueQueue >= SETTINGS.IssueCountForCriticalState then\n\t\t\tProfileService.CriticalState = true\n\t\t\tProfileService.CriticalStateSignal:Fire(true)\n\t\t\tCriticalStateStart = os.clock()\n\t\t\twarn(\"[ProfileService]: Entered critical state\")\n\t\tend\n\telse\n\t\tif #IssueQueue >= SETTINGS.IssueCountForCriticalState then\n\t\t\tCriticalStateStart = os.clock()\n\t\telseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then\n\t\t\tProfileService.CriticalState = false\n\t\t\tProfileService.CriticalStateSignal:Fire(false)\n\t\t\twarn(\"[ProfileService]: Critical state ended\")\n\t\tend\n\tend\n\t-- Issue queue:\n\twhile true do\n\t\tlocal issue_time = IssueQueue[1]\n\t\tif issue_time == nil then\n\t\t\tbreak\n\t\telseif os.clock() - issue_time > SETTINGS.IssueLast then\n\t\t\ttable.remove(IssueQueue, 1)\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\nend)\n\n-- Release all loaded profiles when the server is shutting down:\ncoroutine.wrap(function()\n\tWaitForLiveAccessCheck()\n\tMadwork.ConnectToOnClose(\n\t\tfunction()\n\t\t\tProfileService.ServiceLocked = true\n\t\t\t-- 1) Release all active profiles: --\n\t\t\t-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:\n\t\t\tlocal on_close_save_job_count = 0\n\t\t\tlocal active_profiles = {}\n\t\t\tfor index, profile in ipairs(AutoSaveList) do\n\t\t\t\tactive_profiles[index] = profile\n\t\t\tend\n\t\t\t-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:\n\t\t\tfor _, profile in ipairs(active_profiles) do\n\t\t\t\tif profile:IsActive() == true then\n\t\t\t\t\ton_close_save_job_count = on_close_save_job_count + 1\n\t\t\t\t\tcoroutine.wrap(function() -- Save profile on new thread\n\t\t\t\t\t\tSaveProfileAsync(profile, true)\n\t\t\t\t\t\ton_close_save_job_count = on_close_save_job_count - 1\n\t\t\t\t\tend)()\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- 2) Yield until all active profile jobs are finished: --\n\t\t\twhile on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do\n\t\t\t\tMadwork.HeartbeatWait()\n\t\t\tend\n\t\t\treturn -- We're done!\n\t\tend,\n\t\tUseMockDataStore == false -- Always run this OnClose task if using Roblox API services\n\t)\nend)()\n\nreturn ProfileService",
  "SourceAssetId": 5331689994,
  "Tags": [],
  "UniqueId": "<FAILED: Unsupported variant type: Discriminant(35) (property: UniqueId, class: ModuleScript, instance: ProfileService)>"
}