{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{84FFE82B-D656-4B47-B5EF-FF319E827CE1}",
  "Source": "-- [[ Services ]]\nlocal Players = game:GetService(\"Players\")\nlocal CollectionService = game:GetService(\"CollectionService\")\n\n-- [[ Variables ]]\nlocal MAIN = script.Parent\n\nlocal CastAttachment  = require(MAIN.CastLogics.CastAttachment)\nlocal CastVectorPoint = require(MAIN.CastLogics.CastVectorPoint)\nlocal CastLinkAttach  = require(MAIN.CastLogics.CastLinkAttachment)\n\nlocal Signal = require(MAIN.Tools.Signal)\nlocal clock = os.clock\n\n\n--------\nlocal HitboxObject = {}\nlocal Hitbox = {}\nHitbox.__index = Hitbox\n\nfunction Hitbox:__tostring() \n\treturn string.format(\"Hitbox for instance %s [%s]\", self.object.Name, self.object.ClassName)\nend\n\nfunction HitboxObject:new()\n    return setmetatable({}, Hitbox)\nend\n\nfunction Hitbox:config(object, ignoreList)\n\tself.active = false\n\tself.deleted = false\n\tself.partMode = false\n\tself.debugMode = false\n\tself.points = {}\n\tself.targetsHit = {}\n\tself.endTime = 0\n\tself.OnHit = Signal:Create()\n\tself.OnUpdate = Signal:Create()\n\tself.raycastParams = RaycastParams.new()\n\tself.raycastParams.FilterType = Enum.RaycastFilterType.Blacklist\n\tself.raycastParams.FilterDescendantsInstances = ignoreList or {}\n\t\n\tself.object = object\n\tCollectionService:AddTag(self.object, \"RaycastModuleManaged\")\nend\n\nfunction Hitbox:SetPoints(object, vectorPoints, groupName)\n\tif object and (object:IsA(\"BasePart\") or object:IsA(\"MeshPart\") or object:IsA(\"Attachment\")) then\n\t\tfor _, vectors in ipairs(vectorPoints) do\n\t\t\tif typeof(vectors) == \"Vector3\" then\n\t\t\t\tlocal Point = {\n\t\t\t\t\tIsAttachment = object:IsA(\"Attachment\"),\n\t\t\t\t\tRelativePart = object, \n\t\t\t\t\tAttachment = vectors,\n\t\t\t\t\tLastPosition = nil,\n\t\t\t\t\tgroup = groupName,\n\t\t\t\t\tsolver = CastVectorPoint\n\t\t\t\t}\n\t\t\t\ttable.insert(self.points, Point)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Hitbox:RemovePoints(object, vectorPoints)\n\tif object then\n\t\tif object:IsA(\"BasePart\") or object:IsA(\"MeshPart\") then --- for some reason it doesn't recognize meshparts unless I add it in\n\t\t\tfor i = 1, #self.points do\n\t\t\t\tlocal Point = self.points[i]\n\t\t\t\tfor _, vectors in ipairs(vectorPoints) do\n\t\t\t\t\tif typeof(Point.Attachment) == \"Vector3\" and Point.Attachment == vectors and Point.RelativePart == object then\n\t\t\t\t\t\tself.points[i] = nil\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Hitbox:LinkAttachments(primaryAttachment, secondaryAttachment)\n\tif primaryAttachment:IsA(\"Attachment\") and secondaryAttachment:IsA(\"Attachment\") then\n\t\tlocal group = primaryAttachment:FindFirstChild(\"Group\")\n\t\tlocal Point = {\n\t\t\tRelativePart = nil,\n\t\t\tAttachment = primaryAttachment,\n\t\t\tAttachment0 = secondaryAttachment,\n\t\t\tLastPosition = nil,\n\t\t\tgroup = group and group.Value,\n\t\t\tsolver = CastLinkAttach\n\t\t}\n\t\ttable.insert(self.points, Point)\n\tend\nend\n\nfunction Hitbox:UnlinkAttachments(primaryAttachment)\n\tfor i, Point in ipairs(self.points) do\n\t\tif Point.Attachment and Point.Attachment == primaryAttachment then\n\t\t\ttable.remove(self.points, i)\n\t\t\tbreak\n\t\tend\n\tend\nend\n\nfunction Hitbox:seekAttachments(attachmentName, canWarn)\n\tif #self.points <= 0 then\n\t\ttable.insert(self.raycastParams.FilterDescendantsInstances, workspace.Terrain)\n\tend\n\tfor _, attachment in ipairs(self.object:GetDescendants()) do\n\t\tif attachment:IsA(\"Attachment\") and attachment.Name == attachmentName then\n\t\t\tlocal group = attachment:FindFirstChild(\"Group\")\n\t\t\tlocal Point = {\n\t\t\t\tAttachment = attachment, \n\t\t\t\tRelativePart = nil, \n\t\t\t\tLastPosition = nil, \n\t\t\t\tgroup = group and group.Value,\n\t\t\t\tsolver = CastAttachment\n\t\t\t}\n\t\t\ttable.insert(self.points, Point)\n\t\tend\n\tend\n\t\n\tif canWarn then\n\t\tif #self.points <= 0 then\n\t\t\twarn(string.format(\"\\n[[RAYCAST WARNING]]\\nNo attachments with the name '%s' were found in %s. No raycasts will be drawn. Can be ignored if you are using SetPoints.\",\n\t\t\t\tattachmentName, self.object.Name)\n\t\t\t)\n\t\telse\n\t\t\tprint(string.format(\"\\n[[RAYCAST MESSAGE]]\\n\\nCreated Hitbox for %s - Attachments found: %s\", \n\t\t\t\tself.object.Name, #self.points)\n\t\t\t)\n\t\tend\n\tend\nend\n\nfunction Hitbox:Destroy()\n\tif self.deleted then return end\n\tif self.OnHit then self.OnHit:Delete() end\n\tif self.OnUpdate then self.OnUpdate:Delete() end\n\t\n\tself.points = nil\n\tself.active = false\n\tself.deleted = true\nend\n\nfunction Hitbox:HitStart(seconds)\n\tself.active = true\n\t\n\tif seconds then\n\t\tassert(type(seconds) == \"number\", \"Argument #1 must be a number!\")\n\t\t\n\t\tlocal minSeconds = 1 / 60 --- Seconds cannot be under 1/60th\n\t\t\n\t\tif seconds <= minSeconds or seconds == math.huge then\n\t\t\tseconds = minSeconds\n\t\tend\n\t\t\n\t\tself.endTime = clock() + seconds\n\tend\nend\n\nfunction Hitbox:HitStop()\n\tif self.deleted then return end\n\t\n\tself.active = false\n\tself.endTime = 0\n\ttable.clear(self.targetsHit)\nend\n\nfunction Hitbox:PartMode(bool)\n\tself.partMode = bool\nend\n\nfunction Hitbox:DebugMode(bool)\n\tself.debugMode = bool\nend\n\nreturn HitboxObject\n",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25842, time: 142155861, random: 1232354692393223026 })>"
}