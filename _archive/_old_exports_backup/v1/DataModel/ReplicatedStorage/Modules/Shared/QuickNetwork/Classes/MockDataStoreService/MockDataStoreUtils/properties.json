{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{4E7F96D8-F89E-4E2A-A959-7F5760D66564}",
  "Source": "--[[\n\tMockDataStoreUtils.lua\n\tContains helper and utility functions used by other classes.\n\n\tThis module is licensed under APLv2, refer to the LICENSE file or:\n\thttps://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE\n]]\n\nlocal MockDataStoreUtils = {}\n\nlocal Constants = require(script.Parent.MockDataStoreConstants)\nlocal HttpService = game:GetService(\"HttpService\") -- for json encode/decode\nlocal RunService = game:GetService(\"RunService\")\n\nlocal rand = Random.new()\n\nlocal function shorten(s, num)\n\tif #s > num then\n\t\treturn s:sub(1,num-2) .. \"..\"\n\tend\n\treturn s\nend\n\n--[[\n\t[DataStore] [Name/Scope] [GetAsync] KEY\n\t[DataStore] [Name/Scope] [UpdateAsync] KEY => VALUE\n\t[DataStore] [Name/Scope] [SetAsync] KEY => VALUE\n\t[DataStore] [Name/Scope] [IncrementAsync] KEY by INCR => VALUE\n\t[DataStore] [Name/Scope] [RemoveAsync] KEY =/> VALUE\n\t[DataStore] [Name/Scope] [OnUpdate] KEY\n\t[DataStore] [Name/Scope] [GetSortedAsync]\n\n\t[OrderedDataStore] [Name/Scope] [GetAsync] KEY\n\t[OrderedDataStore] [Name/Scope] [UpdateAsync] KEY => VALUE\n\t[OrderedDataStore] [Name/Scope] [SetAsync] KEY => VALUE\n\t[OrderedDataStore] [Name/Scope] [IncrementAsync] KEY + INCR => VALUE\n\t[OrderedDataStore] [Name/Scope] [RemoveAsync] KEY =/> VALUE\n\t[OrderedDataStore] [Name/Scope] [OnUpdate] KEY\n\t[OrderedDataStore] [Name/Scope] [GetSortedAsync]\n\n\t[OrderedDataStore] [Name/Scope] [AdvanceToNextPageAsync]\n]]\n\nlocal function logMethod(self, method, key, value, increment)\n\tif not Constants.LOGGING_ENABLED or type(Constants.LOGGING_FUNCTION) ~= \"function\" then\n\t\treturn\n\tend\n\n\tlocal name = self.__name\n\tlocal scope = self.__scope\n\n\tlocal prefix\n\tif not name then\n\t\tprefix = (\"[GlobalDataStore] [%s]\"):format(method)\n\telseif not scope then\n\t\tprefix = (\"[%s] [%s] [%s]\"):format(self.__type, shorten(name, 20), method)\n\telse\n\t\tprefix = (\"[%s] [%s/%s] [%s]\"):format(self.__type, shorten(name, 15), shorten(scope, 15), method)\n\tend\n\n\tlocal message\n\tif value and increment then\n\t\tmessage = key .. \" + \" .. tostring(increment) .. \" => \" .. tostring(value)\n\telseif increment then\n\t\tmessage = key .. \" + \" .. tostring(increment)\n\telseif value then\n\t\tif method == \"RemoveAsync\" then\n\t\t\tmessage = key .. \" =/> \" .. tostring(value)\n\t\telse\n\t\t\tmessage = key .. \" => \" .. tostring(value)\n\t\tend\n\telse\n\t\tmessage = \"key\"\n\tend\n\n\tConstants.LOGGING_FUNCTION(prefix .. \" \" .. message)\n\nend\n\nlocal function deepcopy(t)\n\tif type(t) == \"table\" then\n\t\tlocal n = {}\n\t\tfor i,v in pairs(t) do\n\t\t\tn[i] = deepcopy(v)\n\t\tend\n\t\treturn n\n\telse\n\t\treturn t\n\tend\nend\n\nlocal function scanValidity(tbl, passed, path) -- Credit to Corecii (edited)\n\tif type(tbl) ~= \"table\" then\n\t\treturn scanValidity({input = tbl}, {}, {})\n\tend\n\tpassed, path = passed or {}, path or {\"root\"}\n\tpassed[tbl] = true\n\tlocal tblType\n\tdo\n\t\tlocal key = next(tbl)\n\t\tif type(key) == \"number\" then\n\t\t\ttblType = \"Array\"\n\t\telse\n\t\t\ttblType = \"Dictionary\"\n\t\tend\n\tend\n\tlocal last = 0\n\tfor key, value in next, tbl do\n\t\tpath[#path + 1] = tostring(key)\n\t\tif type(key) == \"number\" then\n\t\t\tif tblType == \"Dictionary\" then\n\t\t\t\treturn false, path, \"cannot store mixed tables\"\n\t\t\telseif key % 1 ~= 0 then\n\t\t\t\treturn false, path, \"cannot store tables with non-integer indices\"\n\t\t\telseif key == math.huge or key == -math.huge then\n\t\t\t\treturn false, path, \"cannot store tables with (-)infinity indices\"\n\t\t\tend\n\t\telseif type(key) ~= \"string\" then\n\t\t\treturn false, path, \"dictionaries cannot have keys of type \" .. typeof(key)\n\t\telseif tblType == \"Array\" then\n\t\t\treturn false, path, \"cannot store mixed tables\"\n\t\telseif not utf8.len(key) then\n\t\t\treturn false, path, \"dictionary has key that is invalid UTF-8\"\n\t\tend\n\t\tif tblType == \"Array\" then\n\t\t\tif last ~= key - 1 then\n\t\t\t\treturn false, path, \"array has non-sequential indices\"\n\t\t\tend\n\t\t\tlast = key\n\t\tend\n\t\tif type(value) == \"userdata\" or type(value) == \"function\" or type(value) == \"thread\" then\n\t\t\treturn false, path, \"cannot store value '\" .. tostring(value) .. \"' of type \" .. typeof(value)\n\t\telseif type(value) == \"string\" and not utf8.len(value) then\n\t\t\treturn false, path, \"cannot store strings that are invalid UTF-8\"\n\t\tend\n\t\tif type(value) == \"table\" then\n\t\t\tif passed[value] then\n\t\t\t\treturn false, path, \"cannot store cyclic tables\"\n\t\t\tend\n\t\t\tlocal isValid, keyPath, reason = scanValidity(value, passed, path)\n\t\t\tif not isValid then\n\t\t\t\treturn isValid, keyPath, reason\n\t\t\tend\n\t\tend\n\t\tpath[#path] = nil\n\tend\n\tpassed[tbl] = nil\n\treturn true\nend\n\nlocal function getStringPath(path)\n\treturn table.concat(path, '.')\nend\n\n-- Import into a single datastore:\nlocal function importPairsFromTable(origin, destination, interface, warnFunc, methodName, prefix, isOrdered)\n\tfor key, value in pairs(origin) do\n\t\tif type(key) ~= \"string\" then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (key is not a string, but a %s)\")\n\t\t\t\t:format(methodName, prefix, tostring(key), typeof(key)))\n\t\telseif not utf8.len(key) then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (key is not valid UTF-8)\")\n\t\t\t\t:format(methodName, prefix, tostring(key)))\n\t\telseif #key > Constants.MAX_LENGTH_KEY then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (key exceeds %d character limit)\")\n\t\t\t\t:format(methodName, prefix, key, Constants.MAX_LENGTH_KEY))\n\t\telseif type(value) == \"string\" and #value > Constants.MAX_LENGTH_DATA then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (length of value exceeds %d character limit)\")\n\t\t\t\t:format(methodName, prefix, key, Constants.MAX_LENGTH_DATA))\n\t\telseif type(value) == \"table\" and #HttpService:JSONEncode(value) > Constants.MAX_LENGTH_DATA then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (length of encoded value exceeds %d character limit)\")\n\t\t\t\t:format(methodName, prefix, key, Constants.MAX_LENGTH_DATA))\n\t\telseif type(value) == \"function\" or type(value) == \"userdata\" or type(value) == \"thread\" then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (cannot store value '%s' of type %s)\")\n\t\t\t\t:format(methodName, prefix, key, tostring(value), type(value)))\n\t\telseif isOrdered and type(value) ~= \"number\" then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (cannot store value '%s' of type %s in OrderedDataStore)\")\n\t\t\t\t:format(methodName, prefix, key, tostring(value), type(value)))\n\t\telseif isOrdered and value % 1 ~= 0 then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (cannot store non-integer value '%s' in OrderedDataStore)\")\n\t\t\t\t:format(methodName, prefix, key, tostring(value)))\n\t\telseif type(value) == \"string\" and not utf8.len(value) then\n\t\t\twarnFunc((\"%s: ignored %s > '%s' (string value is not valid UTF-8)\")\n\t\t\t\t:format(methodName, prefix, key, tostring(value), type(value)))\n\t\telse\n\t\t\tlocal isValid = true\n\t\t\tlocal keyPath, reason\n\t\t\tif type(value) == \"table\" then\n\t\t\t\tisValid, keyPath, reason = scanValidity(value)\n\t\t\tend\n\t\t\tif isOrdered then\n\t\t\t\tvalue = math.floor(value + .5)\n\t\t\tend\n\t\t\tif isValid then\n\t\t\t\tlocal old = destination[key]\n\t\t\t\tdestination[key] = value\n\t\t\t\tif interface and old ~= value then -- hacky block to fire OnUpdate signals\n\t\t\t\t\tif isOrdered and interface then -- hacky block to populate internal structures for OrderedDataStores\n\t\t\t\t\t\tif interface.__ref[key] then\n\t\t\t\t\t\t\tinterface.__ref[key].Value = value\n\t\t\t\t\t\t\tinterface.__changed = true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinterface.__ref[key] = {Key = key, Value = interface.__data[key]}\n\t\t\t\t\t\t\ttable.insert(interface.__sorted, interface.__ref[key])\n\t\t\t\t\t\t\tinterface.__changed = true\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tinterface.__event:Fire(key, value)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\twarnFunc((\"%s: ignored %s > '%s' (table has invalid entry at <%s>: %s)\")\n\t\t\t\t\t:format(methodName, prefix, key, getStringPath(keyPath), reason))\n\t\t\tend\n\t\tend\n\tend\nend\n\n-- Trim empty datastores and scopes from an entire datastore type:\nlocal function prepareDataStoresForExport(origin)\n\tlocal dataPrepared = {}\n\n\tfor name, scopes in pairs(origin) do\n\t\tlocal exportScopes = {}\n\t\tfor scope, data in pairs(scopes) do\n\t\t\tlocal exportData = {}\n\t\t\tfor key, value in pairs(data) do\n\t\t\t\texportData[key] = value\n\t\t\tend\n\t\t\tif next(exportData) ~= nil then -- Only export datastore when non-empty\n\t\t\t\texportScopes[scope] = exportData\n\t\t\tend\n\t\tend\n\t\tif next(exportScopes) ~= nil then -- Only export scope list when non-empty\n\t\t\tdataPrepared[name] = exportScopes\n\t\tend\n\tend\n\n\tif next(dataPrepared) ~= nil then -- Only return datastore type when non-empty\n\t\treturn dataPrepared\n\tend\nend\n\nlocal function preprocessKey(key)\n\tif type(key) == \"number\" then\n\t\tif key ~= key then\n\t\t\treturn \"NAN\"\n\t\telseif key >= math.huge then\n\t\t\treturn \"INF\"\n\t\telseif key <= -math.huge then\n\t\t\treturn \"-INF\"\n\t\tend\n\t\treturn tostring(key)\n\tend\n\treturn key\nend\n\nlocal function accurateWait(dt)\n\tdt = math.max(0, dt)\n\tlocal left = dt\n\n\twhile left > 0 do\n\t\tleft = left - RunService.Heartbeat:Wait()\n\tend\n\n\treturn dt - left\nend\n\nlocal function simulateYield()\n\tif Constants.YIELD_TIME_MAX > 0 then\n\t\taccurateWait(rand:NextNumber(Constants.YIELD_TIME_MIN, Constants.YIELD_TIME_MAX))\n\tend\nend\n\nlocal function simulateErrorCheck(method)\n\tif Constants.SIMULATE_ERROR_RATE > 0 and rand:NextNumber() <= Constants.SIMULATE_ERROR_RATE then\n\t\tsimulateYield()\n\t\terror(method .. \" rejected with error (simulated error)\", 3)\n\tend\nend\n\n-- Setting these here so the functions above can self-reference just by name:\nMockDataStoreUtils.logMethod = logMethod\nMockDataStoreUtils.deepcopy = deepcopy\nMockDataStoreUtils.scanValidity = scanValidity\nMockDataStoreUtils.getStringPath = getStringPath\nMockDataStoreUtils.importPairsFromTable = importPairsFromTable\nMockDataStoreUtils.prepareDataStoresForExport = prepareDataStoresForExport\nMockDataStoreUtils.preprocessKey = preprocessKey\nMockDataStoreUtils.accurateWait = accurateWait\nMockDataStoreUtils.simulateYield = simulateYield\nMockDataStoreUtils.simulateErrorCheck = simulateErrorCheck\n\nreturn MockDataStoreUtils\n",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25834, time: 142155861, random: 1232354692393223026 })>"
}