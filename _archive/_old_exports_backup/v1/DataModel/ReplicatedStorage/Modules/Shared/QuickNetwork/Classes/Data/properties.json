{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{936BDD29-D59C-4651-A66E-224644267B7B}",
  "Source": "local Data = {}\nData.__index = Data \n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal ancestor = script:FindFirstAncestor(\"QuickNetwork\") \n\nlocal Settings = require(ancestor.Settings)\nlocal Utility = require(ancestor.AbstractionLayers.Utility)\nlocal Queue = require(ancestor.AbstractionLayers.Queue)\nlocal Signal = require(script.Parent.Signal)\n\nlocal INVALID_ARGUMENT_TYPE = \"Bad argument to #%s: expected %s, got %s\"\n\nlocal QuickNetwork \n\nlocal function Output(message)\n\tif not Settings.Logging then\n\t\treturn\n\tend\n\n\twarn(message)\nend\n\nlocal function DeepCopyTable(tabl)\n\tlocal copiedTable = {}\n\n\tsetmetatable(copiedTable, getmetatable(tabl))\n\n\tfor key, value in pairs(tabl) do\n\t\tif typeof(value) == \"table\" then\n\t\t\tcopiedTable[key] = DeepCopyTable(value)\n\t\telse\n\t\t\tcopiedTable[key] = value\n\t\tend\n\tend\n\n\treturn copiedTable\nend\n\nlocal function ReconcileTable(tabl, reconcileTable)\n\treconcileTable = DeepCopyTable(reconcileTable)\n\t\n\tfor key, value in pairs(reconcileTable) do\n\t\tif typeof(reconcileTable[key]) == \"table\" then\n\t\t\tReconcileTable(tabl[key], reconcileTable[key])\n\t\t\t\n\t\telseif tabl[key] == nil then\n\t\t\ttabl[key] = value \n\t\tend\n\tend\nend\n\nlocal function SerializeData(data)\n\tfor key, value in pairs(data) do\n\t\tif typeof(value) == \"table\" and value.Signal then\n\t\t\tvalue:Disconnect()\n\t\t\tdata[key] = nil\n\n\t\telseif typeof(value) == \"table\" then\n\t\t\tSerializeData(value)\n\n\t\telseif typeof(value) == \"Instance\" then\n\t\t\tdata[key] = nil\n\t\tend\n\tend\nend\n\nlocal function Is_Default_Data(data, defaultDataTemplate)\n\tdata = DeepCopyTable(data)\n\n\tfor key, value in pairs(data) do\n\t\tif key == \"MetaData\" or typeof(value) == \"table\" and value.Signal then\n\t\t\tcontinue\n\t\tend\n\n\t\tif value ~= defaultDataTemplate[key] then\n\t\t\treturn false\n\t\tend\n\tend\n\n\treturn true\nend\n\nfunction Data._Init(module)\n\tQuickNetwork = module\nend\n\nfunction Data:CombineKeysAsync(...)\n\tassert(self:IsActive(), \"Combining keys isn't possible since data was cleared\")\n\tassert(next({...}), \"Keys must not be nil\")\n\n\tlocal dataNetwork = self.MetaData.DataNetwork\t\n\n\tdataNetwork.DataCorruptionSignal:Connect(function()\n\t\treturn \"LoadBackup\"\n\tend)\n\n\tdataNetwork.DataErrorLoadSignal:Connect(function()\n\t\treturn \"LoadBackup\"\n\tend)\n\n\tfor _, key in ipairs({...}) do\n\t\tlocal data = dataNetwork:LoadDataAsync(key, \"Steal\", true)\n\n\t\t-- Skip the current iteration if data is empty:\n\t\tif next(data) == nil then \n\t\t\tcontinue\n\t\tend\n\n\t\tfor key, value in pairs(data) do\n\t\t\tif typeof(value) == \"table\" and value.Signal or key == \"MetaData\" then\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\t\n\t\t\tself:Set(key, value)\n\t\tend\n\tend\n\t\n\tdataNetwork.DataCorruptionSignal:Disconnect()\n\tdataNetwork.DataErrorLoadSignal:Disconnect()\nend\n\nfunction Data:CombineDataStoresAsync(...)\n\tassert(self:IsActive(), \"Combining data stores isn't possible since data was cleared\")\n\tassert(next({...}), \"Data store names must not be nil\")\n\n\tfor _, name in ipairs({...}) do\n\t\tlocal dataNetwork = QuickNetwork.GetDataNetwork(name, {})\n\n\t\tdataNetwork.DataCorruptionSignal:Connect(function()\n\t\t\treturn \"LoadBackup\"\n\t\tend)\n\n\t\tdataNetwork.DataErrorLoadSignal:Connect(function()\n\t\t\treturn \"LoadBackup\"\n\t\tend)\n\n\t\tlocal data = dataNetwork:LoadDataAsync(self.MetaData.Key, \"Steal\", true)\n\n\t\t-- Skip the current iteration if data is empty:\n\t\tif next(data) == nil then \n\t\t\tcontinue\n\t\tend\n\n\t\tfor key, value in pairs(data) do\n\t\t\tif typeof(value) == \"table\" and value.Signal or key == \"MetaData\" then\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\t\n\t\t\tself:Set(key, value)\n\t\tend\n\t\t\n\t\tdataNetwork.DataCorruptionSignal:Disconnect()\n\t\tdataNetwork.DataErrorLoadSignal:Disconnect()\n\tend\nend\n\nfunction Data:Set(key, value)\n\t-- Rare case which needs to be handled:\n\tif self.MetaData.Setting then\n\t\tself.MetaData.Setting:Wait()\n\tend\n\t\n\t-- Same value?\n\tif self[key] == value then\n\t\treturn\n\tend\n\t\n\tself.MetaData.Setting = Signal.new()\n\tself[key] = value\n\tself.MetaData.Updated = true\n\tself.ListenToUpdate:Fire(key, value)\n\t\n\tself.MetaData.Setting:Fire()\n\tself.MetaData.Setting:Disconnect()\n\tself.MetaData.Setting = nil\nend\n\nfunction Data:SetTable(value, ...)\t\n\t-- Rare case which needs to be handled:\n\tif self.MetaData.SettingTable then\n\t\tself.MetaData.SettingTable:Wait()\n\tend\n\t\n\tlocal arguments = {...}\n\tlocal data = self\n\t\n\tfor i, v in ipairs(arguments) do\n\t\t-- Don't loop if we're at the last index since the value at the last index is the index\n\t\tif i ==  #arguments then \n\t\t\tbreak \n\t\tend\n\n\t\tself = self[v]\n\tend\n\t\n\t-- Same value?\n\tif self[arguments[#arguments]] == value then\n\t\treturn\n\tend\n\t\n\tself.MetaData.SettingTable = Signal.new()\n\tself[arguments[#arguments]] = value\n\tself.Updated = true\n\t\n\tdata.ListenToUpdate:Fire(arguments[#arguments], value, self)\n\tself.MetaData.SettingTable:Fire()\n\tself.MetaData.SettingTable:Disconnect()\n\tself.MetaData.SettingTable = nil\nend\n\nfunction Data:IsActive()\n\treturn not self.MetaData.Cleared \nend\n\nfunction Data:IsBackup()\n\treturn self.MetaData.Backup\nend\n\nfunction Data:Save(forceSave) \n\tassert(typeof(forceSave) == \"boolean\" or forceSave == nil, INVALID_ARGUMENT_TYPE:format(1, \"boolean or nil\", typeof(forceSave)))\n\tassert(self:IsActive(), \"Saving data isn't possible since it was cleared\")\n\n\tlocal key = self.MetaData.Key\n\tlocal dataNetwork = self.MetaData.DataNetwork \t\n\t\n\t-- Data is currently being saved?\n\tif self.MetaData.Saving then\n\t\tself.MetaData.Saving:Wait()\n\tend\n\t\n\tif (RunService:IsStudio()) and not Settings.SaveInStudio then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cannot save data in Studio as SaveInStudio is false\"):format(key))\n\t\tself.MetaData.BoundToClear = false\n\t\treturn\n\n\telseif not self.MetaData.Loaded then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cannot save data as it wasn't loaded\"):format(key))\n\t\tself.MetaData.BoundToClear = false\n\t\treturn\n\n\telseif (not self.MetaData.Updated) and (not forceSave) and not self.MetaData.BoundToClear then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cannot save data as it wasn't updated\"):format(key))\n\t\tself.MetaData.BoundToClear = false\n\t\treturn\n\n\telseif (not self.MetaData.SessionLockFree) and not forceSave then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cannot save data as it was previously session locked\"):format(key))\n\t\tself.MetaData.BoundToClear = false\n\t\treturn\n\tend\n\n\tlocal backup = self:IsBackup()\n\n\tif (not Settings.SaveBackups) and backup then\n\t\treturn\n\tend\n\t\n\tself.MetaData.Saving = Signal.new()\n\t\n\tif backup then\n\t\tlocal response = Queue.QueueAPICall({dataNetwork, self, backup}, Utility.Save)\n\n\t\tif response == \"SAVED\" then\n\t\t\tif self.MetaData.BoundToClear then\n\t\t\t\tself._ListenToClear:Fire()\n\t\t\t\tself.MetaData.Cleared = true\n\t\t\t\tself.MetaData.BoundToClear = false\n\t\t\tend\n\t\t\t\n\t\t\tself.MetaData.Updated = false\n\t\t\tself.ListenToSave:Fire(self.MetaData.AutoSaving)\n\t\t\t\n\t\t\tif self.MetaData.AutoSaving then\n\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Auto saved backup data\"):format(key))\n\t\t\t\tself.MetaData.AutoSaving = false\n\t\t\telse\n\t\t\t\tif self.MetaData.BoundToClear then\n\t\t\t\t\tself._ListenToClear:Fire()\n\t\t\t\t\tself.MetaData.Cleared = true\n\t\t\t\t\tself.MetaData.BoundToClear = false\n\t\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cleared backup data\"):format(key))\n\t\t\t\telse\n\t\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Saved backup data\"):format(key))\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tif self.MetaData.BoundToClear then\n\t\t\t\tself.MetaData.BoundToClear = false\n\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Error clearing backup data: %s\"):format(key, response))\n\t\t\telse\n\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Error saving  backup data: %s\"):format(key, response))\n\t\t\tend\n\t\tend\n\telse\n\t\tlocal response = Queue.QueueAPICall({dataNetwork, self, backup}, Utility.Save)\n\n\t\tif response == \"SAVED\" then\n\t\t\tself.MetaData.Updated = false\n\t\t\tself.ListenToSave:Fire(self.MetaData.AutoSaving)\n\t\t\t\n\t\t\tif self.MetaData.AutoSaving then\n\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Auto saved data\"):format(key))\n\t\t\t\tself.MetaData.AutoSaving = false\n\t\t\telse\n\t\t\t\tif self.MetaData.BoundToClear then\n\t\t\t\t\tself._ListenToClear:Fire()\n\t\t\t\t\tself.MetaData.Cleared = true\n\t\t\t\t\tself.MetaData.BoundToClear = false\n\t\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cleared data\"):format(key))\n\t\t\t\telse\n\t\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Saved data\"):format(key))\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tif Settings.SaveBackups then\n\t\t\t\tcoroutine.wrap(Queue.QueueAPICall)({dataNetwork, self, true}, Utility.Save)\n\t\t\tend\n\t\telse\n\t\t\tif self.MetaData.BoundToClear then\n\t\t\t\tself.MetaData.BoundToClear = false\n\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Error clearing data: %s\"):format(key, response))\n\t\t\telse\n\t\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Error saving data: %s\"):format(key, response))\n\t\t\tend\n\t\tend\n\tend\n\t\n\tself.MetaData.Saving:Fire()\n\tself.MetaData.Saving:Disconnect()\n\tself.MetaData.Saving = nil\nend\n\nfunction Data:ClearBackup()\n\tself.MetaData.Backup = false\nend\n\nfunction Data:Clear()\n\tassert(self:IsActive(), \"Clearing data isn't possible since it was cleared\")\n\t\n\tif self.MetaData.BoundToClear then\n\t\treturn\n\tend\n\t\n\tself.MetaData.BoundToClear = true\n\tself:Save()\nend\t\n\nfunction Data:Reconcile() \n\tReconcileTable(self, self.MetaData.DataNetwork.DefaultDataTemplate)\nend\n\nfunction Data:Reset()\n\tfor key, value in pairs(DeepCopyTable(self.MetaData.DataNetwork.DefaultDataTemplate)) do\n\t\tself:Set(key, value)\n\tend\nend\n\nfunction Data:Wipe(forceWipe)\n\tassert(typeof(forceWipe) == \"boolean\" or forceWipe == nil, INVALID_ARGUMENT_TYPE:format(1, \"boolean or nil\", typeof(forceWipe)))\n\tassert(self:IsActive(), \"Wiping data isn't possible since it was cleared\")\n\t\n\t-- Data is currently being wiped?\n\tif self.MetaData.Wiping then\n\t\tself.MetaData.Wiping:Wait()\n\tend\n\t\n\tself.MetaData.Wiping = Signal.new()\n\t\n\tlocal key = self.MetaData.Key\n\tlocal dataNetwork = self.MetaData.DataNetwork\n\t\n\tif not self.MetaData.Loaded then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cannot wipe data as it wasn't loaded\"):format(key))\n\t\treturn\t\t\n\n\telseif (Is_Default_Data(self, dataNetwork.DefaultDataTemplate)) and not forceWipe then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Cannot wipe data as it wasn't updated from the default data\"):format(key))\n\t\treturn\n\n\telseif (self.MetaData.BoundToClear) and not forceWipe then\n\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Wipe request cancelled as data is being cleared\"))\n\t\treturn\n\tend\n\n\tlocal backup = self:IsBackup()\n\n\tif backup then\n\t\tlocal response = Queue.QueueAPICall({dataNetwork, self, backup}, Utility.Wipe)\n\n\t\tif response == \"WIPED\" then\n\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Wiped backup data\"):format(key))\n\t\t\tself:Reset()\n\t\telse\n\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Error wiping backup data: %s\"):format(key, response))\n\t\tend\n\n\t\tself.ListenToWipe:Fire()\n\telse\n\t\tlocal response = Queue.QueueAPICall({dataNetwork, self, backup}, Utility.Wipe)\n\n\t\tif response == \"WIPED\" then\n\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Wiped data\"):format(key))\n\t\t\tself:Reset()\n\t\t\tcoroutine.wrap(Queue.QueueAPICall)({dataNetwork, self, backup}, Utility.Wipe)\n\t\telse\n\t\t\tOutput((\"[QuickNetwork]: [KEY: %s]: Error wiping data: %s\"):format(key, response))\n\t\tend\n\tend\n\t\n\tself.MetaData.Wiping:Fire()\n\tself.MetaData.Wiping:Disconnect()\n\tself.MetaData.Wiping = nil\nend\n\nreturn Data",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25828, time: 142155861, random: 1232354692393223026 })>"
}