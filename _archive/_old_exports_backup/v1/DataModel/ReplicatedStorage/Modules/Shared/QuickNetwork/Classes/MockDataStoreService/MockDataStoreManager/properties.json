{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{D9871A46-80EB-4174-B3DB-D9D93B34DAF0}",
  "Source": "--[[\n\tMockDataStoreManager.lua\n\tThis module does bookkeeping of data, interfaces and request limits used by MockDataStoreService and its sub-classes.\n\n\tThis module is licensed under APLv2, refer to the LICENSE file or:\n\thttps://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE\n]]\n\nlocal MockDataStoreManager = {}\n\nlocal Utils = require(script.Parent.MockDataStoreUtils)\nlocal Constants = require(script.Parent.MockDataStoreConstants)\nlocal HttpService = game:GetService(\"HttpService\") -- for json encode/decode\nlocal Players = game:GetService(\"Players\") -- for restoring budgets\nlocal RunService = game:GetService(\"RunService\") -- for checking if running context is on server\n\nlocal ConstantsMapping = {\n\t[Enum.DataStoreRequestType.GetAsync] = Constants.BUDGET_GETASYNC;\n\t[Enum.DataStoreRequestType.GetSortedAsync] = Constants.BUDGET_GETSORTEDASYNC;\n\t[Enum.DataStoreRequestType.OnUpdate] = Constants.BUDGET_ONUPDATE;\n\t[Enum.DataStoreRequestType.SetIncrementAsync] = Constants.BUDGET_SETINCREMENTASYNC;\n\t[Enum.DataStoreRequestType.SetIncrementSortedAsync] = Constants.BUDGET_SETINCREMENTSORTEDASYNC;\n}\n\n-- Bookkeeping of all data:\nlocal Data = {\n\tGlobalDataStore = {};\n\tDataStore = {};\n\tOrderedDataStore = {};\n}\n\n-- Bookkeeping of all active GlobalDataStore/OrderedDataStore interfaces indexed by data table:\nlocal Interfaces = {}\n\n-- Request limit bookkeeping:\nlocal Budgets = {}\n\nlocal budgetRequestQueues = {\n\t[Enum.DataStoreRequestType.GetAsync] = {};\n\t[Enum.DataStoreRequestType.GetSortedAsync] = {};\n\t[Enum.DataStoreRequestType.OnUpdate] = {};\n\t[Enum.DataStoreRequestType.SetIncrementAsync] = {};\n\t[Enum.DataStoreRequestType.SetIncrementSortedAsync] = {};\n}\n\nlocal function initBudget()\n\tfor requestType, const in pairs(ConstantsMapping) do\n\t\tBudgets[requestType] = const.START\n\tend\n\tBudgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(\n\t\tBudgets[Enum.DataStoreRequestType.GetAsync],\n\t\tBudgets[Enum.DataStoreRequestType.SetIncrementAsync]\n\t)\nend\n\nlocal function updateBudget(req, const, dt, n)\n\tif not Constants.BUDGETING_ENABLED then\n\t\treturn\n\tend\n\tlocal rate = const.RATE + n * const.RATE_PLR\n\tBudgets[req] = math.min(\n\t\tBudgets[req] + dt * rate,\n\t\tconst.MAX_FACTOR * rate\n\t)\nend\n\nlocal function stealBudget(budget)\n\tif not Constants.BUDGETING_ENABLED then\n\t\treturn\n\tend\n\tfor _, requestType in pairs(budget) do\n\t\tif Budgets[requestType] then\n\t\t\tBudgets[requestType] = math.max(0, Budgets[requestType] - 1)\n\t\tend\n\tend\n\tBudgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(\n\t\tBudgets[Enum.DataStoreRequestType.GetAsync],\n\t\tBudgets[Enum.DataStoreRequestType.SetIncrementAsync]\n\t)\nend\n\nlocal function checkBudget(budget)\n\tif not Constants.BUDGETING_ENABLED then\n\t\treturn true\n\tend\n\tfor _, requestType in pairs(budget) do\n\t\tif Budgets[requestType] and Budgets[requestType] < 1 then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend\n\nlocal isFrozen = false\n\nif RunService:IsServer() then\n\t-- Only do budget/throttle updating on server (in case package required on client)\n\n\tinitBudget()\n\n\tcoroutine.wrap(function() -- Thread that increases budgets and de-throttles requests periodically\n\t\tlocal lastCheck = tick()\n\t\twhile Utils.accurateWait(Constants.BUDGET_UPDATE_INTERVAL) do\n\t\t\tlocal now = tick()\n\t\t\tlocal dt = (now - lastCheck) / 60\n\t\t\tlastCheck = now\n\t\t\tlocal n = #Players:GetPlayers()\n\n\t\t\tif not isFrozen then\n\t\t\t\tfor requestType, const in pairs(ConstantsMapping) do\n\t\t\t\t\tupdateBudget(requestType, const, dt, n)\n\t\t\t\tend\n\t\t\t\tBudgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(\n\t\t\t\t\tBudgets[Enum.DataStoreRequestType.GetAsync],\n\t\t\t\t\tBudgets[Enum.DataStoreRequestType.SetIncrementAsync]\n\t\t\t\t)\n\t\t\tend\n\n\t\t\tfor _, budgetRequestQueue in pairs(budgetRequestQueues) do\n\t\t\t\tfor i = #budgetRequestQueue, 1, -1 do\n\t\t\t\t\tlocal request = budgetRequestQueue[i]\n\n\t\t\t\t\tlocal thread = request.Thread\n\t\t\t\t\tlocal budget = request.Budget\n\t\t\t\t\tlocal key = request.Key\n\t\t\t\t\tlocal lock = request.Lock\n\t\t\t\t\tlocal cache = request.Cache\n\n\t\t\t\t\tif not (lock and (lock[key] or tick() - (cache[key] or 0) < Constants.WRITE_COOLDOWN)) and checkBudget(budget) then\n\t\t\t\t\t\ttable.remove(budgetRequestQueue, i)\n\t\t\t\t\t\tstealBudget(budget)\n\t\t\t\t\t\tcoroutine.resume(thread)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)()\n\n\tgame:BindToClose(function()\n\t\tfor requestType, const in pairs(ConstantsMapping) do\n\t\t\tBudgets[requestType] = math.max(\n\t\t\t\tBudgets[requestType],\n\t\t\t\tConstants.BUDGET_ONCLOSE_BASE * (const.RATE / Constants.BUDGET_BASE)\n\t\t\t)\n\t\tend\n\t\tBudgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(\n\t\t\tBudgets[Enum.DataStoreRequestType.GetAsync],\n\t\t\tBudgets[Enum.DataStoreRequestType.SetIncrementAsync]\n\t\t)\n\tend)\n\nend\n\nfunction MockDataStoreManager.GetGlobalData()\n\treturn Data.GlobalDataStore\nend\n\nfunction MockDataStoreManager.GetData(name, scope)\n\tassert(type(name) == \"string\")\n\tassert(type(scope) == \"string\")\n\n\tif not Data.DataStore[name] then\n\t\tData.DataStore[name] = {}\n\tend\n\tif not Data.DataStore[name][scope] then\n\t\tData.DataStore[name][scope] = {}\n\tend\n\n\treturn Data.DataStore[name][scope]\nend\n\nfunction MockDataStoreManager.GetOrderedData(name, scope)\n\tassert(type(name) == \"string\")\n\tassert(type(scope) == \"string\")\n\n\tif not Data.OrderedDataStore[name] then\n\t\tData.OrderedDataStore[name] = {}\n\tend\n\tif not Data.OrderedDataStore[name][scope] then\n\t\tData.OrderedDataStore[name][scope] = {}\n\tend\n\n\treturn Data.OrderedDataStore[name][scope]\nend\n\nfunction MockDataStoreManager.GetDataInterface(data)\n\treturn Interfaces[data]\nend\n\nfunction MockDataStoreManager.SetDataInterface(data, interface)\n\tassert(type(data) == \"table\")\n\tassert(type(interface) == \"table\")\n\n\tInterfaces[data] = interface\nend\n\nfunction MockDataStoreManager.GetBudget(requestType)\n\tif Constants.BUDGETING_ENABLED then\n\t\treturn math.floor(Budgets[requestType] or 0)\n\telse\n\t\treturn math.huge\n\tend\nend\n\nfunction MockDataStoreManager.SetBudget(requestType, budget)\n\tassert(type(budget) == \"number\")\n\tbudget = math.max(budget, 0)\n\n\tif requestType == Enum.DataStoreRequestType.UpdateAsync then\n\t\tBudgets[Enum.DataStoreRequestType.SetIncrementAsync] = budget\n\t\tBudgets[Enum.DataStoreRequestType.GetAsync] = budget\n\tend\n\n\tif Budgets[requestType] then\n\t\tBudgets[requestType] = budget\n\tend\nend\n\nfunction MockDataStoreManager.ResetBudget()\n\tinitBudget()\nend\n\nfunction MockDataStoreManager.FreezeBudgetUpdates()\n\tisFrozen = true\nend\n\nfunction MockDataStoreManager.ThawBudgetUpdates()\n\tisFrozen = false\nend\n\nfunction MockDataStoreManager.YieldForWriteLockAndBudget(callback, key, writeLock, writeCache, budget)\n\tassert(type(callback) == \"function\")\n\tassert(type(key) == \"string\")\n\tassert(type(writeLock) == \"table\")\n\tassert(type(writeCache) == \"table\")\n\tassert(#budget > 0)\n\n\tlocal mainRequestType = budget[1]\n\n\tif #budgetRequestQueues[mainRequestType] >= Constants.THROTTLE_QUEUE_SIZE then\n\t\treturn false -- no room in throttle queue\n\tend\n\n\tcallback() -- would i.e. trigger a warning in output\n\n\ttable.insert(budgetRequestQueues[mainRequestType], 1, {\n\t\tKey = key;\n\t\tLock = writeLock;\n\t\tCache = writeCache;\n\t\tThread = coroutine.running();\n\t\tBudget = budget;\n\t})\n\tcoroutine.yield()\n\n\treturn true\nend\n\nfunction MockDataStoreManager.YieldForBudget(callback, budget)\n\tassert(type(callback) == \"function\")\n\tassert(#budget > 0)\n\n\tlocal mainRequestType = budget[1]\n\n\tif checkBudget(budget) then\n\t\tstealBudget(budget)\n\telseif #budgetRequestQueues[mainRequestType] >= Constants.THROTTLE_QUEUE_SIZE then\n\t\treturn false -- no room in throttle queue\n\telse\n\t\tcallback() -- would i.e. trigger a warning in output\n\n\t\ttable.insert(budgetRequestQueues[mainRequestType], 1, {\n\t\t\tAfter = 0; -- no write lock\n\t\t\tThread = coroutine.running();\n\t\t\tBudget = budget;\n\t\t})\n\t\tcoroutine.yield()\n\tend\n\n\treturn true\nend\n\nfunction MockDataStoreManager.ExportToJSON()\n\tlocal export = {}\n\n\tif next(Data.GlobalDataStore) ~= nil then -- GlobalDataStore not empty\n\t\texport.GlobalDataStore = Data.GlobalDataStore\n\tend\n\texport.DataStore = Utils.prepareDataStoresForExport(Data.DataStore) -- can be nil\n\texport.OrderedDataStore = Utils.prepareDataStoresForExport(Data.OrderedDataStore) -- can be nil\n\n\treturn HttpService:JSONEncode(export)\nend\n\n-- Import into an entire datastore type:\nlocal function importDataStoresFromTable(origin, destination, warnFunc, methodName, prefix, isOrdered)\n\tfor name, scopes in pairs(origin) do\n\t\tif type(name) ~= \"string\" then\n\t\t\twarnFunc((\"%s: ignored %s > %q (name is not a string, but a %s)\")\n\t\t\t\t:format(methodName, prefix, tostring(name), typeof(name)))\n\t\telseif type(scopes) ~= \"table\" then\n\t\t\twarnFunc((\"%s: ignored %s > %q (scope list is not a table, but a %s)\")\n\t\t\t\t:format(methodName, prefix, name, typeof(scopes)))\n\t\telseif #name == 0 then\n\t\t\twarnFunc((\"%s: ignored %s > %q (name is an empty string)\")\n\t\t\t\t:format(methodName, prefix, name))\n\t\telseif #name > Constants.MAX_LENGTH_NAME then\n\t\t\twarnFunc((\"%s: ignored %s > %q (name exceeds %d character limit)\")\n\t\t\t\t:format(methodName, prefix, name, Constants.MAX_LENGTH_NAME))\n\t\telse\n\t\t\tfor scope, data in pairs(scopes) do\n\t\t\t\tif type(scope) ~= \"string\" then\n\t\t\t\t\twarnFunc((\"%s: ignored %s > %q > %q (scope is not a string, but a %s)\")\n\t\t\t\t\t\t:format(methodName, prefix, name, tostring(scope), typeof(scope)))\n\t\t\t\telseif type(data) ~= \"table\" then\n\t\t\t\t\twarnFunc((\"%s: ignored %s > %q > %q (data list is not a table, but a %s)\")\n\t\t\t\t\t\t:format(methodName, prefix, name, scope, typeof(data)))\n\t\t\t\telseif #scope == 0 then\n\t\t\t\t\twarnFunc((\"%s: ignored %s > %q > %q (scope is an empty string)\")\n\t\t\t\t\t\t:format(methodName, prefix, name, scope))\n\t\t\t\telseif #scope > Constants.MAX_LENGTH_SCOPE then\n\t\t\t\t\twarnFunc((\"%s: ignored %s > %q > %q (scope exceeds %d character limit)\")\n\t\t\t\t\t\t:format(methodName, prefix, name, scope, Constants.MAX_LENGTH_SCOPE))\n\t\t\t\telse\n\t\t\t\t\tif not destination[name] then\n\t\t\t\t\t\tdestination[name] = {}\n\t\t\t\t\tend\n\t\t\t\t\tif not destination[name][scope] then\n\t\t\t\t\t\tdestination[name][scope] = {}\n\t\t\t\t\tend\n\t\t\t\t\tUtils.importPairsFromTable(\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tdestination[name][scope],\n\t\t\t\t\t\tInterfaces[destination[name][scope]],\n\t\t\t\t\t\twarnFunc,\n\t\t\t\t\t\tmethodName,\n\t\t\t\t\t\t(\"%s > %q > %q\"):format(prefix, name, scope),\n\t\t\t\t\t\tisOrdered\n\t\t\t\t\t)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction MockDataStoreManager.ImportFromJSON(content, verbose)\n\tassert(type(content) == \"table\")\n\tassert(verbose == nil or type(verbose) == \"boolean\")\n\n\tlocal warnFunc = warn -- assume verbose as default\n\tif verbose == false then -- intentional formatting\n\t\twarnFunc = function() end\n\tend\n\n\tif type(content.GlobalDataStore) == \"table\" then\n\t\tUtils.importPairsFromTable(\n\t\t\tcontent.GlobalDataStore,\n\t\t\tData.GlobalDataStore,\n\t\t\tInterfaces[Data.GlobalDataStore],\n\t\t\twarnFunc,\n\t\t\t\"ImportFromJSON\",\n\t\t\t\"GlobalDataStore\",\n\t\t\tfalse\n\t\t)\n\tend\n\tif type(content.DataStore) == \"table\" then\n\t\timportDataStoresFromTable(\n\t\t\tcontent.DataStore,\n\t\t\tData.DataStore,\n\t\t\twarnFunc,\n\t\t\t\"ImportFromJSON\",\n\t\t\t\"DataStore\",\n\t\t\tfalse\n\t\t)\n\tend\n\tif type(content.OrderedDataStore) == \"table\" then\n\t\timportDataStoresFromTable(\n\t\t\tcontent.OrderedDataStore,\n\t\t\tData.OrderedDataStore,\n\t\t\twarnFunc,\n\t\t\t\"ImportFromJSON\",\n\t\t\t\"OrderedDataStore\",\n\t\t\ttrue\n\t\t)\n\tend\nend\n\nlocal function clearTable(t)\n\tfor i,_ in pairs(t) do\n\t\tt[i] = nil\n\tend\nend\n\nfunction MockDataStoreManager.ResetData()\n\tfor _, interface in pairs(Interfaces) do\n\t\tfor key, _ in pairs(interface.__data) do\n\t\t\tinterface.__data[key] = nil\n\t\t\tinterface.__event:Fire(key, nil)\n\t\tend\n\t\tinterface.__getCache = {}\n\t\tinterface.__writeCache = {}\n\t\tinterface.__writeLock = {}\n\t\tif interface.__sorted then\n\t\t\tinterface.__sorted = {};\n            interface.__ref = {};\n            interface.__changed = false;\n\t\tend\n\tend\n\n\tclearTable(Data.GlobalDataStore)\n\n\tfor _, scopes in pairs(Data.DataStore) do\n\t\tfor _, data in pairs(scopes) do\n\t\t\tclearTable(data)\n\t\tend\n\tend\n\n\tfor _, scopes in pairs(Data.OrderedDataStore) do\n\t\tfor _, data in pairs(scopes) do\n\t\t\tclearTable(data)\n\t\tend\n\tend\nend\n\nreturn MockDataStoreManager\n",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25832, time: 142155861, random: 1232354692393223026 })>"
}