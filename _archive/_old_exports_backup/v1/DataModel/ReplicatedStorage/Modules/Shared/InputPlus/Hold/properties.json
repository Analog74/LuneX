{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{A18D01F2-8B64-4CF0-90FD-1C2B0F724423}",
  "Source": "local hold = {}\nlocal ActiveHolds = {}\nlocal utils = require(script.Parent.Utils)\n\nlocal HoldTable = {\n\tDestroy = function(self)\n\t\tlocal Info = ActiveHolds[self.Index]\n\t\tif Info then\n\t\t\tInfo.Start:Destroy()\n\t\t\tInfo.End:Destroy()\n\t\t\ttable.remove(ActiveHolds,self.Index)\n\t\tend\n\tend,\n\tCancel = function(self)\n\t\tlocal Info = ActiveHolds[self.Index]\n\t\tif Info then\n\t\t\tif Info.Progress[1] then\n\t\t\t\ttable.remove(Info.Progress,1)\n\t\t\tend\n\t\tend\n\tend,\n}\n\nhold.new = function(...)\n\tlocal Keys = {...}\n\tif #Keys == 0 then warn('Atleast one key required for the holder') return end\n\tlocal Name = ''\n\tfor i , v in ipairs(Keys) do\n\t\tName ..= utils.GetKeyFromEnum(v)\n\t\tif i ~= #Keys then\n\t\t\tName ..= '+'\n\t\tend\n\tend\n\n\tif utils.CheckDuplicate(ActiveHolds,nil,Name) then warn('A holder with the same keys already exist') return end\n\n\n\tlocal Start = Instance.new('BindableEvent')\n\tStart.Name = 'Hold'..Name..'Start'\n\tStart.Parent = game.ReplicatedStorage.EventStorage\n\n\tlocal End = Instance.new('BindableEvent')\n\tEnd.Name = 'Hold'..Name..'End'\n\tEnd.Parent = game.ReplicatedStorage.EventStorage\n\n\tlocal Hold = Instance.new('BindableEvent')\n\tHold.Name = 'Hold'..Name..'Hold'\n\tHold.Parent = game.ReplicatedStorage.EventStorage\n\n\ttable.insert(ActiveHolds,{\n\t\tName = Name,\n\t\tKeys = Keys,\n\t\tProgress = {},\n\t\tEnabled = true,\n\t\tIndex = #ActiveHolds + 1,\n\t\tHolding = false,\n\t\tStart = Start,\n\t\tEnd = End,\n\t\tHold = Hold\n\t})\n\tlocal Clone = {}\n\n\tClone.Start = Start.Event\n\tClone.End = End.Event\n\tClone.Hold = Hold.Event\n\tClone.Index = #ActiveHolds\n\n\tfor i,v in pairs(HoldTable) do\n\t\tClone[i] = v\n\tend\n\n\treturn Clone\nend\n\nhold.HookStart = function(Input,gp)\n\tfor _ , v in ipairs(ActiveHolds) do\n\t\tif v.Enabled then\n\t\t\tlocal Index = table.find(v.Keys,Input.KeyCode) or table.find(v.Keys,Input.UserInputType)\n\t\t\tif Index then\n\t\t\t\ttable.insert(v.Progress,true)\n\t\t\t\tv.Hold:Fire(v.Keys[Index],gp)\n\t\t\t\tif #v.Progress == #v.Keys and not v.Holding then\n\t\t\t\t\tv.Holding = true\n\t\t\t\t\tv.Start:Fire(#v.Keys == 1 and gp)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nhold.HookEnd = function(Input)\n\tfor _ , v in ipairs(ActiveHolds) do\n\t\tif v.Enabled then\n\t\t\tlocal Index = table.find(v.Keys,Input.KeyCode) or table.find(v.Keys,Input.UserInputType)\n\t\t\tif Index then\n\t\t\t\tif v.Progress[1] then\n\t\t\t\t\ttable.remove(v.Progress,1)\n\t\t\t\tend\n\t\t\t\tif v.Holding then\n\t\t\t\t\tv.Holding = false\n\t\t\t\t\tv.End:Fire()\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nreturn hold\n",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25783, time: 142155861, random: 1232354692393223026 })>"
}