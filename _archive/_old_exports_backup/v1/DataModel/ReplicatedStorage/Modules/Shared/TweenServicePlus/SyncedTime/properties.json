{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{893A2418-AADA-4340-B118-6342A521B4EE}",
  "Source": "--Made by Quenty and not by me\n--- Syncronize time between client and servers so we can use a universal timestamp\n-- across the game.\n-- See: www.nist.gov/el/isd/ieee/upload/tutorial-basic.pdf\n-- @classmod TimeSyncManager\n-- @usage Use use just require the module, it's a singleton. Load TimeSyncManager on the server to use on the clients.\n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal MasterClock = {}\nMasterClock.__index = MasterClock\nMasterClock.ClassName = \"MasterClock\"\n\nfunction MasterClock.new(remoteEvent, remoteFunction)\n\tlocal self = setmetatable({}, MasterClock)\n\n\tself._remoteEvent = remoteEvent or error(\"No remoteEvent\")\n\tself._remoteFunction = remoteFunction or error(\"No remoteFunction\")\n\n\tself._remoteFunction.OnServerInvoke = function(player, timeThree)\n\t\treturn self:_handleDelayRequest(timeThree)\n\tend\n\tself._remoteEvent.OnServerEvent:Connect(function(player)\n\t\t self._remoteEvent:FireClient(player, self:GetTime())\n\tend)\n\n\tspawn(function()\n\t\twhile true do\n\t\t\twait(3.5)\n\t\t\tself:Sync()\n\t\tend\n\tend)\n\n\treturn self\nend\n\n--- Returns true if the manager has synced with the server\n-- @treturn boolean\nfunction MasterClock:IsSynced()\n\treturn true\nend\n\n--- Returns the sycncronized time\n-- @treturn number current time\nfunction MasterClock:GetTime()\n\treturn tick()\nend\n\n--- Starts the sync process with all slave clocks.\nfunction MasterClock:Sync()\n\tlocal timeOne = self:GetTime()\n\t--print(\"Syncing\")\n    self._remoteEvent:FireAllClients(timeOne)\nend\n\n--- Client sends back message to get the SM_Difference.\n-- @return slaveMasterDifference\nfunction MasterClock:_handleDelayRequest(timeThree)\n    local TimeFour = self:GetTime()\n    return TimeFour - timeThree -- -offset + SM Delay\nend\n\n\nlocal SlaveClock = {}\nSlaveClock.__index = SlaveClock\nSlaveClock.ClassName = \"SlaveClock\"\nSlaveClock._offset = -1 -- Set uncalculated values to -1\n\nfunction SlaveClock.new(remoteEvent, remoteFunction)\n\tlocal self = setmetatable({}, SlaveClock)\n\n\tself._remoteEvent = remoteEvent or error(\"No remoteEvent\")\n\tself._remoteFunction = remoteFunction or error(\"No remoteFunction\")\n\n\tself._remoteEvent.OnClientEvent:Connect(function(timeOne)\n\t\tself:_handleSyncEvent(timeOne)\n\tend)\n\n\tself._remoteEvent:FireServer() -- Request server to syncronize with us\n\n\treturn self\nend\n\nfunction SlaveClock:GetTime()\n\tif not self:IsSynced() then\n\t\twarn(\"[SlaveClock][GetTime] - Slave clock is not yet synced\")\n\t\treturn self:_getLocalTime()\n\tend\n\n\treturn self:_getLocalTime() - self._offset\nend\n\nfunction SlaveClock:IsSynced()\n\treturn self._offset ~= -1\nend\n\nfunction SlaveClock:_getLocalTime()\n    return tick()\nend\n\nfunction SlaveClock:_handleSyncEvent(timeOne)\n    local timeTwo = self:_getLocalTime() -- We can't actually get hardware stuff, so we'll send T1 immediately.\n    local masterSlaveDifference = timeTwo - timeOne -- We have Offst + MS Delay\n\n    local timeThree = self:_getLocalTime()\n    local slaveMasterDifference = self:_sendDelayRequest(timeThree)\n\n    --[[ From explination link.\n        The result is that we have the following two equations:\n        MS_difference = offset + MS delay\n        SM_difference = ?offset + SM delay\n        With two measured quantities:\n        MS_difference = 90 minutes\n        SM_difference = ?20 minutes\n        And three unknowns:\n        offset , MS delay, and SM delay\n        Rearrange the equations according to the tutorial.\n        -- Assuming this: MS delay = SM delay = one_way_delay\n        one_way_delay = (MSDelay + SMDelay) / 2\n    ]]\n\n    local offset = (masterSlaveDifference - slaveMasterDifference)/2\n    local oneWayDelay = (masterSlaveDifference + slaveMasterDifference)/2\n\n    self._offset = offset -- Estimated difference between server/client\n    self._pneWayDelay = oneWayDelay -- Estimated time for network events to send. (MSDelay/SMDelay)\nend\n\nfunction SlaveClock:_sendDelayRequest(timeThree)\n\treturn self._remoteFunction:InvokeServer(timeThree)\nend\n\n\n--- Return a singleton\nlocal function buildClock()\n\n\tlocal remoteEvent = script:WaitForChild(\"TimeSyncEvent\")\n\tlocal remoteFunction = script:WaitForChild(\"DelayedRequestEvent\")\n\n\tif RunService:IsClient() and RunService:IsServer() then -- Solo test mode\n\t\tlocal clock = MasterClock.new(remoteEvent, remoteFunction)\n\t\tremoteEvent.OnClientEvent:Connect(function() end)\n\t\treturn clock\n\telseif RunService:IsClient() then\n\t\treturn SlaveClock.new(remoteEvent, remoteFunction)\n\telse\n\t\treturn MasterClock.new(remoteEvent, remoteFunction)\n\tend\nend\n\nreturn buildClock()\n",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25867, time: 142155861, random: 1232354692393223026 })>"
}