{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{808AA158-990C-4C05-AAD2-9374521ADE7A}",
  "Source": "--[[\n\nThis is a Rotated Region3 Class that behaves much the same as the standard Region3 class expect that it allows\nfor both rotated regions and also a varying array of shapes.\t\n\nAPI:\n\nConstructors:\n\tRotatedRegion3.new(CFrame cframe, Vector3 size)\n\t\t> Creates a region from a cframe which acts as the center of the region and size which extends to \n\t\t> the corners like a block part.\n\tRotatedRegion3.Block(CFrame cframe, Vector3 size)\n\t\t> This is the exact same as the region.new constructor, but has a different name.\n\tRotatedRegion3.Wedge(CFrame cframe, Vector3 size)\n\t\t> Creates a region from a cframe which acts as the center of the region and size which extends to \n\t\t> the corners like a wedge part.\n\tRotatedRegion3.CornerWedge(CFrame cframe, Vector3 size)\n\t\t> Creates a region from a cframe which acts as the center of the region and size which extends to \n\t\t> the corners like a cornerWedge part.\n\tRotatedRegion3.Cylinder(CFrame cframe, Vector3 size)\n\t\t> Creates a region from a cframe which acts as the center of the region and size which extends to \n\t\t> the corners like a cylinder part.\n\tRotatedRegion3.Ball(CFrame cframe, Vector3 size)\n\t\t> Creates a region from a cframe which acts as the center of the region and size which extends to \n\t\t> the corners like a ball part.\n\tRotatedRegion3.FromPart(part)\n\t\t> Creates a region from a part in the game. It can be used on any base part, but the region \n\t\t> will treat unknown shapes (meshes, unions, etc) as block shapes.\n\nMethods:\n\tRotatedRegion3:CastPoint(Vector3 point)\n\t\t> returns true or false if the point is within the RotatedRegion3 object\n\tRotatedRegion3:CastPart(BasePart part)\n\t\t> returns true or false if the part is withing the RotatedRegion3 object\n\tRotatedRegion3:FindPartsInRegion3(Instance ignore, Integer maxParts)\n\t\t> returns array of parts in the RotatedRegion3 object\n\t\t> will return a maximum number of parts in array [maxParts] the default is 20\n\t\t> parts that either are descendants of or actually are the [ignore] instance will be ignored\n\tRotatedRegion3:FindPartsInRegion3WithIgnoreList(Instance Array ignore, Integer maxParts)\n\t\t> returns array of parts in the RotatedRegion3 object\n\t\t> will return a maximum number of parts in array [maxParts] the default is 20\n\t\t> parts that either are descendants of the [ignore array] or actually are the [ignore array] instances will be ignored\n\tRotatedRegion3:FindPartsInRegion3WithWhiteList(Instance Array whiteList, Integer maxParts)\n\t\t> returns array of parts in the RotatedRegion3 object\n\t\t> will return a maximum number of parts in array [maxParts] the default is 20\n\t\t> parts that either are descendants of the [whiteList array] or actually are the [whiteList array] instances are all that will be checked\n\tRotatedRegion3:Cast(Instance or Instance Array ignore, Integer maxParts)\n\t\t> Same as the `:FindPartsInRegion3WithIgnoreList` method, but will check if the ignore argument is an array or single instance\n\nProperties:\n\tRotatedRegion3.CFrame\n\t\t> cframe that represents the center of the region\n\tRotatedRegion3.Size\n\t\t> vector3 that represents the size of the region\n\tRotatedRegion3.Shape\n\t\t> string that represents the shape type of the RotatedRegion3 object\n\tRotatedRegion3.Set\n\t\t> array of vector3 that are passed to the support function\n\tRotatedRegion3.Support\n\t\t> function that is used for support in the GJK algorithm\n\tRotatedRegion3.Centroid\n\t\t> vector3 that represents the center of the set, again used for the GJK algorithm\n\tRotatedRegion3.AlignedRegion3\n\t\t> standard region3 that represents the world bounding box of the RotatedRegion3 object\n\nNote: I haven't actually done anything to enforce this, but you should treat all these properties as read only\n\nEnjoy!\n- EgoMoose\n\n--]]\n\n--\n\nlocal GJK = require(script:WaitForChild(\"GJK\"))\nlocal Supports = require(script:WaitForChild(\"Supports\"))\nlocal Vertices = require(script:WaitForChild(\"Vertices\"))\n\n-- Class\n\nlocal RotatedRegion3 = {}\nRotatedRegion3.__index = RotatedRegion3\n\n-- Private functions\n\nlocal function getCorners(cf, s2)\n\treturn {\n\t\tcf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, -s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, -s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(s2.x, s2.y, -s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(s2.x, s2.y, s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, s2.z));\n\t\tcf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, -s2.z));\n\t}\nend\n\nlocal function worldBoundingBox(set)\n\tlocal x, y, z = {}, {}, {}\n\tfor i = 1, #set do x[i], y[i], z[i] = set[i].x, set[i].y, set[i].z end\n\tlocal min = Vector3.new(math.min(unpack(x)), math.min(unpack(y)), math.min(unpack(z)))\n\tlocal max = Vector3.new(math.max(unpack(x)), math.max(unpack(y)), math.max(unpack(z)))\n\treturn min, max\nend\n\n-- Public Constructors\n\nfunction RotatedRegion3.new(cframe, size)\n\tlocal self = setmetatable({}, RotatedRegion3)\n\t\n\tself.CFrame = cframe\n\tself.Size = size\n\tself.Shape = \"Block\"\n\t\n\tself.Set = Vertices.Block(cframe, size/2)\n\tself.Support = Supports.PointCloud\n\tself.Centroid = cframe.p\n\t\n\tself.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))\n\n\treturn self\nend\n\nRotatedRegion3.Block = RotatedRegion3.new\n\nfunction RotatedRegion3.Wedge(cframe, size)\n\tlocal self = setmetatable({}, RotatedRegion3)\n\n\tself.CFrame = cframe\n\tself.Size = size\n\tself.Shape = \"Wedge\"\n\t\n\tself.Set = Vertices.Wedge(cframe, size/2)\n\tself.Support = Supports.PointCloud\n\tself.Centroid = Vertices.GetCentroid(self.Set)\n\t\n\tself.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))\n\n\treturn self\nend\n\nfunction RotatedRegion3.CornerWedge(cframe, size)\n\tlocal self = setmetatable({}, RotatedRegion3)\n\n\tself.CFrame = cframe\n\tself.Size = size\n\tself.Shape = \"CornerWedge\"\n\t\n\tself.Set = Vertices.CornerWedge(cframe, size/2)\n\tself.Support = Supports.PointCloud\n\tself.Centroid = Vertices.GetCentroid(self.Set)\n\t\n\tself.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))\n\n\treturn self\nend\n\nfunction RotatedRegion3.Cylinder(cframe, size)\n\tlocal self = setmetatable({}, RotatedRegion3)\n\n\tself.CFrame = cframe\n\tself.Size = size\n\tself.Shape = \"Cylinder\"\n\t\n\tself.Set = {cframe, size/2}\n\tself.Support = Supports.Cylinder\n\tself.Centroid = cframe.p\n\t\n\tself.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))\n\n\treturn self\nend\n\nfunction RotatedRegion3.Ball(cframe, size)\n\tlocal self = setmetatable({}, RotatedRegion3)\n\n\tself.CFrame = cframe\n\tself.Size = size\n\tself.Shape = \"Ball\"\n\t\n\tself.Set = {cframe, size/2}\n\tself.Support = Supports.Ellipsoid\n\tself.Centroid = cframe.p\n\t\n\tself.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))\n\n\treturn self\nend\n\nfunction RotatedRegion3.FromPart(part)\n\treturn RotatedRegion3[Vertices.Classify(part)](part.CFrame, part.Size)\nend\n\n-- Public Constructors\n\nfunction RotatedRegion3:CastPoint(point)\n\tlocal gjk = GJK.new(self.Set, {point}, self.Centroid, point, self.Support, Supports.PointCloud)\n\treturn gjk:IsColliding()\nend\n\nfunction RotatedRegion3:CastPart(part)\n\tlocal r3 = RotatedRegion3.FromPart(part)\n\tlocal gjk = GJK.new(self.Set, r3.Set, self.Centroid, r3.Centroid, self.Support, r3.Support)\n\treturn gjk:IsColliding()\nend\n\nfunction RotatedRegion3:FindPartsInRegion3(ignore, maxParts)\n\tlocal found = {}\n\tlocal parts = game.Workspace:FindPartsInRegion3(self.AlignedRegion3, ignore, maxParts)\n\tfor i = 1, #parts do\n\t\tif (self:CastPart(parts[i])) then\n\t\t\ttable.insert(found, parts[i])\n\t\tend\n\tend\n\treturn found\nend\n\nfunction RotatedRegion3:FindPartsInRegion3WithIgnoreList(ignore, maxParts)\n\tignore = ignore or {}\n\tlocal found = {}\n\tlocal parts = game.Workspace:FindPartsInRegion3WithIgnoreList(self.AlignedRegion3, ignore, maxParts)\n\tfor i = 1, #parts do\n\t\tif (self:CastPart(parts[i])) then\n\t\t\ttable.insert(found, parts[i])\n\t\tend\n\tend\n\treturn found\nend\n\nfunction RotatedRegion3:FindPartsInRegion3WithWhiteList(whiteList, maxParts)\n\twhiteList = whiteList or {}\n\tlocal found = {}\n\tlocal parts = game.Workspace:FindPartsInRegion3WithWhiteList(self.AlignedRegion3, whiteList, maxParts)\n\tfor i = 1, #parts do\n\t\tif (self:CastPart(parts[i])) then\n\t\t\ttable.insert(found, parts[i])\n\t\tend\n\tend\n\treturn found\nend\n\nfunction RotatedRegion3:Cast(ignore, maxParts)\n\tignore = type(ignore) == \"table\" and ignore or {ignore}\n\treturn self:FindPartsInRegion3WithIgnoreList(ignore, maxParts)\nend\n\n--\n\nreturn RotatedRegion3",
  "SourceAssetId": "<unsupported: Int64(-1)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25861, time: 142155861, random: 1232354692393223026 })>"
}