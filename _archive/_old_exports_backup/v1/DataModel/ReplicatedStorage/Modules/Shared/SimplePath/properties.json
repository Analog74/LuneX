{
  "Attributes": "<unsupported: Attributes(Attributes { data: {} })>",
  "Capabilities": "<unsupported: SecurityCapabilities(SecurityCapabilities { value: 0 })>",
  "HistoryId": "<unsupported: UniqueId(UniqueId { index: 0, time: 0, random: 0 })>",
  "LinkedSource": "<unsupported: ContentId(ContentId { url: \"\" })>",
  "Sandboxed": false,
  "ScriptGuid": "{B23C5B55-A379-4926-A256-20E321A663F3}",
  "Source": "--[[\n---------------------------------------------------------------------\nCreated by: V3N0M_Z\nAPI: https://github.com/00xima/SimplePath\n---------------------------------------------------------------------\n]]\n\nlocal PathfindingService = game:GetService(\"PathfindingService\")\nlocal RunService = game:GetService(\"RunService\")\nlocal Players = game:GetService(\"Players\")\n\n--Used to display waypoints\nlocal displayPart = Instance.new(\"Part\")\ndisplayPart.Size = Vector3.new(1, 1, 1)\ndisplayPart.Anchored = true\ndisplayPart.CanCollide = false\ndisplayPart.Color = Color3.fromRGB(255, 255, 255)\ndisplayPart.Material = Enum.Material.Neon\ndisplayPart.Shape = Enum.PartType.Ball\n\nlocal nonHumanoidRestrictions = {\n\tBlocked = \":Blocked()\";\n}\nlocal Path = {\n\tStatus = {\n\t\tPathNotFound = \"PathNotFound\";\n\t\tPathCompleted = \"PathCompleted\";\n\t\tPathBlocked = \"PathBlocked\";\n\t};\n}\nPath.__index = function(tab, index)\n\tif not tab._humanoid then\n\t\tassert(not nonHumanoidRestrictions[index], (nonHumanoidRestrictions[index] or \"\")..\" cannot be used for a non-humanoid model\")\n\tend\n\treturn (tab._signals[index] and tab._signals[index].Event) or Path[index]\nend\nlocal function GetNum(i, j) return Random.new(tick()):NextNumber(i, j) end\n\n--Execute if Path.IgnoreObstacles is true\nlocal function RetryPath(self)\n\tif self.IgnoreObstacles and self._goal then\n\t\tself._humanoid.Jump = true\n\t\tself._model.PrimaryPart.Velocity = (self._model.PrimaryPart.CFrame.LookVector * self._humanoid.WalkSpeed * 3) + Vector3.new(0, self._humanoid.JumpPower, 0)\n\t\tself._active = false\n\t\tself:Run(self._goal)\n\tend\nend\n\n--Move the humanoid model\nlocal function Move(self)\n\tif self._active then\n\t\tif self._humanoid then\n\t\t\tself._humanoid:MoveTo(self._waypoints[self._waypoint].Position)\n\t\tend\n\tend\nend\n\n--Detect for gaps between waypoints\nlocal function JumpDetect(self)\n\tif self._waypoints[self._waypoint + 1] and self._humanoid then\n\t\tlocal p0 = self._waypoints[self._waypoint].Position\n\t\tlocal p1 = self._waypoints[self._waypoint + 1].Position\n\t\tlocal pos = (p1 - p0).Unit * ((p1 - p0).Magnitude / 2) + p0\n\t\tlocal raycast = workspace:Raycast(pos + Vector3.new(0, 0.1, 0), Vector3.new(0, -1000, 0))\n\t\tif (p1.Y - p0.Y  >= self._hipHeight) or (raycast and p1.Y - raycast.Position.Y  >= self._hipHeight) then\n\t\t\tself._humanoid.Jump = true\n\t\tend\n\tend\nend\n\n--Check and fire the WaypointReached event\nlocal function FireWaypointReached(self)\n\tlocal lastPos = (self._waypoint - 1 > 0 and self._waypoints[self._waypoint - 1].Position) or self._model.PrimaryPart.Position\n\tlocal nextPos = self._waypoints[self._waypoint].Position\n\tif lastPos == nextPos then return end\n\tself._signals.WaypointReached:Fire(self._model, lastPos, nextPos)\nend\n\n--Execute when humanoid reaches waypoint\nlocal function WaypointReached(self, reached)\n\tFireWaypointReached(self)\n\n\tif not self._humanoid then\n\t\tif self._waypoint < #self._waypoints then\n\t\t\tself._waypoint += 1\n\t\telse\n\t\t\tself:Stop(self.Status.Reached)\n\t\t\tself._signals.Reached:Fire(self._model)\n\t\tend\n\t\treturn\n\tend\n\n\tif reached and self._waypoint < #self._waypoints then\t\n\t\tJumpDetect(self)\n\t\tself._waypoint += 1\n\t\tMove(self)\n\telseif reached then\n\t\tself:Stop(self.Status.PathCompleted)\n\t\tself._signals.Reached:Fire(self._model)\n\telse\n\t\tRetryPath(self)\n\t\tself:Stop(self.Status.PathBlocked)\n\t\tself._signals.Blocked:Fire(self._model)\n\tend\nend\n\n--Fix the computed waypoints to make the path transition seamless\nlocal function CleanWaypoints(self, newWaypoints, finalPosition)\n\tlocal cleanedWaypoints = {}\n\tfor _, waypoint in ipairs(newWaypoints) do\n\t\tlocal angle = math.acos((finalPosition - self._model.PrimaryPart.Position).Unit:Dot((waypoint.Position - self._model.PrimaryPart.Position).Unit))\n\t\tif angle < 150 * (math.pi / 180) then\n\t\t\ttable.insert(cleanedWaypoints, waypoint)\n\t\tend\n\tend\n\treturn cleanedWaypoints\nend\n\n--Get initial waypoint for non-humanoid models\nlocal function GetNonHumanoidWaypoint(self)\n\tfor i, waypoint in ipairs(self._waypoints) do\n\t\tlocal mag = (waypoint.Position - self._model.PrimaryPart.Position).Magnitude\n\t\tif mag > 2 then\n\t\t\treturn i\n\t\tend\n\tend\n\treturn 1\nend\n\n--Destroy visual waypoints\nlocal function DestroyWaypoints(waypoints)\n\treturn (waypoints and (function()\n\t\tfor _, waypoint in ipairs(waypoints) do\n\t\t\twaypoint:Destroy()\n\t\tend\n\tend)())\nend\n\n--Create visual waypoints\nlocal function CreateWaypoints(waypoints)\n\tlocal displayParts = {}\n\tfor _, waypoint in ipairs(waypoints) do\n\t\tlocal displayPartClone = displayPart:Clone()\n\t\tdisplayPartClone.Position = waypoint.Position\n\t\tdisplayPartClone.Parent = workspace\n\t\ttable.insert(displayParts, displayPartClone)\n\tend\n\treturn displayParts\nend\n\n--Execute when the humanoid doesn't reach waypoint in time\nlocal function Timeout(self)\n\tRetryPath(self)\n\tself:Stop(self.Status.PathBlocked)\n\tself._signals.Blocked:Fire(self._model)\nend\n\nlocal function GetFacingSide(part, face)\n\tlocal facing, val = nil, -7\n\tif math.abs(part.CFrame.LookVector[face]) >= val then val = math.abs(part.CFrame.LookVector[face]); facing = \"Z\" end\n\tif math.abs(part.CFrame.UpVector[face]) >= val then val = math.abs(part.CFrame.UpVector[face]); facing = \"Y\" end\n\tif math.abs(part.CFrame.RightVector[face]) >= val then val = math.abs(part.CFrame.RightVector[face]); facing = \"X\" end\n\treturn facing\nend\n\nfunction Path.GetRandomPosition(part)\n\tassert(part:IsA(\"BasePart\"), \"Part must be a valid BasePart\")\n\tlocal faces = {X = GetFacingSide(part, \"X\"), Y = GetFacingSide(part, \"Y\"), Z = GetFacingSide(part, \"Z\")}\n\tlocal p0 = part.Position + Vector3.new(0, (part.Size[faces.X] / 2) + 1, 0) + Vector3.new(0, part.Size[faces.Y] / 2, 0)\n\tlocal x = part.Position.X + GetNum(-part.Size[faces.X] / 2, part.Size[faces.X] / 2)\n\tlocal y = part.Position.Y + GetNum(-part.Size[faces.Y] / 2, part.Size[faces.Y] / 2)\n\tlocal z = part.Position.Z + GetNum(-part.Size[faces.Z] / 2, part.Size[faces.Z] / 2)\n\tlocal p1 = Vector3.new(x, y, z)\n\tlocal params = RaycastParams.new()\n\tparams.FilterType = Enum.RaycastFilterType.Whitelist\n\tparams.FilterDescendantsInstances = {part}\n\tlocal result = workspace:Raycast(p0, (p1 - p0).Unit * (part.Size.X * part.Size.Y * part.Size.Z))\t\n\treturn (result and result.Position and result.Position + Vector3.new(0, 1 / 2, 0)) or Path.GetRandomPosition(part)\nend\n\nfunction Path.GetNearestCharacter(part)\n\tassert(part:IsA(\"BasePart\"), \"Part must be a valid BasePart\")\n\tlocal c, m = nil, -1\n\tfor _, p in ipairs(Players:GetPlayers()) do\n\t\tif p.Character and (p.Character.PrimaryPart.Position - part.Position).Magnitude > m then\n\t\t\tc, m = p.Character, (p.Character.PrimaryPart.Position - part.Position).Magnitude\n\t\tend \n\tend\n\treturn c\nend\n\nfunction Path.GetNearestCharacterPosition(part)\n\tassert(part:IsA(\"BasePart\"), \"Part must be a valid BasePart\")\n\tlocal model = Path.GetNearestCharacter(part)\n\treturn (model and model.PrimaryPart.Position)\nend\n\nfunction Path.new(model, agentParameters)\n\tassert(model:IsA(\"Model\") and model.PrimaryPart, \"Model must by a valid Model Instance with a set PrimaryPart\")\n\n\tlocal self = setmetatable({\n\t\t_signals = {\n\t\t\tReached = Instance.new(\"BindableEvent\");\n\t\t\tBlocked = Instance.new(\"BindableEvent\");\n\t\t\tWaypointReached = Instance.new(\"BindableEvent\");\n\t\t\tStopped = Instance.new(\"BindableEvent\");\n\t\t};\n\t\t_connections = {};\n\t\t_model = model;\n\t\t_path = PathfindingService:CreatePath(agentParameters);\n\t\t_humanoid = model:FindFirstChildOfClass(\"Humanoid\") or false;\n\t\tIgnoreObstacles = true;\n\t}, Path)\n\n\tif self._humanoid then\n\t\tself._hipHeight = self._humanoid.HipHeight\n\t\tself._connections = {self._humanoid.MoveToFinished:Connect(function(reached)\n\t\t\tif self._active then\n\t\t\t\tself._elapsed = tick()\n\t\t\t\tWaypointReached(self, reached)\n\t\t\tend\n\t\tend)}\n\tend\n\treturn self\nend\n\nfunction Path:SetHipHeight(hipHeight)\n\tassert(type(hipHeight) == \"number\" and hipHeight > 0, \"HipHeight must be a valid number above 0\")\n\tself._hipHeight = hipHeight\nend\n\nfunction Path:Destroy()\n\tfor _, signal in ipairs(self._signals) do\n\t\tsignal:Destroy()\n\t\tself._signals[signal] = nil\n\tend\n\tfor _, connection in ipairs(self._connections) do\n\t\tconnection:Disconnect()\n\tend\n\tDestroyWaypoints(self._displayParts)\n\tself._connections = nil\n\tself._humanoid = nil\n\tself._path = nil\n\tself._goal = nil\nend\n\nfunction Path:Stop(status)\n\tself._signals.Stopped:Fire(self._model, status)\n\tself._active = false\n\tself._elapsed = false\n\tself._displayParts = (self._displayParts and DestroyWaypoints(self._displayParts))\nend\n\nfunction Path:Run(goal)\n\n\tif not goal and not self._humanoid and self._goal then\n\t\tWaypointReached(self, true)\n\t\treturn\n\tend\n\tassert(goal and (typeof(goal) == \"Vector3\" or goal:IsA(\"BasePart\")), \"Goal must be a valid BasePart or a Vector3 position\")\n\tassert(self._hipHeight ~= 0, \"Chracter hipHeight is 0; set a new hipHeight using Path:SetHipHeight() before using Path:Run()\")\n\tpcall(function() self._model.PrimaryPart:SetNetworkOwner(nil) end)\n\n\tlocal initialPosition = self._model.PrimaryPart.Position\n\tlocal finalPosition = (typeof(goal) == \"Vector3\" and goal) or goal.Position\n\tlocal success, msg = pcall(function()\n\t\tself._path:ComputeAsync(initialPosition, finalPosition)\n\tend)\n\tif not success or self._path.Status == Enum.PathStatus.NoPath or not self._path:GetWaypoints() or #self._path:GetWaypoints() == 0 or (self._humanoid and self._humanoid.FloorMaterial == Enum.Material.Air and self._model.PrimaryPart.Velocity.Magnitude >= 1) then\n\t\tself:Stop(self.Status.PathNotFound)\n\t\treturn false\n\tend\n\n\tself._waypoints = (self._active and CleanWaypoints(self, self._path:GetWaypoints(), finalPosition)) or self._path:GetWaypoints()\n\tself._waypoint = 1\n\tself._goal = goal\n\tDestroyWaypoints(self._displayParts)\n\tself._displayParts = (self.Visualize and CreateWaypoints(self._waypoints))\n\n\tif not self._humanoid then\n\t\tself._waypoint = GetNonHumanoidWaypoint(self)\n\t\tWaypointReached(self, true)\n\t\treturn\n\tend\n\n\tif not self._active then\n\t\tself._active = true\n\t\tMove(self)\n\t\tcoroutine.wrap(function()\n\t\t\twhile self._active do\n\t\t\t\tif self._elapsed and tick() - self._elapsed > 1 then\n\t\t\t\t\tTimeout(self); break\n\t\t\t\tend\n\t\t\t\tRunService.Stepped:Wait()\n\t\t\tend\n\t\tend)()\n\tend\n\n\treturn true\nend\n\nreturn Path",
  "SourceAssetId": "<unsupported: Int64(6744337775)>",
  "Tags": "<unsupported: Tags(Tags { members: [] })>",
  "UniqueId": "<unsupported: UniqueId(UniqueId { index: 25865, time: 142155861, random: 1232354692393223026 })>"
}